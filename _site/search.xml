<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[jQuery 解决 click 和 dblclick 冲突]]></title>
      <url>/jquery/javascript/2018/09/11/jQuery-%E8%A7%A3%E5%86%B3-click-%E5%92%8C-dblclick-%E5%86%B2%E7%AA%81/</url>
      <content type="text"><![CDATA[  click 是单击事件， dblclick 是双击事件如果给一个 DOM 元素同时绑定两个事件，则会导致响应 dblclick 时会同时响应 click制定延迟策略  set() 用于为待执行方案设置一个延迟  clear() 用于清空设置的延迟var clickTimeout = {  _timeout: null,  set: function (fn) {    var that = this    that.clear()    that._timeout = setTimeout(fn, 300)  },  clear: function () {    var that = this    if (that._timeout) {      clearTimeout(that._timeout)    }  }}为单击事件添加延迟操作  由于单击事件默认优先响应，所以需要为单击事件设置延迟策略，从而给双击事件足够的响应时间$('#btn').on('click', function () {	clickTimeout.set(function () {		console.log('this is click')	})})在响应双击事件时清空延迟  双击事件响应完毕后，清空延迟策略$('#btn').on('dblclick', function() {	clickTimeout.clear()	conosle.log('this is dblckick')})]]></content>
      <categories>
        
          <category> jquery </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Lambda forEach 关于 return 的使用]]></title>
      <url>/java/lambda/2018/09/11/Lambda-forEach-%E5%85%B3%E4%BA%8E-return-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="text"><![CDATA[  JDK8 中新增的 Lambda 表达式对于 for 循环的操作变得非常简洁但其中的 forEach 和 for 之间存在一定差异比如 forEach 无法使用 break 和 continueforEach 实现和 contiune 一样的效果  参见以下代码可知，在 forEach 中 return 可实现和 contiune 一样的效果int[] arrs = new int[]{1, 3, 9, 2};arrs.forEach(arr -&gt; {	if (arr &gt; 4) {		return;	}	// 输出 1 3 2	System.out.println(arr);})forEach 实现和 break 一样的效果  对不起，臣妾做不到]]></content>
      <categories>
        
          <category> java </category>
        
          <category> lambda </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> lambda </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Apache POI 操作 Excel 导出]]></title>
      <url>/java/poi/2018/09/11/Java-Apache-POI-%E6%93%8D%E4%BD%9C-Excel-%E5%AF%BC%E5%87%BA/</url>
      <content type="text"><![CDATA[  Java 可以通过 Apache POI 操作 Excel 的导入导出Apache POI 是一套操作 Microsoft Office 套件的开源 Java APIJAR 包依赖及介绍  请参见 Java Apache POI 操作 Excel 导入实现步骤创建 Excel 实体类，用于同一接收导出数据  headers 用于存储导出数据时规定的表格头部内容  cells 是一个在 List 中嵌套 List 的结构          外层的 List 表示行数据      内层的 List 表示列数据      结合起来也就是有多少行多少列的数据        如果导出的内容存在多个 sheet ，只需要使用一个 Map ，通过 key-value 的形式包装 Excel 实体类即可          例如 Map&lt;String, Excel&gt; excels ，Map 中的 key 就是 sheet 的名称      public class Excel {    // 表头    private List&lt;String&gt; headers = Lists.newArrayList();    // 内容    private List&lt;List&lt;String&gt;&gt; cells = Lists.newArrayList();    // 省略 Getter/Setter 方法}举一个上述实体类使用的例子  传入的数据本身就很复杂，需要导出的数据也存在多个 sheetprivate Map&lt;String, Excel&gt; wrapFeedbackQuestions(Map&lt;String, ArrayList&lt;FeedbackQuestion&gt;&gt; feedbackQuestionMap) {    Map&lt;String, Excel&gt; excels = Maps.newHashMap();    if (feedbackQuestionMap.isEmpty()) {        throw new TSharkException("统计数据转换异常，请咨询管理员");    }    List&lt;String&gt; divide = Lists.newArrayList();    feedbackQuestionMap.forEach((k, v) -&gt; {        Excel excel = new Excel();        excel.addHeader("题目");        excel.addHeader("小计");        v.forEach(feedbackQuestion -&gt; {            // 按照约定格式每行添加数据            List&lt;String&gt; row = Lists.newArrayList();            row.add(feedbackQuestion.getContent());            row.add(feedbackQuestion.getCount().toString());            excel.addCell(row);        });        excels.put(k, excel);    });    return excels;}构建 ExcelExportUtil 工具类  Map&lt;String, Excel&gt; excel 是通过上述操作构建好的数据结构  String filePath 是生成 Excel 后，存放文件的地址  initHeaderStyle() 和 initCellStyle() 是对表格样式的初始化，在后续步骤中提供  formatLongValue() 是为了防止单元格内容过长，而设置的超过一定量长度添加换行符public static String export(Map&lt;String, Excel&gt; excel, String filePath) {    HSSFWorkbook workbook = new HSSFWorkbook();    // 表头样式    HSSFCellStyle headerStyle = initHeaderStyle(workbook);    // 单元格样式    HSSFCellStyle cellStyle = initCellStyle(workbook);    excel.forEach((key, value) -&gt; {        HSSFSheet sheet = workbook.createSheet(key);        List&lt;String&gt; headers = value.getHeaders();        List&lt;List&lt;String&gt;&gt; cells = value.getCells();        // 表头包装        HSSFRow headerRow = sheet.createRow(0);        for (int i = 0; i &lt; headers.size(); i++) {            HSSFCell cell = headerRow.createCell(i);            cell.setCellValue(headers.get(i));            cell.setCellStyle(headerStyle);        }        // 内容包装        for (int j = 0; j &lt; cells.size(); j++) {            HSSFRow row = sheet.createRow(j + 1);            List&lt;String&gt; child = cells.get(j);            for (int k = 0; k &lt; child.size(); k++) {                HSSFCell cell = row.createCell(k);                cell.setCellValue(formatLongValue(child.get(k)));                cell.setCellStyle(cellStyle);            }        }        // 自动撑开列宽        sheet.autoSizeColumn((short) 0);        sheet.autoSizeColumn((short) 1);    });    // 保存文件并返回名称    String fileName = FileUtil.getRandomFileNameByDate();    try {        String fullFileName = filePath + fileName + FILE_SUFFIX;        FileOutputStream stream = new FileOutputStream(fullFileName);        workbook.write(stream);        stream.flush();    } catch (Exception e) {        logger.error("Excel导出失败，", e);    }    return fileName;}initHeaderStyle() 初始化表头样式  对表头单元格的字体、颜色、背景做一些自定义操作private static HSSFCellStyle initHeaderStyle(HSSFWorkbook workbook) {    // 表头字体    HSSFFont font = workbook.createFont();    font.setFontHeightInPoints((short) 15);    font.setColor(HSSFColor.WHITE.index);    // 表头样式    HSSFCellStyle headerStyle = workbook.createCellStyle();    headerStyle.setFont(font);    headerStyle.setWrapText(true);    headerStyle.setFillBackgroundColor(HSSFColor.GREEN.index);    headerStyle.setFillForegroundColor(HSSFColor.GREEN.index);    // 需要设置此项，单元格背景色才会生效    headerStyle.setFillPattern(CellStyle.SOLID_FOREGROUND);    return headerStyle;}initCellStyle 初始化单元格样式private static HSSFCellStyle initCellStyle(HSSFWorkbook workbook) {    // 单元格字体    HSSFFont font = workbook.createFont();    font.setFontHeightInPoints((short) 15);    // 单元格样式    HSSFCellStyle cellStyle = workbook.createCellStyle();    cellStyle.setFont(font);    cellStyle.setWrapText(true);    return cellStyle;}formatLongValue 格式化超长内容  需要单元格启用 setWrapText = true 才会生效private static String formatLongValue(String value) {    // 长度限制    int limit = 50;    // 没有达到限制直接返回    if (value.length() &lt; 50) {        return value;    }    StringBuilder stringBuilder = new StringBuilder();    // 设置长度限制的正则匹配    Pattern p = Pattern.compile("(.{" + limit + "}|.*)");    Matcher m = p.matcher(value);    while (m.find()) {        String group = m.group();        // 字符不存在则跳过        if (group == null || group.trim().equals("")) {            continue;        }        // 超过限制添加换行符        stringBuilder.append(group);        stringBuilder.append("\n");    }    return stringBuilder.toString();}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> poi </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> poi </tag>
        
          <tag> excel </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[preventDefault 和 stopPropagation 的区别]]></title>
      <url>/javascript/2018/09/04/preventDefault-%E5%92%8C-stopPropagation-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="text"><![CDATA[  在使用 JS 阻止默认动作时，通常会使用 preventDefault 或 stopPropagation ，但两者存在一定区别preventDefault  如下方法中，.training-name-input 存在与一个表单中，该元素监听了键盘的回车事件  如果不使用 e.preventDefault() 则会在触发该监听的同时，触发表单中 type="submit" 按钮的提交事件  所以 preventDefault 的关键作用在于通知浏览器不执行与事件关联的默认动作$diplomaContentPanel.find('.training-name-input').on('keydown', function (e) {  e.preventDefault()  if (e.keyCode === 13) {		// 只响应回车事件  }})stopPropagation  如下方法中，carousel-indicators li 是一个插件的节点，本身就被插件赋予了点击事件  但是使用时希望屏蔽该插件赋予的点击事件，这个时候就需要使用 e.stopPropagation()  作用在于，阻止 DOM 元素继续向下冒泡，在执行了该点击方法后，就停止了，不再响应被赋予的其他点击事件$noviceGuidePanel.find('.carousel-indicators li').on('click', function (e) {	e.stopPropagation()})]]></content>
      <categories>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IDEA 隐藏四周的工具按钮栏]]></title>
      <url>/software/idea/2018/08/31/IDEA-%E9%9A%90%E8%97%8F%E5%9B%9B%E5%91%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%8C%89%E9%92%AE%E6%A0%8F/</url>
      <content type="text"><![CDATA[  IDEA 默认会在界面四周显示各种工具的按钮，没什么卵用，通过以下方式可以隐藏隐藏方式  如图所示取消 Tool Buttons 的勾选即可]]></content>
      <categories>
        
          <category> software </category>
        
          <category> idea </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> idea </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery 手动触发按键按下]]></title>
      <url>/jquery/2018/08/30/jQuery-%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B/</url>
      <content type="text"><![CDATA[  通过 jQuery 可以手动触发指定按键被按下的动作实现方式  关于按键的码表可以参考 jQuery 禁用右键菜单、复制功能// 首先获取按键的事件var e = $.Event('keydown')// 然后指定按键的类型e.which = 27// 最后在需要被触发的元素上触发该按键$noviceGuidePanel.trigger(e)]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
          <tag> keycode </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[HTML5+CSS3 为 input 添加一键删除按钮]]></title>
      <url>/css/2018/08/25/HTML5+CSS3-%E4%B8%BA-input-%E6%B7%BB%E5%8A%A0%E4%B8%80%E9%94%AE%E5%88%A0%E9%99%A4%E6%8C%89%E9%92%AE/</url>
      <content type="text"><![CDATA[  经常可以看到一些 input 输入框在输入文字后，输入框末尾会出现一键删除的按钮实现方式基础布局  &lt;input/&gt; 末尾必须添加 required 标记，这是 HTML5 的验证标记  准备一个用于显示删除按钮的 DOM 元素，例如以下代码中的 &lt;span/&gt; ，图标自备&lt;div class="invite-code-panel"&gt;  &lt;input type="text" class="invite-code-input" placeholder="请输入实训计划邀请码/助飞码" required&gt;  &lt;span class="editable-clear-x"&gt;&lt;/span&gt;&lt;/div&gt;CSS 控制按钮显示  删除按钮默认隐藏  通过 :valid + 可以控制当 &lt;input/&gt; 输入内容后 &lt;span/&gt; 则显示.invite-code-panel .editable-clear-x {  right: 15px;  display: none;}.invite-code-panel .invite-code-input:valid + .editable-clear-x {  display: inline;}注意点  需要注意的是如果没有为 &lt;input/&gt; 添加 required 标记，:valid + 属性则不会生效  本文只是实现了按钮的自动隐藏/显示，点击按钮后的删除操作需要通过 JS 自行实现]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Buefy 用户界面组件库]]></title>
      <url>/vue/frame/2018/08/24/Buefy-%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
      <content type="text"><![CDATA[  Buefy 是一款基于 Bumla 的 Vue.js 用户界面组件库官网Buefy]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> frame </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> frame </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot+MyBatis 框架搭建]]></title>
      <url>/java/springboot/mybatis/2018/08/23/SpringBoot+MyBatis-%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
      <content type="text"><![CDATA[  基础框架使用 SpringBoot持久层使用 MyBatis数据源使用 Druid数据库使用 MySQL创建 Java Web 项目，并配置 POM  该 POM 只包含最基础的配置，没有任何多余 JAR 包&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;!-- 项目基础信息 --&gt;  &lt;groupId&gt;com.asing1elife.newso&lt;/groupId&gt;  &lt;artifactId&gt;asl-newso&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;!-- SpringBoot 基础依赖 --&gt;  &lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;  &lt;/parent&gt;  &lt;!-- 指定编码格式和 JDK 版本 --&gt;  &lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;!-- SpringBoot 相关依赖 --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;      &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;      &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;      &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;      &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- MyBatis 相关依赖 --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;1.3.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- MySQL 相关依赖 --&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;6.0.6&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Druid 相关依赖 --&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;druid&lt;/artifactId&gt;      &lt;version&gt;1.1.9&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;      &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;1.1.9&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;&lt;/project&gt;指定端口号  在 /resources 根目录创建 application.yml 文件并添加如下内容  表示端口号为 8080  以及项目请求根路径为 /newsoserver:  port: 8080  servlet:    context-path: /newso指定数据源  在 application.yml 中添加如下内容为数据源连接信息  数据源使用过的是阿里的 Druidspring:  datasource:    name: newso_dev    url: jdbc:mysql://127.0.0.1:3306/newso_dev?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false    username: root    password: root    type: com.alibaba.druid.pool.DruidDataSource    driver-class-name: com.mysql.cj.jdbc.Driver    druid:      filters: stat      max-active: 20      initial-size: 1      max-wait: 60000      min-idle: 1      time-between-eviction-runs-millis: 60000      min-evictable-idle-time-millis: 300000      validation-query: select 'x'      test-while-idle: true      test-on-borrow: false      test-on-return: false      pool-prepared-statements: true      max-open-prepared-statements: 20指定 MyBatis 配置  同样可在 application.yml 中指定 MyBatis 的配置信息  mapper-locations 是指定 mapper 文件所在位置  type-aliases-package 是指定对应实体类所在位置mybatis:  mapper-locations: classpath:mapper/*.xml  type-aliases-package: com.asing1elife.newso.dto作为前后分离项目必不可少的结果集对象  前后分离项目都是采用前端发起请求，后端返回结果  为了保证后端返回结果的统一性，所以需要如下的结果集对象  只有这样前端在处理后端返回结果时，才能有规范的操作public class ResponseData {    private static final String SUCCESS_CODE = "0";    private static final String ERROR_CODE = "-1";    private String status = SUCCESS_CODE;    private Object data;    ...    public boolean isSuccess() {        return this.status.equalsIgnoreCase(SUCCESS_CODE);    }    public void setError(Object data) {        this.status = ERROR_CODE;        this.data = data;    }}控制层基础控制类  基础控制类的作用在于可以在调用逻辑层代码时有一个统一的预处理操作或者后置操作public class SimpleActionHandler {    private Logger log = LoggerFactory.getLogger(this.getClass());    // 当前请求    private String action;    public SimpleActionHandler(HttpServletRequest request) {        // 记录当前请求        this.action = request.getRequestURI();    }    public void doAction(ResponseData responseData) {        throw new RuntimeException("This method must be overide");    }    public ResponseData handle(HttpServletRequest... requests) {        ResponseData responseData = new ResponseData();        try {            doAction(responseData);        } catch (Exception e) {            log.info(this.action, e);            responseData.setError(e.getMessage());        }        return responseData;    }}创建控制层接收请求信息@RestController@RequestMapping("/api/homes")public class HomeController extends AbstractBaseController {    @GetMapping("")    public ResponseData main() {        return new SimpleActionHandler(request) {            @Override            public void doAction(ResponseData responseData) {                System.out.println("welcome");            }        }.handle();    }}MyBatis 通过自定义接口规范 DAO 层  通过 @Mapper 注解可以确保容器只扫描被注解的 DAO    @Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documented@Component@Mapperpublic @interface MyBatisRepository {}      创建 DAO 接口  在 DAO 接口使用自定义的注解即可保证该接口被容器扫描到@MyBatisRepositorypublic interface NewsDaoMyBatis {    List&lt;NewsDTO&gt; getNewss();}创建 Mapper 文件  Mapper 文件的 DTD 都是统一格式的，按照如下规范即可&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.asing1elife.newso.module.news.dao.NewsDaoMyBatis"&gt;  &lt;select id="getNewss" resultType="NewsDTO"&gt;    SELECT      ne.id,      ne.title,      ne.brief,      ne.author_id AS 'author.id',      ne.createTime    FROM      ns_news ne  &lt;/select&gt;&lt;/mapper&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 组件中监听路由变化]]></title>
      <url>/vue/2018/08/21/Vue-%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9B%91%E5%90%AC%E8%B7%AF%E7%94%B1%E5%8F%98%E5%8C%96/</url>
      <content type="text"><![CDATA[  在 Vue 的组件中可以通过 watch 监听到当前路由的变化实现方式  在 watch 按照如下规则书写即可  该监听会在路由发生变化时触发watch: {	'$route' (val, old) {		// 当前路由		console.log(val)		// 上一个路由		console.log(old)	}}]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> watch </tag>
        
          <tag> router </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[vuex 在非组件中调用 mutations 方法]]></title>
      <url>/vue/vuex/2018/08/14/vuex-%E5%9C%A8%E9%9D%9E%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%B0%83%E7%94%A8-mutations-%E6%96%B9%E6%B3%95/</url>
      <content type="text"><![CDATA[  一般情况下调用 mutations.js 中的方法都是在组件中，如果想在非组件中调用，则需要使用如下方式在组件中调用import {mapMutations} from 'vuex'import {SET_IS_LOGIN} from 'store/mutation-types'export default {	methods: {		...mapMutations({			set_is_login: SET_IS_LOGIN		}),		init() {			this.set_is_login(true)		}	}}在非组件中调用import store from 'store'import {SET_IS_LOGIN} from 'store/mutation-types'function init() {	store.commit(SET_IS_LOGIN, true)}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> vuex </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> vuex </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[vuex 在非组件中调用 actions 方法]]></title>
      <url>/vue/vuex/2018/08/14/vuex-%E5%9C%A8%E9%9D%9E%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%B0%83%E7%94%A8-actions-%E6%96%B9%E6%B3%95/</url>
      <content type="text"><![CDATA[  一般情况下调用 actions.js 中的方法都是在组件中，如果想在非组件中调用，则需要如下方式在组件中import {mapActions} from 'vuex'export default {	methods: {		...mapActions([			'setUserInfo'		])	},	init() {		let user = {}				this.setUserInfo(user)	}}在非组件中import store from 'store'function init() {	let user = {}	store.dispatch('setUserInfo', user)}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> vuex </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> vuex </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JS 判断对象是否为空]]></title>
      <url>/javascript/es6/2018/08/14/JS-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/</url>
      <content type="text"><![CDATA[  ES6 新增了 Object.keys() 可将对象自身可枚举属性转换为数组实现方式let obj = {}let objArr = Object.keys(obj)console.log(objArr.length) // 0]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> es6 </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> es6 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[v-for 遍历 Map]]></title>
      <url>/vue/2018/08/11/v-for-%E9%81%8D%E5%8E%86-Map/</url>
      <content type="text"><![CDATA[  通常情况下都是使用 v-for 遍历 List 或 Array ，但 v-for 对于 Map 遍历也是支持的遍历方式  下列代码展现的是一种比较复杂的情况，在 Map 的 value 中存放的是一个 List&lt;ul v-for="(value, key) in questions" :key="key"&gt;	&lt;li&gt;&lt;/li&gt;	&lt;ul v-for="val in value" :key="val.hexId"&gt;		&lt;li&gt;&lt;/li&gt;	&lt;/ul&gt;&lt;/ul&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> for </tag>
        
          <tag> map </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[简单封装浏览器 cookie 工具类]]></title>
      <url>/vue/2018/08/10/%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E6%B5%8F%E8%A7%88%E5%99%A8-cookie-%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      <content type="text"><![CDATA[  目前主流浏览器一般都支持 cookie ，以下对 cookie 的操作进行简单封装，以方便使用主体封装类import { storagePrefix } from 'assets/scripts/config/config'import { verify, uri } from 'assets/scripts/tools'/** * cookies操作类 */export default new class Cookie {  /**   * 构造函数   */  constructor() {    this.defaults = {}    this.expiresMultiplier = 60 * 60 * 24    this.prefix = storagePrefix  }  /**   * 根据key获取cookie的值   * @param {string} key 键   * @returns {object} 值   */  get(key) {    if (!key) {      throw new Error('没有找到key。')    }    if (typeof key === 'object') {      throw new Error('key不能是一个对象。')    }    let cookies = this.all()    let value = cookies[this.prefix + key]    try {      value = JSON.parse(value)    } catch (e) {      value = {}    }    return value  }  /**   * 设置cookies   * @param key 键   * @param value 值   * @param options 选项   * @returns {Cookie}   */  set(key, value, options) {    options = verify.isObject(options) ? options : {expires: options}    let expires = options.expires !== undefined ? options.expires : (this.defaults.expires || '')    let expiresType = typeof (expires)    if (expiresType === 'string' &amp;&amp; expires !== '') {      expires = new Date(expires)    } else if (expiresType === 'number') {      expires = new Date(+new Date() + 1000 * this.expiresMultiplier * expires)    }    if (expires !== '' &amp;&amp; 'toGMTString' in expires) {      expires = ';expires=' + expires.toGMTString()    }    let path = options.path || this.defaults.path    path = path ? ';path=' + path : ''    let domain = options.domain || this.defaults.domain    domain = domain ? ';domain=' + domain : ''    let secure = options.secure || this.defaults.secure ? ';secure' : ''    if (options.secure === false) secure = ''    document.cookie = uri.encode(this.prefix + key) + '=' + uri.encode(JSON.stringify(value)) + expires + path + domain + secure    return this  }  /**   * 删除cookie   * @param {string||array} keys 删除cookie的key   * @returns {Cookie}   */  remove(keys) {    keys = verify.isArray(keys) ? keys : [keys]    for (let i = 0, l = keys.length; i &lt; l; i++) {      this.set(keys[i], '', -1)    }    return this  }  /**   * 获取所有的cookie   * @returns {object} cookie对象   */  all() {    let cookie = document.cookie    if (cookie === '') return {}    let cookieArr = cookie.split('; ')    let result = {}    for (let i = 0, l = cookieArr.length; i &lt; l; i++) {      let item = cookieArr[i].split('=')      let key = uri.decode(item.shift())      let value = uri.decode(item.join(''))      result[key] = value    }    return result  }}verify 工具类export default new class Verify {  // 验证url是否正确，true/false  isUrl (url) {    return (/(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-.,@?^=%&amp;:/~+#]*[\w\-@?^=%&amp;/~+#])?/i).test(url)  }    // 验证手机号码是否正确， true/false  isTel (tel) {    return (/^1[3|4|5|8][0-9]\d{4,8}$/).test(tel)  }    // 判断是否是object对象  isObject (value) {    return !!value &amp;&amp; Object.prototype.toString.call(value) === '[object Object]'  }    // 判断是否是数组  isArray (value) {    return Object.prototype.toString.call(value) === '[object Array]'  }}uri 工具类export default new class Uri {  decode (value) {    return decodeURIComponent(value)  }    encode (value) {    return encodeURIComponent(value)  }}config 基础配置// 本地存储的前缀export const storagePrefix = 'tshark_quick_storage_']]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> cookie </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot+Shiro前后端分离项目通过JWT实现自动登录]]></title>
      <url>/java/springboot/shiro/vue/2018/08/09/SpringBoot+Shiro%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%80%9A%E8%BF%87JWT%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/</url>
      <content type="text"><![CDATA[  虽然 Shiro 本身可以支持扩展 RememberMe 功能，但仅限于传统项目因为 Shiro 的用户信息是基于 Session 进行管理，在前后端分离的项目中无法实现 Session 状态的前后统一所以本文通过 JWT 对 Shiro 原生的 Session 控制进行替换，从而实现用户信息的前后传递及判断涉及资料  一个已经实现的例子  JWT官网  JWT源码导入项目所需的依赖  对于 SpringBoot 和 Shiro 的依赖此处不重复介绍  以下是 JWT 的依赖包，就一个即可&lt;dependency&gt;  &lt;groupId&gt;com.auth0&lt;/groupId&gt;  &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;  &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;创建 JWTToken 替换 Shiro 原生 Token  Shiro 原生的 Token 中存在用户名和密码以及其他信息 [验证码，记住我]  在 JWT 的 Token 中因为已将用户名和密码通过加密处理整合到一个加密串中，所以只需要一个 token 字段即可public class JWTToken implements AuthenticationToken {    // 密钥    private String token;    public JWTToken(String token) {        this.token = token;    }    @Override    public Object getPrincipal() {        return token;    }    @Override    public Object getCredentials() {        return token;    }}创建 JWTUtil 整合 JWT 相关操作  在这个工具类中可以实现对用户名和密码的加密处理，校验 token 是否正确，获取用户名等操作  Algorithm algorithm = Algorithm.HMAC256(password) 是对密码进行加密后再与用户名混淆在一起  在签名时可以通过 .withExpiresAt(date) 指定 token 的过期时间public class JWTUtil {    // 过期时间30天    private static final long EXPIRE_TIME = 24 * 60 * 30 * 1000;    /**     * 校验token是否正确     *     * @param token    密钥     * @param username 登录名     * @param password 密码     * @return     */    public static boolean verify(String token, String username, String password) {        try {            Algorithm algorithm = Algorithm.HMAC256(password);            JWTVerifier verifier = JWT.require(algorithm).withClaim("username", username).build();            DecodedJWT jwt = verifier.verify(token);            return true;        } catch (Exception e) {            return false;        }    }    /**     * 获取登录名     *     * @param token     * @return     */    public static String getUsername(String token) {        try {            DecodedJWT jwt = JWT.decode(token);            return jwt.getClaim("username").asString();        } catch (JWTDecodeException e) {            return null;        }    }    /**     * 生成签名     *     * @param username     * @param password     * @return     */    public static String sign(String username, String password) {        try {            // 指定过期时间            Date date = new Date(System.currentTimeMillis() + EXPIRE_TIME);            Algorithm algorithm = Algorithm.HMAC256(password);            return JWT.create()                    .withClaim("username", username)                    .withExpiresAt(date)                    .sign(algorithm);        } catch (UnsupportedEncodingException e) {            return null;        }    }}创建 JWTFilter 实现前端请求统一拦截及处理  executeLogin() 方法中的 getSubject(request, response).login(token) 就是触发 Shiro Realm 自身的登录控制，具体内容需要手动实现  executeLogin() 始终返回 true 的原因是因为具体的是否登录成功的判断，需要在 Realm 中手动实现，此处不做统一判断  LOGIN_SIGN 是前端放置在 headers 头文件中的登录标识，如果用户发起的请求是需要登录才能正常返回的，那么头文件中就必须存在该标识并携带有效值public class JWTFilter extends BasicHttpAuthenticationFilter {    // 登录标识    private static String LOGIN_SIGN = "Authorization";    /**     * 检测用户是否登录     * 检测header里面是否包含Authorization字段即可     *     * @param request     * @param response     * @return     */    @Override    protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) {        HttpServletRequest req = (HttpServletRequest) request;        String authorization = req.getHeader(LOGIN_SIGN);        return authorization != null;    }    @Override    protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception {        HttpServletRequest req = (HttpServletRequest) request;        String header = req.getHeader(LOGIN_SIGN);        JWTToken token = new JWTToken(header);        getSubject(request, response).login(token);        return true;    }    @Override    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {        if (isLoginAttempt(request, response)) {            try {                executeLogin(request, response);            } catch (Exception e) {                throw new TSharkException("登录权限不足！", e);            }        }        return true;    }    /**     * 对跨域提供支持     *     * @param request     * @param response     * @return     * @throws Exception     */    @Override    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {        HttpServletRequest httpServletRequest = (HttpServletRequest) request;        HttpServletResponse httpServletResponse = (HttpServletResponse) response;        httpServletResponse.setHeader("Access-control-Allow-Origin", httpServletRequest.getHeader("Origin"));        httpServletResponse.setHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS,PUT,DELETE");        httpServletResponse.setHeader("Access-Control-Allow-Headers", httpServletRequest.getHeader("Access-Control-Request-Headers"));        // 跨域时会首先发送一个option请求，这里我们给option请求直接返回正常状态        if (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) {            httpServletResponse.setStatus(HttpStatus.OK.value());            return false;        }        return super.preHandle(request, response);    }}自定义 ShiroDatabaseRealm 实现 Shiro Realm 的登录控制  重写 Realm 的 supports()  方法是通过 JWT 进行登录判断的关键          因为前文中创建了 JWTToken 用于替换 Shiro 原生 token      所以必须在此方法中显式的进行替换，否则在进行判断时会一直失败        登录的合法验证通常包括 token 是否有效 、用户名是否存在 、密码是否正确          通过 JWTUtil 对前端传入的 token 进行处理获取到用户名      然后使用用户名前往数据库获取到用户密码      再将用户面传入 JWTUtil 进行验证即可      public class ShiroDatabaseRealm extends AuthorizingRealm {    private Logger logger = LoggerFactory.getLogger(this.getClass());    @Autowired    private ShiroAuthService shiroAuthService;    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        logger.info("doGetAuthorizationInfo+" + principals.toString());        String username = JWTUtil.getUsername(principals.toString());        MemberDTO member = shiroAuthService.getPrincipal(username);        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();        List&lt;String&gt; userPermissions = shiroAuthService.getPermissions(member.getId());        // 基于Permission的权限信息        info.addStringPermissions(userPermissions);        return info;    }    /**     * 使用JWT替代原生Token     *     * @param token     * @return     */    @Override    public boolean supports(AuthenticationToken token) {        return token instanceof JWTToken;    }    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) throws AuthenticationException {        String token = (String) authcToken.getCredentials();        String username = JWTUtil.getUsername(token);        MemberDTO member = shiroAuthService.getPrincipal(username);        // 用户不会空        if (member != null) {            // 判断是否禁用            if (member.getStatus().equals(MemberStatus.disableStatus)) {                throw new DisabledAccountException("901");            }            // 密码验证            if (!JWTUtil.verify(token, username, member.getLoginPassword())) {                throw new UnknownAccountException("900");            }            return new SimpleAuthenticationInfo(token, token, "realm");        } else {            throw new UnknownAccountException("900");        }    }}在 ShiroConfiguration 中将所有的请求指向 JWT  指定手工实现的 ShiroDatabaseRealm 用于传入 DefaultWebSecurityManager  在 securityManager 中关闭默认的 Session 控制          因为在前后分离项目中前端是无法获取到后端 Session 的，即无法实现用户登录状态的同步        在 shiroFilterFactoryBean() 中传入自定义的 TokenFilter          并将所有的请求指向该过滤器 filterRuleMap.put("/**", "jwt")      @Configuration@ConditionalOnWebApplicationpublic class ShiroConfiguration {    @Bean    public ShiroDatabaseRealm shiroDatabaseRealm() {        return new ShiroDatabaseRealm();    }    @Bean("securityManager")    public DefaultWebSecurityManager securityManager(ShiroDatabaseRealm shiroDatabaseRealm) {        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();        securityManager.setRealm(shiroDatabaseRealm);        // 关闭自带session        DefaultSessionStorageEvaluator evaluator = new DefaultSessionStorageEvaluator();        evaluator.setSessionStorageEnabled(false);        DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO();        subjectDAO.setSessionStorageEvaluator(evaluator);        securityManager.setSubjectDAO(subjectDAO);        return securityManager;    }    @Bean("shiroFilter")    public ShiroFilterFactoryBean shiroFilterFactoryBean(DefaultWebSecurityManager securityManager) {        ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();        Map&lt;String, Filter&gt; filterMap = new HashMap&lt;&gt;();        filterMap.put("jwt", new JWTFilter());        factoryBean.setFilters(filterMap);        factoryBean.setSecurityManager(securityManager);        Map&lt;String, String&gt; filterRuleMap = new HashMap&lt;&gt;();        filterRuleMap.put("/**", "jwt");        factoryBean.setFilterChainDefinitionMap(filterRuleMap);        return factoryBean;    }    @Bean    @DependsOn("lifecycleBeanPostProcessor")    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);        return defaultAdvisorAutoProxyCreator;    }    @Bean    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {        return new LifecycleBeanPostProcessor();    }    @Bean    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager) {        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();        advisor.setSecurityManager(securityManager);        return advisor;    }}执行登录操作时对用户信息进行基础验证并签名返回  ResponseData 是前后分离项目中用于统一后端返回数据的类，必不可少          一般包含状态值和返回的具体内容      @RestController@RequestMapping("")@Api("用户登录")public class LoginController extends AbstractBaseController {    @Autowired    private LoginServiceImpl loginService;    @PostMapping("/login")    @ApiOperation("登录")    public ResponseData login(@RequestParam String username, @RequestParam String password) {        return new SimpleActionHandler(request) {            @Override            public void doAction(ResponseData responseData) throws Exception {                responseData.setData(loginService.jwtLogin(username, password));            }        }.handle();    }}  进行登录操作处理时需要判断数据有效性，即 数据是否为空，密码是否正确  一般为了用户隐私和安全起见，数据库中存入的密码都是经过 不可逆混淆 处理的          所以此处在通过 JWTUtil 签名之前，需要将用户传入的密码进行相同混淆，再将混淆后的两个密码进行对比      如果密码正确，通过相同规则混淆后的密码也会相同      @Servicepublic class LoginServiceImpl extends AbstractBaseService {    @Autowired    private MemberServiceImpl memberService;    /**     * 用户登录     *     * @param username     * @param password     * @return     */    public String jwtLogin(String username, String password) {        Assert.notNull(username, "用户名不能为空");        Assert.notNull(password, "密码不能为空");        // 获取用户密码混淆值        MemberDTO member = memberService.getMemberSalt(username);        // 加密当前用户输入密码        byte[] bytePassword = DigestUtil.sha1(password.getBytes(), EncodeUtils.hexDecode(member.getSalt()), Constants.PASSWORD_HASH_INTERATIONS);        String encodePassword = EncodeUtils.hexEncode(bytePassword);        if (!encodePassword.equals(member.getLoginPassword())) {            throw new TSharkException("900");        }        return JWTUtil.sign(username, encodePassword);    }}在前端的请求发起基类中对头文件进行统一传递  由于本项目用的 SPA 模式，除了欢迎页不需要登录，其余页面都需要登录后才能访问          因此在基类中对头文件进行统一处理，默认所有请求都会传递用户登录状态      个别不需要传递登录状态的，再进行单独处理        在头文件中指定 Authorization 自定义信息，对应的 token 值是用户登录后存入到 vuex 中的数组import axios from 'axios'import router from 'router'import store from 'store'import qs from 'qs'import { SET_USER_INFO } from 'store/mutation-types'import * as config from 'assets/scripts/config/config'axios.defaults.withCredentials = trueconst setUserInfo = function (user) {  store.commit(SET_USER_INFO, user)}const getUserInfo = function () {  return store.state.userInfo.token}export default function fetch(options) {  return new Promise((resolve, reject) =&gt; {    const instance = axios.create({      baseURL: `${config.serverBaseUrl}mop`,      timeout: 10000,      withCredentials: true,      credentials: 'include'    })    // 针对头文件是否为空，会做一些权限控制    if (options.headers === undefined) {      // 没有指定头文件的使用默认头文件，需要传入用户信息      options.headers = {        'Content-Type': 'application/x-www-form-urlencoded',        'Authorization': getUserInfo()      }    }    // 表单提交格式需要进行参数转换    if (options.headers['Content-Type'].indexOf('x-www-form') !== -1) {      // 参数格式转换      options.data = qs.stringify(options.data)    }    instance(options).then((response) =&gt; {      let result = response.data      // 无数据      if (!result) {        return false      }      // 未授权      if (result.status === config.UNAUTHORIZED_CODE || result.data === config.UNAUTHORIZED_CODE) {        // 清空用户信息        setUserInfo(null)        // 跳转至登录界面        router.replace({name: 'portal'})        return false      }      resolve(result)      return false    }).catch((error) =&gt; {      reject(error)      // 清空用户信息      setUserInfo(null)      router.replace({name: 'portal'})    })  })}单独处理不需要头文件的请求  由于 fetch.js 中对头文件存在 undefined 的判断，所以外部如果传入头文件，则可以替换默认的头文件配置import fetch from 'assets/scripts/fetch/fetch'import * as config from 'assets/scripts/config/config'let baseUrl = '/api/portals'/** * 轮播列表 */export function covers() {  const url = `${baseUrl}/covers`  return fetch({    url: url,    method: config.GET,    headers: config.VISITOR_HEADER  })}  实际开发中通常会存在一个 config.js 文件，用于存储一系列通用配置信息// 游客头文件export const VISITOR_HEADER = {  'Content-Type': 'application/x-www-form-urlencoded'}用户登录成功后将后端返回的 token 值存入 cookie  登录操作实际应该对用户名和密码进行有效性判断，以及登录失败后的错误提示，此处都省略，重点突出将 token 值存入 vuex 的步骤&lt;template&gt;  &lt;div ref="portal" class="container portal-panel"&gt;	  ...    &lt;mt-field placeholder="请输入手机号或邮箱" v-model.trim="user.username" :state="state.username"                         @keyup.enter.native="sendLogin"&gt;&lt;/mt-field&gt;    &lt;mt-field placeholder="请输入密码" type="password" v-model.trim="user.password" :state="state.password"                        @keyup.enter.native="sendLogin"&gt;&lt;/mt-field&gt;    &lt;mt-button type="primary" @click.native="sendCaptcha"&gt;&lt;/mt-button&gt;	  ...  &lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;  import { mapMutations } from 'vuex'  import { SET_USER_INFO } from 'store/mutation-types'  export default {    name: 'portal',    data() {      return {        countDown: 0,        timer: null,        user: {          username: '',          password: ''        }      }    },    methods: {      ...mapMutations({        set_user_info: SET_USER_INFO      }),      // 用户登录      sendLogin() {        ...        this.$fetch.login.login({          username: this.user.username,          password: this.user.password        }).then((res) =&gt; {			...          this.$toast.success('登录成功')          this.set_user_info({            token: res.data,            isLogin: true          })			...        })      }		...  }&lt;/script&gt;&lt;style lang="stylus" rel="stylesheet/stylus"&gt;  ...&lt;/style&gt;vuex 处理 token 值  在 mutations.js 中，当存入用户信息时          一份存入 session ，供日常使用      一份存入 cookie ，有效期 30 天，供自动登录使用，具体的 cookie 存值方式，请参见 简单封装浏览器 cookie 工具类        同时需要确保，当用户手动退出后执行用户信息清除时，需要同时清除 cookie/** vuex所有的mutation */// 引入mutations-typesimport * as types from './mutation-types'import { sessionStorage, cookieStorage } from 'assets/scripts/storage'// 定义mutation，其内部是一些修改方法const mutations = {  // 第一个参数是状态值  // 第二个参数为提交状态修改是传入的对象参数  [types.SET_USER_INFO](state, userInfo) {    state.userInfo = userInfo || {}    if (userInfo === null) {      sessionStorage.remove('userInfo')      cookieStorage.remove('userInfo')    } else {      sessionStorage.set('userInfo', userInfo)      cookieStorage.set('userInfo', userInfo, 30)    }  }	...}// 暴露给外部export default mutations在请求首页时判断是否可以自动登录  在 router.js 的最后添加 router.beforeEach() ，可以在链接跳转之前执行一些预判操作  如果 cookie 中存在用户登录信息，则将信息取出重新放入 vuex ，并在后续操作中直接跳转至登录后的首屏页面/** * 全局路由配置 * 路由开始之前的操作 */router.beforeEach((to, from, next) =&gt; {  // 获取当前请求的名称  // let toName = to.name  // 获取当前请求的路径  let toPath = to.path  // 请求首页时判断用户是否存在本地登录信息  if (toPath.indexOf('portal') === 1) {    // 获取用户信息    let userInfo = cookieStorage.get('userInfo')    // 存在用户信息    if (userInfo !== undefined &amp;&amp; userInfo.token !== undefined) {      // 将用户信息重新进行状态管理      store.commit(SET_USER_INFO, userInfo)    }  }  // 获取用户登录标识  let isLogin = store.state.userInfo.isLogin  // 用户未登录，且请求的不是首页或首页子页面  if (!isLogin &amp;&amp; toPath.indexOf('portal') !== 1) {    // 跳转到登录页面    next({      name: 'portal'    })  } else {    // 用户已登录，且请求的是登录页面    if (isLogin &amp;&amp; toPath.indexOf('portal') === 1) {      // 跳转到首页      next({        path: serverBaseUrl      })    } else {      // 默认操作      next()    }  }})]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> shiro </category>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> shiro </tag>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Slack设置VPN代理]]></title>
      <url>/software/slack/2018/08/01/Slack%E8%AE%BE%E7%BD%AEVPN%E4%BB%A3%E7%90%86/</url>
      <content type="text"><![CDATA[  Slack 目前看来应该是被墙了，但 Slack 本身不支持配置代理，所以可以使用 mac 本身的自动配置代理方式进行代理该方法理论上适配其他需要被代理的请求链接官网slack-proxy下载 pac 文件  在 slack-proxy-github 下载 slack-proxy.pac 文件获取本地代理地址  由于我使用的是 lantern ，所以在 lantern 的配置项中可以找到其对应的代理地址  其他软件可自行 Google 如何获取代理地址修改 pac 文件中的本地代理地址  使用编辑器打开 slack-proxy.pac ，内容如下  将 SOCKS 后面的地址改为自己本地有效的代理地址function FindProxyForURL(url, host) {    if (shExpMatch(host, "*.slack-msgs.com")) {                // Use SOCK proxy, or fall back to a DIRECT traffic.        // ssh -D 8000 [user]@[server]        return "SOCKS 127.0.0.1:51218; DIRECT";    }    return "DIRECT";}在 mac 的系统配置中指定代理文件  一开始已经说过 Slack 本身不支持配置代理，所以需要使用系统本身的特性进行代理配置  依次打开 系统偏好配置 &gt; 网络 &gt; 选择WIFI &gt; 右下角高级 &gt; 代理  勾选 自动代理配置 ，并在右侧输入框中输入上述修好的 slack-proxy.pac 文件  保存即可]]></content>
      <categories>
        
          <category> software </category>
        
          <category> slack </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> slack </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux ssh]]></title>
      <url>/linux/2018/07/29/Linux-ssh/</url>
      <content type="text"><![CDATA[  ssh 可用于远程登录指定服务器基本语法  输入以下语法后，如果存在密码则需要交互式的输入密码ssh 10.24.232.71绕过交互式密码输入安装 sshpass 插件yum install -y sshpass在 ssh 语句之前使用 sshpass 指定密码sshpass -p '1nn0va1e-qsx' ssh 10.47.120.134绕过 RSA key 验证  对于部分没有安装 RSA key 的服务器，在登录时会需要确认 RSA 信息  通过在 ssh 语句后添加 -o "StrictHostKeyChecking no" 即可绕过ssh -o "StrictHostKeyChecking no" 10.47.120.134防止远程启动 nohup &amp; 无法跳出进程  在执行基础脚本后加上 &gt;/dev/null 2&gt;&amp;1 &amp; 可以将由远程输出到本地的无用信息导向一个空的目录并且后台运行ssh web1 "/opt/mop-server/run.sh &gt;/dev/null 2&gt;&amp;1 &amp;"]]></content>
      <categories>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IDEA 安装 Jrebel]]></title>
      <url>/software/idea/2018/07/24/IDEA-%E5%AE%89%E8%A3%85-Jrebel/</url>
      <content type="text"><![CDATA[  虽然 IDEA 本身支持热部署，但功能较弱，只支持方法内部代码更新，如果新增方法则需要重启项目，使用 Jrebel 可以实现完全的项目热部署Jrebel 安装  Jrebel 提供了 IDEA 的插件支持，进入插件列表搜索下载即可  但 Jrebel 不是免费的，需要激活为什么要激活 Jrebel  之前的 Jrebel 有个人版，支持 Facebook 账号的免费激活使用，但目前 Jrebel 更新到 2018.1.4 版本后已经下线了个人版，只提供企业版  企业版 Jrebel 的价格实在有点贵，而且也是按年付费Jrebel 实现本地激活下载激活文件  前往 Jrebel License Server 下载 ReverseProxy_darwin_amd64 该文件是 mac 可使用的为文件添加权限并运行chmod 777 ./ReverseProxy_darwin_amd64$bash ./ReverseProxy_darwin_amd64运行成功后显示如下内容前往 Jrebel 配置界面按如下输入  地址后面需要跟一串 GUID 验证  邮箱可随意输入输入成功显示激活后要立即将 Jrebel 设置为离线模式，可确保 180 有效性  180 天后重复上述操作即可  如果不设置为离线模式，终端运行的程序就不能退出，一旦退出激活就会失效 ]]></content>
      <categories>
        
          <category> software </category>
        
          <category> idea </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> idea </tag>
        
          <tag> jrebel </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC多环境配置]]></title>
      <url>/java/springmvc/2018/07/23/SpringMVC%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  SpringMVC 可以使用 Spring 本身提供的 profile 特性对多环境配置文件进行统一集成，自动切换存在的必要  日常开发中，一般都存在多个环境，开发、测试、生产  上述环境对应的数据库及配置文件都会存在不同，所以为项目集成多环境配置很有必要实现方式  集成方式有多种，网上介绍的大多是使用 &lt;beans profile="dev"&gt; 去区分不同的 *.properties 文件  还可以使用 @Profile 进行不同环境代码加载  本文介绍的是使用 &lt;beans profile="dev"&gt; 直接在同一个 xml 文件中区分不同环境需要的不同配置项XML配置  注意如果使用了多环境的配置的 xml 文件中存在其他公有属性，这些属性需要放在最前面，否则会报错&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:p="http://www.springframework.org/schema/p"       xsi:schemaLocation="http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans-4.0.xsd"&gt;  &lt;description&gt;spring-data-redis-cluster&lt;/description&gt;  &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;    &lt;property name="maxIdle" value="${redis.pool.maxIdle}"/&gt;    &lt;property name="maxTotal" value="${redis.pool.maxActive}"/&gt;    &lt;property name="maxWaitMillis" value="${redis.pool.maxWait}"/&gt;    &lt;property name="testOnBorrow" value="${redis.pool.testOnBorrow}"/&gt;  &lt;/bean&gt;  ...  &lt;beans profile="dev"&gt;    &lt;bean id="jedisPool" class="redis.clients.jedis.JedisPool"&gt;      &lt;constructor-arg index="0" ref="jedisPoolConfig"/&gt;      &lt;constructor-arg index="1" value="${redis.server.url}"/&gt;      &lt;constructor-arg index="2" value="${redis.server.port}" type="int"/&gt;      &lt;constructor-arg index="3" value="${redis.server.timeout}" type="int"/&gt;      &lt;constructor-arg index="4" value="${redis.server.password}"/&gt;    &lt;/bean&gt;    &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt;      &lt;property name="hostName" value="${redis.server.url}"/&gt;      &lt;property name="port" value="${redis.server.port}"/&gt;      &lt;property name="password" value="${redis.server.password}"/&gt;      &lt;property name="poolConfig" ref="jedisPoolConfig"/&gt;    &lt;/bean&gt;  &lt;/beans&gt;  &lt;beans profile="prod"&gt;    &lt;bean id="redisClusterConfiguration" class="org.springframework.data.redis.connection.RedisClusterConfiguration"&gt;      ...    &lt;/bean&gt;    &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt;      &lt;constructor-arg ref="redisClusterConfiguration"/&gt;      &lt;constructor-arg ref="jedisPoolConfig"/&gt;    &lt;/bean&gt;  &lt;/beans&gt;&lt;/beans&gt;开发环境启动方式  IDEA 需要在启动时添加脚本 -Dspring.profiles.active="dev" 以确保使用开发环境启动生产环境启动方式  Linux 环境需要前往 Tomcat 的 /bin 目录下，需要 ./catalina.sh 中的 JAVA_OPTS 内容如下  JAVA_OPTS="$JAVA_OPTS -Dspring.profiles.active=prod"]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> profile </tag>
        
          <tag> spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IDEA 自动导入包]]></title>
      <url>/software/idea/2018/07/23/IDEA-%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%8C%85/</url>
      <content type="text"><![CDATA[  IDEA 默认只会提示需要导入包，但不会自动导入解决方法  可以起到自动导入包，以及自动移除无用包的作用]]></content>
      <categories>
        
          <category> software </category>
        
          <category> idea </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> idea </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IDEA 智能提示不区分大小写]]></title>
      <url>/software/idea/2018/07/23/IDEA-%E6%99%BA%E8%83%BD%E6%8F%90%E7%A4%BA%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99/</url>
      <content type="text"><![CDATA[  IDEA 默认的智能提示会区分大小写，通过以下方式可解决解决方法]]></content>
      <categories>
        
          <category> software </category>
        
          <category> idea </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> idea </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[高德地图 JS API]]></title>
      <url>/javascript/amap/2018/07/22/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE-JS-API/</url>
      <content type="text"><![CDATA[  高德地图对于开发者提供一套 JS API ，可用于将高德地图集成到网站中官网  开发者平台  代码在线调试  开发手册]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> amap </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> amap </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[连接 MySQL 抛出 Establishing SSL connection 警告]]></title>
      <url>/java/database/2018/07/11/%E8%BF%9E%E6%8E%A5-MySQL-%E6%8A%9B%E5%87%BA-Establishing-SSL-connection-%E8%AD%A6%E5%91%8A/</url>
      <content type="text"><![CDATA[  Java 连接 MySQL 时控制台出现多条 Establishing SSL connection without 警告解决办法  在连接数据库的 url 最后加上 useSSL=false 即可    jdbc:mysql://localhost:3306/hts_lb?characterEncoding=UTF-8&amp;tinyInt1isBit=false&amp;useSSL=false      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> database </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[移动端弹出遮罩层时防止底部页面滚动]]></title>
      <url>/vue/javascript/2018/07/10/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%B9%E5%87%BA%E9%81%AE%E7%BD%A9%E5%B1%82%E6%97%B6%E9%98%B2%E6%AD%A2%E5%BA%95%E9%83%A8%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/</url>
      <content type="text"><![CDATA[  如果底部页面内容过多出现滚动条，此时弹出遮罩层后，在遮罩层滑动页面也会导致底部页面响应滚动操作解决办法  监听遮罩层的打开和关闭          打开时设置底部页面的 position: fixed      关闭时恢复默认布局 position: static      watch: {  'popupVisible'(val) {    if (val) {      this.$refs.portal.style.position = 'fixed'    } else {      this.$refs.portal.style.position = 'static'    }  }}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
          <tag> dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 动态赋值 class]]></title>
      <url>/vue/2018/06/29/Vue-%E5%8A%A8%E6%80%81%E8%B5%8B%E5%80%BC-class/</url>
      <content type="text"><![CDATA[  Vue 在操作 DOM 元素的 class 属性时，有以下多种方法比较通用的是否赋值方式  通过以下 :class="{show: show}" 的方式可以决定该元素是否拥有名称为 show 的 class          data() 中的 show 属性为 true ，则赋予 show class ，否则不赋予      &lt;template&gt;	&lt;div class="watch-mooc-panel" :class="{show: show}"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;  export default {    name: 'mooc',    data() {      return {        show: false      }    }  }&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt;    .watch-mooc-panel      width 100%      height 100%      position absolute      transition background-color .3s      &amp;.show        background-color #000000&lt;/style&gt;使用三目运算符的方式  注意使用三木运算符添加的属性语法和上述方式存在明显区别&lt;template&gt;	&lt;div class="watch-mooc-panel" :class="show ? 'show' : 'hide'"&gt;&lt;/div&gt;&lt;/template&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mint-UI Infinite Scroll 无限滚动运用]]></title>
      <url>/vue/mintui/2018/06/25/Mint-UI-Infinite-Scroll-%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8%E8%BF%90%E7%94%A8/</url>
      <content type="text"><![CDATA[  Mint-UI 自带一个支持无限滚动的组件，以下是用法官网文档Infinite Scroll使用方法  v-infinite-scroll 指定加载内容的方法，在满足触发条件时，则会加载          注意如果内容加载的分页方法就一个，此处指定后，则不需要再通过 created() 调用分页方法，否则一开始会加载两次        infinite-scroll-distance 触发方法的阈值，底部距离的像素值&lt;div class="real-content" v-infinite-scroll="getMoocs" infinite-scroll-distance="10"&gt;  &lt;div class="hot-item" v-for="mooc in moocs" :key="mooc.hexId"&gt;    ...  &lt;/div&gt;&lt;/div&gt;注意点  值得注意的是该组件提供了一个 infinite-scroll-disabled 属性，文档中的说明是若为真，则无限滚动不会被触发          这很容易让人理解为当分页检测到没有下一页后，则不再触发无限滚动，但其实根本达不到这个效果      翻阅 官方 GitHub 上作者的解释 才知道这个属性其实为了防止分页内容在加载过程中重复加载，当内容加载完毕后，会被内部重置      所以要实现到达尾页后不再重复发起分页请求，需要通过以下方法      getMoocs() {	// 检测是否存在下一页  if (!this.page.hasNext) {    return false  }  this.$fetch.mooc.page(this.page).then((res) =&gt; {    this.page = new Page(res.data)    this.moocs = _.concat(this.moocs, res.data.list)  })}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> mintui </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> mintui </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot前后分离项目实现自定义登录拦截]]></title>
      <url>/java/springboot/shiro/2018/06/24/SpringBoot%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA/</url>
      <content type="text"><![CDATA[  通常的 shiro 登录拦截对于 /login 操作可设置为 authc 模式，但前后分离的项目直接设置会导致无法获取登录信息自定义登录拦截的实现  要实现自定义的登录拦截是继承 FormAuthenticationFilter 接口  对接口中的 onLoginSuccess 和 onLoginFailure 重写          从而根据登录成功和失败进行不同的操作记录      public class LoginFormAuthenticationFilter extends FormAuthenticationFilter {  // springBoot中存在与配置类的service类需要提供get/set方法手动收入，如果使用@Autowired会导致报错    private MemberLoginRecordServiceImpl memberLoginRecordService;    @Override    protected boolean onLoginSuccess(AuthenticationToken token, Subject subject, ServletRequest request, ServletResponse response) throws Exception {        // 处理会员登录成功操作        memberLoginRecordService.doAfterSuccessfullyLogin(request, subject);        return super.onLoginSuccess(token, subject, request, response);    }    @Override    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) {        return super.onLoginFailure(token, e, request, response);    }    public MemberLoginRecordServiceImpl getMemberLoginRecordService() {        return memberLoginRecordService;    }    public void setMemberLoginRecordService(MemberLoginRecordServiceImpl memberLoginRecordService) {        this.memberLoginRecordService = memberLoginRecordService;    }}将重写的拦截器注入到 shiro 配置中@Configuration@ConditionalOnWebApplicationpublic class ShiroConfiguration extends BaseShiroConfiguration {  ...  	// 手动注入自定义拦截器需要用到的service  	// 注入该service即可，service内部的其他类可实现自动注入    @Bean    public MemberLoginRecordServiceImpl memberLoginRecordService() {        return new MemberLoginRecordServiceImpl();    }    public ShiroFilterFactoryBean shiroFilterFactoryBean(DefaultWebSecurityManager securityManager) throws Exception {        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();        shiroFilterFactoryBean.setSecurityManager(securityManager);  		// 指定登录链接        shiroFilterFactoryBean.setLoginUrl("/login");        Map&lt;String, Filter&gt; filters = new LinkedHashMap&lt;String, Filter&gt;();          		// 配置自定义表单拦截器        LoginFormAuthenticationFilter authcFilter = new LoginFormAuthenticationFilter();        authcFilter.setRememberMeParam("rememberMe");  		// 注入上述引用的service类        authcFilter.setMemberLoginRecordService(memberLoginRecordService());  		// 选择指定拦截器的规则        filters.put("authc", authcFilter);        shiroFilterFactoryBean.setFilters(filters);  		// 配置不同接口规则        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;();  		// 登出操作由shiro管理        filterChainDefinitionMap.put("/logout", "anon");  		// 以下规则可直接访问        filterChainDefinitionMap.put("/api/portals/**", "anon");  		// 以下规则需要认证访问        filterChainDefinitionMap.put("/login", "authc");        filterChainDefinitionMap.put("/api/**", "authc");        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);        return shiroFilterFactoryBean;    }}以上方式在前后分离项目中会出现的问题  由于项目是前后分离的，前端发起的直接是访问 loginController 的请求  该请求由于配置了 authc 规则，则需要认证才能访问  所以就导致以上配置方式会直接报错  而如果将 /login 请求配置为 anon 规则，则会导致登录操作无法被自定义表单拦截器拦截解决方式  重写 FormAuthenticationFilter 接口的 onAccessDenied 方法  判断当前访问该规则的请求是否为登录请求  如果是登录请求则再次判断是否为登录提交请求 this.isLoginRequest          因为正常的登录请求中会存在一个访问登录页面和提交登录表单两个操作      而前后分离项目发起的必然是提交登录表单 this.isLoginSubmission        如果不是登录请求则返回 false@Overrideprotected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {    if (this.isLoginRequest(request, response) &amp;&amp; this.isLoginSubmission(request, response)) {        return true;    }    return false;}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> shiro </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> shiro </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 项目在 IE11 中数据更改后页面数据无变化]]></title>
      <url>/vue/javascript/2018/06/23/Vue-%E9%A1%B9%E7%9B%AE%E5%9C%A8-IE11-%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%94%B9%E5%90%8E%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E6%97%A0%E5%8F%98%E5%8C%96/</url>
      <content type="text"><![CDATA[  在 IE11 中运行 Vue 项目会发现提交表单数据后，列表数据没有变化出现问题的原因  在 IE11 中，如果 GET 请求相同的 URL ，浏览器默认会使用之前的缓存数据，而不是重新请求接口解决的方式  针对 IE 浏览器，在每个请求末尾都添加一个时间戳，保证每个请求都是独立的即可  因为其他浏览器不存在此问题，所以添加时对浏览器进行判断，只为 IE 添加if (window.ActiveXObject || 'ActiveXObject' in window) {  options.url = `${options.url}?${new Date().getTime()}`}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[URLSearchParams 在 IE11 中无法被识别]]></title>
      <url>/vue/javascript/2018/06/23/URLSearchParams-%E5%9C%A8-IE11-%E4%B8%AD%E6%97%A0%E6%B3%95%E8%A2%AB%E8%AF%86%E5%88%AB/</url>
      <content type="text"><![CDATA[  URLSearchParams 是用于拼接请求参数的工具类，但在 IE11 中无法被直接识别解决办法  在项目中安装 url-search-params-polyfill  在需要使用 URLSearchParams 的类中引入即可  引入之后可以按照正常操作使用 URLSearchParamsimport 'url-search-params-polyfill'...function dataTruncateMap (objs) {  let data = new URLSearchParams()  ...}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[为 IE 编写兼容性样式]]></title>
      <url>/css/ie/2018/06/15/%E4%B8%BA-IE-%E7%BC%96%E5%86%99%E5%85%BC%E5%AE%B9%E6%80%A7%E6%A0%B7%E5%BC%8F/</url>
      <content type="text"><![CDATA[  由于众所周知的原因，尽管 IE 非常傻 x ，但依旧存在很大的市场，所以必须为 IE11 编写一些特殊样式，才能让项目成功运行IE11 专有 hack  在此 @media 中编写的样式，只有在 IE11 才会生效@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {	.slide-right-pop-panel {		top 0	}}IE10 专有 hack  IE7 - IE9 的专有注释在 IE10 不适用，需要使用以下方式读取  @cc_on 为 IE10 脚本的功能检测名&lt;html&gt;&lt;!--[if !IE]&gt;&lt;!--&gt;&lt;script&gt;  if (/*@cc_on!@*/false) {    document.documentElement.className += ' ie10';  }&lt;/script&gt;&lt;!--&lt;![endif]--&gt;&lt;/html&gt;IE7 - IE9 专有 hack  以下编写的是 IE9 样式，其他只需要修改对应数字即可  通过为 &lt;html&gt; 添加对应的属性标签，可以完美区分各种 IE 浏览器样式&lt;!--[if IE 9 ]&gt; &lt;html class="ie9"&gt; &lt;![endif]--&gt;&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt; &lt;html class=""&gt; &lt;!--&lt;![endif]--&gt;...&lt;style&gt;.ie9 #teacherSection {  background-color: rgba(62, 137, 214, 1.000);}.ie9 #studentSection .student-item figure {  display: none;}&lt;/style&gt;&lt;/html&gt;]]></content>
      <categories>
        
          <category> css </category>
        
          <category> ie </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
          <tag> ie </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 添加自定义 JS 文件参与 ES6 转义]]></title>
      <url>/vue/javascript/es6/2018/06/14/Vue-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89-JS-%E6%96%87%E4%BB%B6%E5%8F%82%E4%B8%8E-ES6-%E8%BD%AC%E4%B9%89/</url>
      <content type="text"><![CDATA[  vue 中可能存在部分 JS 文件使用了 ES6 语法，但默认不会被 babel-loader 扫描到，从而出现编译后的项目 ES6 语法没有被转义报错信息  下列报错信息就是说明在 ::node_modules/quill-image-extend-module/index.js:: 文件中存在 ES6 的语法糖  由于目前大部分浏览器默认不支持 ES6 语法，所以项目编译后如果没有把 ES6 语法转义成 ES5 语法，浏览器则会报错ERROR in static/js/vendor.9447dc694e95071dbce3.js from UglifyJsUnexpected token operator «=», expected punc «,» [./node_modules/quill-image-extend-module/index.js:12,0][static/js/vendor.9447dc694e95071dbce3.js:28927,35]  Build failed with errors.解决方式  在 ::webpack.base.conf.js:: 中添加如下语法{  test: /\.js$/,  loader: 'babel-loader',  include: [    resolve('src'),    resolve('test'),	  // 只有这一行是添加的，由于指定自定义扫描文件    resolve('node_modules/quill-image-extend-module/index.js')  ],},]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
          <category> es6 </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
          <tag> es6 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript 获取窗体宽高]]></title>
      <url>/javascript/2018/06/14/Javascript-%E8%8E%B7%E5%8F%96%E7%AA%97%E4%BD%93%E5%AE%BD%E9%AB%98/</url>
      <content type="text"><![CDATA[  通过 Javascript 可以方便的获取浏览器窗体的宽高获取方式document.documentElement.clientHeightdocument.documentElement.clientWidth]]></content>
      <categories>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Wechat for mac 助手]]></title>
      <url>/mac/2018/06/12/Wechat-for-mac-%E5%8A%A9%E6%89%8B/</url>
      <content type="text"><![CDATA[  通过助手可实现注入消息防撤回等操作官网  TK-Wechat下载  终端运行如下操作，并按操作继续执行curl -o- -L https://raw.githubusercontent.com/lmk123/oh-my-wechat/master/install.sh | bash -s]]></content>
      <categories>
        
          <category> mac </category>
        
      </categories>
      <tags>
        
          <tag> mac </tag>
        
          <tag> wechat </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Touch UI 基于 Vue 的移动端框架]]></title>
      <url>/vue/frame/2018/06/07/Touch-UI-%E5%9F%BA%E4%BA%8E-Vue-%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6/</url>
      <content type="text"><![CDATA[  完全免费的高质量移动端框架官网Touch UI]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> frame </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> frame </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot实现全局异常捕获]]></title>
      <url>/java/springboot/2018/06/07/SpringBoot%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</url>
      <content type="text"><![CDATA[  SpringBoot 对异常可以进行全局捕获，按照如下操作即可创建全局异常捕获器  @RestControllerAdvice 是对 @RestController 的加强          该注解是 Spring2.3 之后提供的新功能，主要用于对原生 Controller 做一些低侵入性的增加辅助      被该注解标注的类，其中的方法会被应用到 @RestController 中      作用与 @RestController 中被标注 @RequestMapping 的方法        @ExceptionHandler 是自定义错误处理器，使用时可以注明具体需要处理的错误类型          一般需要标注默认异常和自定义异常即可        该错误捕获方式是将所有错误向上一直抛出至 Spring 容器，由 Spring 自行处理          所以如果在之前进行了 try-catch 操作，会导致 Spring 无法捕获到该异常      @RestControllerAdvicepublic class GlobalExceptionHandler {    public Logger log = LoggerFactory.getLogger(getClass());    @ExceptionHandler(TSharkException.class)    public ResponseData handleTSharkException(TSharkException e) {        log.error(e.getMessage());        ResponseData responseData = new ResponseData();        responseData.setError(e.getMessage());        return responseData;    }    @ExceptionHandler(Exception.class)    public ResponseData handleException(Exception e) {        log.error(e.getMessage());        String exceptionMessage = "";        ResponseData responseData = new ResponseData();        if (e.getMessage().contains("rollback")) {            exceptionMessage = "数据已被关联或使用，无法删除！";        }        responseData.setError(exceptionMessage);        return responseData;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> exception </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[elementui elform 支持回车提交]]></title>
      <url>/vue/elementui/2018/06/06/elementui-elform-%E6%94%AF%E6%8C%81%E5%9B%9E%E8%BD%A6%E6%8F%90%E4%BA%A4/</url>
      <content type="text"><![CDATA[  el-form 组件默认不支持回车提交，需要对提交按钮进行一下更改实现方式  在表单的提交按钮上添加 Vue 原生属性 native-type="submit" 可以让按钮变为表单提交按钮  当表单中只有一个输入框时，按钮会默认为提交按钮  设置默认的提交按钮后需要阻止表单默认提交事件，在表单上添加 @submit.native.prevent 即可&lt;el-form ref="form" :model="user" :rules="rules" class="login-form" @submit.native.prevent&gt;  &lt;el-row :gutter="20"&gt;    &lt;el-col :span="24"&gt;      &lt;el-form-item prop="username"&gt;        &lt;el-input v-model="user.username" placeholder="请输入用户名" autofocus&gt;          &lt;in-icon slot="prefix" :name="userIcon"&gt;&lt;/in-icon&gt;        &lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item prop="password"&gt;        &lt;el-input v-model="user.password" type="password" placeholder="请输入密码"&gt;          &lt;in-icon slot="prefix" :name="passwordIcon"&gt;&lt;/in-icon&gt;        &lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item&gt;        &lt;el-button type="primary" native-type="submit" class="submit-btn" @click="submitForm"&gt;登录&lt;/el-button&gt;      &lt;/el-form-item&gt;    &lt;/el-col&gt;  &lt;/el-row&gt;&lt;/el-form&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> elementui </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> elementui </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Element-ui 桌面端组件库]]></title>
      <url>/vue/frame/elementui/2018/06/06/Element-ui-%E6%A1%8C%E9%9D%A2%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
      <content type="text"><![CDATA[  Element-ui 是一套基于 Vue 2.0 的桌面端组件库官网Element-ui]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> frame </category>
        
          <category> elementui </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> frame </tag>
        
          <tag> elementui </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IDEA Java 注释格式优化]]></title>
      <url>/software/idea/2018/06/04/IDEA-Java-%E6%B3%A8%E9%87%8A%E6%A0%BC%E5%BC%8F%E4%BC%98%E5%8C%96/</url>
      <content type="text"><![CDATA[  IDEA 中关于 Java 通过快捷键添加的注释风格非常奇怪，可以通过以下方式进行优化取消注释默认靠左为注释自动添加空格]]></content>
      <categories>
        
          <category> software </category>
        
          <category> idea </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> idea </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IDEA 隐藏编辑器顶部 Tab 栏]]></title>
      <url>/software/idea/2018/06/03/IDEA-%E9%9A%90%E8%97%8F%E7%BC%96%E8%BE%91%E5%99%A8%E9%A1%B6%E9%83%A8-Tab-%E6%A0%8F/</url>
      <content type="text"><![CDATA[  为了纯粹的编程提现，顶部的 Tab 栏必须隐藏实现方式]]></content>
      <categories>
        
          <category> software </category>
        
          <category> idea </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> idea </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IDEA Tomcat 防止内存溢出]]></title>
      <url>/software/idea/2018/06/03/IDEA-Tomcat-%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
      <content type="text"><![CDATA[  IDEA 中运行运行默认配置的 Tomcat 经常会抛出 OutOfMemoryError： PermGen space 的错误错误原因  出现上述错误的原因是因为 Tomcat 默认配置的内存空间非常小  所以在运行较大项目时就会出现内存溢出的错误解决方法  在 VM options 中按需增加 -server -XX:PermSize=256M -XX:MaxPermSize=512m 的参数即可]]></content>
      <categories>
        
          <category> software </category>
        
          <category> idea </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> idea </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[使用节流函数防止请求重复发送]]></title>
      <url>/vue/javascript/2018/05/28/%E4%BD%BF%E7%94%A8%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E9%98%B2%E6%AD%A2%E8%AF%B7%E6%B1%82%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81/</url>
      <content type="text"><![CDATA[  在注入输入框监听的事件中，快速的输入可能会导致请求频繁发送构造节流函数  节流函数接收两个参数，一个是待执行方法体，一个是延迟时间export function debounce(func, delay) {	// 定义一个timer用于控制延迟	let timer	return function (...args) {		// 定时器存在则清空		if (timer) {			clearTimeout(timer)		}		// 初始化定时器		timer = setTimeout(() =&gt; {			// 在延迟达到或调用原有时间			func.apply(this, args)		}, delay)	}}运用节流函数  在 Vue 的监听中可以使用节流函数来派发监听方法  表示才 200 毫秒内重复触发该方法，不会重复派发this.$watch('query', debounce((newQuery) =&gt; {	this.$emit(query, newQuery)}, 200))]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[v-charts 基于 Vue 和 ECharts 封装的图表插件]]></title>
      <url>/vue/javascript/2018/05/24/v-charts-%E5%9F%BA%E4%BA%8E-Vue-%E5%92%8C-ECharts-%E5%B0%81%E8%A3%85%E7%9A%84%E5%9B%BE%E8%A1%A8%E6%8F%92%E4%BB%B6/</url>
      <content type="text"><![CDATA[  基于 Vue 和 ECharts 封装的图标插件官网v-charts]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
          <tag> charts </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vuex 属性与 v-model 绑定]]></title>
      <url>/vue/vuex/2018/05/23/Vuex-%E5%B1%9E%E6%80%A7%E4%B8%8E-v-model-%E7%BB%91%E5%AE%9A/</url>
      <content type="text"><![CDATA[  由于 Vuex 提供的是 mapGetters 和 mapActions 对属性行获取和操作，所以无法直接适配 v-model 的双向绑定形式官网Vuex 表单数据绑定 解决方式  上述 vuex 的官方文档中提供了适配 v-model 的解决方式  一种是重写 input 的双向绑定  另外一种是提供单独的计算属性，并写明 get / set 方法，将 vuex 的 mapGetters / mapActions 分别赋值  个人认为第二种方式更实用]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> vuex </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> vuex </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[js-base64 使用 JS 解码 base64]]></title>
      <url>/vue/javascript/2018/05/21/js-base64-%E4%BD%BF%E7%94%A8-JS-%E8%A7%A3%E7%A0%81-base64/</url>
      <content type="text"><![CDATA[  使用 JS 解码 base64官网js-base64]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[create-keyframe-animation	使用 JS 创建 CSS 动画]]></title>
      <url>/vue/javascript/2018/05/17/create-keyframe-animation-%E4%BD%BF%E7%94%A8-JS-%E5%88%9B%E5%BB%BA-CSS-%E5%8A%A8%E7%94%BB/</url>
      <content type="text"><![CDATA[#vue/plugin #javascript/plugin  实现通过 JS 编写 CSS3 动画官网create-keyframe-animation]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate 双向关联转换 JSON 防止死循环]]></title>
      <url>/java/hibernate/2018/05/17/Hibernate-%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94%E8%BD%AC%E6%8D%A2-JSON-%E9%98%B2%E6%AD%A2%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
      <content type="text"><![CDATA[  Hibernate 中经常存在双向关联的情况，此处将数据转换为 JSON 格式则可能导致死循环获取数据时只需要单向关联  这种情况下父类需要子类数据，而子类不需要父类数据@Entity@Table(name = "ht_feedback_template")public class FeedbackTemplate extends BaseModel {    @OneToMany(mappedBy = "feedbackTemplate", cascade = {CascadeType.ALL}, fetch = FetchType.LAZY)    @OrderBy("indexNo asc")    private Set&lt;FeedbackQuestion&gt; questions;    public Set&lt;FeedbackQuestion&gt; getQuestions() {        return questions;    }    public void setQuestions(Set&lt;FeedbackQuestion&gt; questions) {        this.questions = questions;    }}  在子类中对父类的引用字段加上 @JsonIgnore 即可@Entity@Table(name = "ht_feedback_question")public class FeedbackQuestion extends BaseModel {    @ManyToOne    @JsonIgnore    private FeedbackTemplate feedbackTemplate;    public FeedbackTemplate getFeedbackTemplate() {        return feedbackTemplate;    }    public void setFeedbackTemplate(FeedbackTemplate feedbackTemplate) {        this.feedbackTemplate = feedbackTemplate;    }}获取数据时确实需要双向关联  在父类对子类的引用字段加上 @JsonManagedReference@Entity@Table(name = "ht_feedback_template")public class FeedbackTemplate extends BaseModel {    @OneToMany(mappedBy = "feedbackTemplate", cascade = {CascadeType.ALL}, fetch = FetchType.LAZY)    @OrderBy("indexNo asc")  @JsonManagedReference    private Set&lt;FeedbackQuestion&gt; questions;    public Set&lt;FeedbackQuestion&gt; getQuestions() {        return questions;    }    public void setQuestions(Set&lt;FeedbackQuestion&gt; questions) {        this.questions = questions;    }}  在子类中对父类的引用字段加上 @JsonBackReference 即可@Entity@Table(name = "ht_feedback_question")public class FeedbackQuestion extends BaseModel {    @ManyToOne  @JsonBackReference    private FeedbackTemplate feedbackTemplate;    public FeedbackTemplate getFeedbackTemplate() {        return feedbackTemplate;    }    public void setFeedbackTemplate(FeedbackTemplate feedbackTemplate) {        this.feedbackTemplate = feedbackTemplate;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate Criteria 模糊查询]]></title>
      <url>/java/hibernate/2018/05/14/Hibernate-Criteria-%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  使用 Hibernate 的 Criteria 可以快速进行模糊查询实现方式  进行模糊查询时需要指定匹配模式，否则会出现无搜索结果的情况，例如 MatchMode.ANYWHERE  如果匹配的条件设置到类的属性，需要使用 createAlias() 指定别名，否则会抛出无法找到 user.name 属性Criterion userCri = Restrictions.like("user.name", username, MatchMode.ANYWHERE);Criteria criteria = getSession().createCriteria(trainingCri, userCri);criteria.createAlias("user", "user", JoinType.LEFT_OUTER_JOIN);criteria.list();]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
          <tag> criteria </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate 执行 SQL 查询]]></title>
      <url>/java/hibernate/2018/05/12/Hibernate-%E6%89%A7%E8%A1%8C-SQL-%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  Hibernate 支持执行原生 SQL 查询实现方式  通过 Session 对象可以使用 createSQLQuery() 方法，传入原生 SQL 语句即可  参数格式为 paramName = :paramCodepublic List&lt;Dictionary&gt; getDictionaries(String categoryCode) {    SQLQuery sqlQuery = getSession().createSQLQuery("SELECT * FROM sys_dictionary WHERE CategoryCode = :categoryCode");    sqlQuery.addEntity(Dictionary.class);    sqlQuery.setParameter("categoryCode", categoryCode);    return sqlQuery.list();}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[vuedraggable 拖拽排序]]></title>
      <url>/vue/2018/05/11/vuedraggable-%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F/</url>
      <content type="text"><![CDATA[  vuedraggable 可实现列表的拖拽排序官网vuedraggable]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL 在指定位置新增字段]]></title>
      <url>/database/mysql/2018/05/11/MySQL-%E5%9C%A8%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%96%B0%E5%A2%9E%E5%AD%97%E6%AE%B5/</url>
      <content type="text"><![CDATA[  MySQL 使用语法新增表字段在指定位置添加字段  要在某个字段字段之后添加字段使用 AFTER columnName 即可ADD COLUMN `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'id' AFTER `name`在第一位添加字段  虽然有 AFTER 语法，但其实没有 BEFORE 语法  要在第一位添加字段，只需要使用 FIRST 即可ADD COLUMN `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'id' FIRST]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot通过jar包启动时MyBatis无法定位实体类]]></title>
      <url>/java/springboot/mybatis/error/2018/05/09/SpringBoot%E9%80%9A%E8%BF%87jar%E5%8C%85%E5%90%AF%E5%8A%A8%E6%97%B6MyBatis%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8D%E5%AE%9E%E4%BD%93%E7%B1%BB/</url>
      <content type="text"><![CDATA[  SpringBoot 通过 jar 包启动项目时，MyBatis 无法定位实体类，但通过 IDE 启动时没问题出现问题的原因  通过 jar 启动时，MyBatis 内部获得的路径不同，会导致无法根据配置文件指定的路径扫描到实体类  项目不是通过自动注入方式配置 MyBatis ，而是通过手动注入解决办法  在手动注入并指定实体类扫描路径之前，将 Spring 已经实例化的 VFS 提前指定@Bean@ConditionalOnMissingBean(SqlSessionFactoryBean.class)public SqlSessionFactory sqlSessionFactory(@Qualifier("druidDataSource") DataSource dataSource) throws Exception {    SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();    sqlSessionFactoryBean.setDataSource(dataSource);    sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations));  // 指定VFS确保可以扫描到实体类    sqlSessionFactoryBean.setVfs(SpringBootVFS.class);    sqlSessionFactoryBean.setTypeAliasesPackage(typeAliasesPackage);    return sqlSessionFactoryBean.getObject();}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> mybatis </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> mybatis </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot多环境配置]]></title>
      <url>/java/springboot/2018/05/09/SpringBoot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  SpringBoot 在开发时可以配置多个环境进行便捷切换创建多个环境配置文件  首先需要创建多个对应的配置文件，如上图  然后在 application.yml 中通过如下语法进行匹配          项目启动时会根据指定的尾缀自动去匹配对应的配置文件      spring:  profiles:    active: dev项目打包实现动态指定配置文件  执行 java -jar xxx.jar  会直接按照默认配置进行打包  执行 java -jar xxx.jar --spring.profiles.active=test 则可以动态指定配置文件]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Maven打包时抛出should not point at files within the project directory …异常]]></title>
      <url>/java/maven/error/2018/05/09/Maven%E6%89%93%E5%8C%85%E6%97%B6%E6%8A%9B%E5%87%BAshould-not-point-at-files-within-the-project-directory-%E5%BC%82%E5%B8%B8/</url>
      <content type="text"><![CDATA[  项目中通过 Maven 引入本地包后打包时抛出 should not point at files within the project directory … 警告具体问题  在项目中引入本地包&lt;dependency&gt;    &lt;groupId&gt;ppts.model&lt;/groupId&gt;    &lt;artifactId&gt;ppts-model&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;scope&gt;system&lt;/scope&gt;    &lt;systemPath&gt;${basedir}/../lib/ppts-model-1.0-SNAPSHOT.jar&lt;/systemPath&gt;&lt;/dependency&gt;  在项目进行 package 打包时，抛出以下异常，且并没有引入对应 jar 包[WARNING] 'dependencies.dependency.systemPath' for ts.core:ts-core:jar should not point at files within the project directory, ${basedir}/../lib/ts-core-1.0.jar will be unresolvable by dependent projects @ line 97, column 19解决方式  移除本地包依赖中的 &lt;scope/&gt; 和 &lt;systemPath/&gt;&lt;dependency&gt;  &lt;groupId&gt;ppts.model&lt;/groupId&gt;  &lt;artifactId&gt;ppts-model&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;  通过 maven-install-plugin 插件对 jar 包进行安装          &lt;phase&gt;clean&lt;/phase&gt; 表示该 jar 包会在执行 clean 操作时引入      &lt;plugin&gt;  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;  &lt;version&gt;2.5.2&lt;/version&gt;  &lt;executions&gt;    &lt;execution&gt;      &lt;id&gt;install-ppts-model&lt;/id&gt;      &lt;phase&gt;clean&lt;/phase&gt;      &lt;configuration&gt;        &lt;file&gt;${basedir}/../lib/ppts-model-1.0-SNAPSHOT.jar&lt;/file&gt;        &lt;repositoryLayout&gt;default&lt;/repositoryLayout&gt;        &lt;groupId&gt;ppts.model&lt;/groupId&gt;        &lt;artifactId&gt;ppts-model&lt;/artifactId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;packaging&gt;jar&lt;/packaging&gt;        &lt;generatePom&gt;true&lt;/generatePom&gt;      &lt;/configuration&gt;      &lt;goals&gt;        &lt;goal&gt;install-file&lt;/goal&gt;      &lt;/goals&gt;    &lt;/execution&gt;  &lt;/executions&gt;&lt;/plugin&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> maven </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> maven </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 实现路由过渡动画]]></title>
      <url>/vue/2018/05/08/Vue-%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/</url>
      <content type="text"><![CDATA[  在进行路由跳转时，可以加上动画效果准备工作  编写动画效果.slide-right-enter-active,.slide-right-leave-active,.slide-left-enter-active,.slide-left-leave-active {  will-change: transform;  transition: all 500ms;  position: absolute;}.slide-right-enter {  opacity: 0;  transform: translate3d(-100%, 0, 0);}.slide-right-leave-active {  opacity: 0;  transform: translate3d(100%, 0, 0);}.slide-left-enter {  opacity: 0;  transform: translate3d(100%, 0, 0);}.slide-left-leave-active {  opacity: 0;  transform: translate3d(-100%, 0, 0);}实现步骤  为路由可能跳转到的组件添加索引，确保动画的过渡效果是有序的          在 meta 中可以添加自定义参数，此处添加 index 用于表示索引      children: [  {    path: 'hot',    name: 'hot',    component: hot,    meta: {      index: 0    }  },  {    path: 'mooc',    name: 'mooc',    component: mooc,    meta: {      index: 1    }  },  {    path: 'self',    name: 'self',    component: self,    meta: {      index: 2    }  },  {    path: 'training/:id',    name: 'training',    component: training,    props: true,    meta: {      index: 3    }  }]  在需要跳转的路由外层包裹 &lt;transition&gt; 组件          同时为组件指定可能执行的动画效果      &lt;transition :name="transitionName"&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;  通过监听路由变化判断具体执行哪个动画          可以通过路由的参数获取到之前设置的索引，从而判断动画效果是向左还是向右      watch: {  '$route' (to, from) {    console.log(to)    let toName = to.name    const toIndex = to.meta.index    const fromIndex = from.meta.index    this.transitionName = toIndex &lt; fromIndex ? 'slide-right' : 'slide-left'  }}]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> transition </tag>
        
          <tag> animate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot集成ActiveMQ抛出java.lang.NoClassDefFoundError异常]]></title>
      <url>/java/springboot/springmvc/maven/error/2018/05/08/SpringBoot%E9%9B%86%E6%88%90ActiveMQ%E6%8A%9B%E5%87%BANoClassDefFoundError/</url>
      <content type="text"><![CDATA[  SpringBoot 在集成 JMS 及 ActiveMQ 时抛出 java.lang.NoClassDefFoundError: javax/jms/JMSContext 异常出现问题的原因  spring 5.0 以上版本不会自动导入 JMS 2.0 的依赖  但是 activemq-core 5.7  版本需要 JMS 2.0 的依赖解决办法  手动加入 JMS 2.0 依赖&lt;dependency&gt;    &lt;groupId&gt;javax.jms&lt;/groupId&gt;    &lt;artifactId&gt;javax.jms-api&lt;/artifactId&gt;    &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;  在 activemq-core 5.7 中移除低版本的默认引入&lt;dependency&gt;    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;    &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;    &lt;version&gt;5.7.0&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;            &lt;artifactId&gt;geronimo-jms_1.1_spec&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> springmvc </category>
        
          <category> maven </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> springmvc </tag>
        
          <tag> maven </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Cube-ui 基于 vue 的移动组件库]]></title>
      <url>/vue/frame/2018/05/07/Cube-ui-%E5%9F%BA%E4%BA%8E-vue-%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
      <content type="text"><![CDATA[  cube-ui 是滴滴团队开源的一套基于 vue 的移动组件库官网  Github  使用文档]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> frame </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> frame </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[es6 方法具名参数及默认值]]></title>
      <url>/javascript/es6/2018/05/03/es6-%E6%96%B9%E6%B3%95%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0%E5%8F%8A%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
      <content type="text"><![CDATA[  es6 对方法参数做了较大升级，不仅可以提供具名参数还能设定默认值携带具名参数的方法function common (message, type, { position , duration }) {  Toast({    message: message,    className: type,    position: position,    duration: duration  })}为具名参数指定默认值的方法function common (message, type, { position = 'middle', duration = 3000 }) {  Toast({    message: message,    className: type,    position: position,    duration: duration  })}注意事项  携带具名参数的方法，在调用时如果不传递对应参数也必须传递一个空的大空号，否则内部参数使用时会抛出 undefinedcommon(message, 'warning', {})  为防止这种每次调用都必须传递一对空的大空号的麻烦，可以对方法进行二次封装export function error (message, position) {  common(message, 'error', { position })}]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> es6 </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> es6 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[vue-aliplayer 阿里云播放器适配 vue]]></title>
      <url>/vue/2018/05/02/vue-aliplayer-%E9%98%BF%E9%87%8C%E4%BA%91%E6%92%AD%E6%94%BE%E5%99%A8%E9%80%82%E9%85%8D-vue/</url>
      <content type="text"><![CDATA[#vue/plugin  阿里云播放器本身没对 vue 进行专门优化，以下借助 github 上一个库进行优化官网vue-aliplayer插件源码&lt;template&gt;  &lt;div class='prism-player' :id='playerId' :style='playStyle'&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: 'Aliplayer',    props: {      playStyle: {        type: String,        default: ''      },      aliplayerSdkPath: {        // Aliplayer 代码的路径        type: String,        default: '//g.alicdn.com/de/prismplayer/2.6.0/aliplayer-min.js'      },      autoplay: {        type: Boolean,        default: false      },      isLive: {        type: Boolean,        default: false      },      playsinline: {        type: Boolean,        default: false      },      width: {        type: String,        default: '100%'      },      height: {        type: String,        default: '320px'      },      controlBarVisibility: {        type: String,        default: 'always'      },      useH5Prism: {        type: Boolean,        default: false      },      useFlashPrism: {        type: Boolean,        default: false      },      vid: {        type: String,        default: ''      },      playauth: {        type: String,        default: ''      },      source: {        type: String,        default: ''      },      cover: {        type: String,        default: ''      },      format: {        type: String,        default: 'm3u8'      },      x5_video_position: {        type: String,        default: 'top'      },      x5_type: {        type: String,        default: 'h5'      },      x5_fullscreen: {        type: Boolean,        default: false      },      x5_orientation: {        type: Number,        default: 2      },      autoPlayDelay: {        type: Number,        default: 0      },      autoPlayDelayDisplayText: {        type: String      }    },    data () {      return {        playerId: 'aliplayer_' + Math.random() * 100000000000000000,        scriptTagStatus: 0,        instance: null      }    },    created () {      if (window.Aliplayer !== undefined) {        // 如果全局对象存在，说明编辑器代码已经初始化完成，直接加载编辑器        this.scriptTagStatus = 2        this.initAliplayer()      } else {        // 如果全局对象不存在，说明编辑器代码还没有加载完成，需要加载编辑器代码        this.insertScriptTag()      }    },    mounted () {      if (window.Aliplayer !== undefined) {        // 如果全局对象存在，说明编辑器代码已经初始化完成，直接加载编辑器        this.scriptTagStatus = 2        this.initAliplayer()      } else {        // 如果全局对象不存在，说明编辑器代码还没有加载完成，需要加载编辑器代码        this.insertScriptTag()      }    },    methods: {      insertScriptTag () {        const _this = this        let playerScriptTag = document.getElementById('playerScriptTag')        // 如果这个tag不存在，则生成相关代码tag以加载代码        if (playerScriptTag === null) {          playerScriptTag = document.createElement('script')          playerScriptTag.type = 'text/javascript'          playerScriptTag.src = this.aliplayerSdkPath          playerScriptTag.id = 'playerScriptTag'          let s = document.getElementsByTagName('head')[0]          s.appendChild(playerScriptTag)        }        if (playerScriptTag.loaded) {          _this.scriptTagStatus++        } else {          playerScriptTag.addEventListener('load', () =&gt; {            _this.scriptTagStatus++            playerScriptTag.loaded = true            _this.initAliplayer()          })        }        _this.initAliplayer()      },      initAliplayer () {        const _this = this        // scriptTagStatus 为 2 的时候，说明两个必需引入的 js 文件都已经被引入，且加载完成        if (_this.scriptTagStatus === 2 &amp;&amp; _this.instance === null) {          // Vue 异步执行 DOM 更新，这样一来代码执行到这里的时候可能 template 里面的 script 标签还没真正创建          // 所以，我们只能在 nextTick 里面初始化 Aliplayer          _this.$nextTick(() =&gt; {            _this.instance = window.Aliplayer({              id: _this.playerId,              autoplay: _this.autoplay,              isLive: _this.isLive,              playsinline: _this.playsinline,              format: _this.format,              width: _this.width,              height: _this.height,              controlBarVisibility: _this.controlBarVisibility,              useH5Prism: _this.useH5Prism,              useFlashPrism: _this.useFlashPrism,              vid: _this.vid,              playauth: _this.playauth,              source: _this.source,              cover: _this.cover,              x5_video_position: _this.x5_video_position,              x5_type: _this.x5_type,              x5_fullscreen: _this.x5_fullscreen,              x5_orientation: _this.x5_orientation,              autoPlayDelay: _this.autoPlayDelay,              autoPlayDelayDisplayText: _this.autoPlayDelayDisplayText            })            // 绑定事件，当 AliPlayer 初始化完成后，将编辑器实例通过自定义的 ready 事件交出去            _this.instance.on('ready', () =&gt; {              this.$emit('ready', _this.instance)            })            _this.instance.on('play', () =&gt; {              this.$emit('play', _this.instance)            })            _this.instance.on('pause', () =&gt; {              this.$emit('pause', _this.instance)            })            _this.instance.on('ended', () =&gt; {              this.$emit('ended', _this.instance)            })            _this.instance.on('liveStreamStop', () =&gt; {              this.$emit('liveStreamStop', _this.instance)            })            _this.instance.on('m3u8Retry', () =&gt; {              this.$emit('m3u8Retry', _this.instance)            })            _this.instance.on('hideBar', () =&gt; {              this.$emit('hideBar', _this.instance)            })            _this.instance.on('waiting', () =&gt; {              this.$emit('waiting', _this.instance)            })            _this.instance.on('snapshoted', () =&gt; {              this.$emit('snapshoted', _this.instance)            })          })        }      },      /**       * 播放视频       */      play: function () {        this.instance.play()      },      /**       * 暂停视频       */      pause: function () {        this.instance.pause()      },      /**       * 重播视频       */      replay: function () {        this.instance.replay()      },      /**       * 跳转到某个时刻进行播放       * @argument time 的单位为秒       */      seek: function (time) {        this.instance.seek(time)      },      /**       * 获取当前时间 单位秒       */      getCurrentTime: function () {        return this.instance.getCurrentTime()      },      /**       *获取视频总时长，返回的单位为秒       * @returns 返回的单位为秒       */      getDuration: function () {        return this.instance.getDuration()      },      /**       获取当前的音量，返回值为0-1的实数ios和部分android会失效       */      getVolume: function () {        return this.instance.getVolume()      },      /**       设置音量，vol为0-1的实数，ios和部分android会失效       */      setVolume: function (vol) {        this.instance.setVolume(vol)      },      /**       *直接播放视频url，time为可选值（单位秒）目前只支持同种格式（mp4/flv/m3u8）之间切换暂不支持直播rtmp流切换       *@argument url 视频地址       *@argument time 跳转到多少秒       */      loadByUrl: function (url, time) {        this.instance.loadByUrl(url, time)      },      /**       * 设置播放速度       *@argument speed 速度       */      setSpeed: function (speed) {        this.instance.setSpeed(speed)      },      /**       * 设置播放器大小w,h可分别为400px像素或60%百分比chrome浏览器下flash播放器分别不能小于397x297       *@argument w 播放器宽度       *@argument h 播放器高度       */      setPlayerSize: function (w, h) {        this.instance.setPlayerSize(w, h)      },      /**       * 目前只支持HTML5界面上的重载功能,暂不支持直播rtmp流切换m3u8）之间切换,暂不支持直播rtmp流切换       *@argument vid 视频id       *@argument playauth 播放凭证       */      reloaduserPlayInfoAndVidRequestMts: function (vid, playauth) {        this.instance.reloaduserPlayInfoAndVidRequestMts(vid, playauth)      }    }  }&lt;/script&gt;&lt;style&gt;  @import url(//g.alicdn.com/de/prismplayer/2.6.0/skins/default/aliplayer-min.css);&lt;/style&gt;组件封装  插件本身属性过多，正常开发中不一定用得到，因此对插件进行再一次封装为组件，方便程序调用及适当扩展  该组件主要实现了一下功能          播放器高度自适应      自动获取视频播放地址，播放地址的实现参见 Java + jQuery 实现阿里云点播      &lt;template&gt;  &lt;ali-player v-if="playAuth" :vid="vid" :playauth="playAuth" :height="height"&gt;&lt;/ali-player&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;  import aliPlayer from './ali-player/ali-player'  export default {    name: 'in-video',    props: {      vid: {        type: String,        default: '0'      }    },    data () {      return {        playAuth: ''      }    },    watch: {      'vid' (val) {        this._getPlayAuth(val)      }    },    computed: {      // 高度自适应      height () {        let width = document.documentElement.clientWidth        return `${width / 1.7777778}px`      }    },    methods: {      // 获取视频鉴权地址      _getPlayAuth (val) {        this.$fetch.video.auth({          videoId: val        }).then((res) =&gt; {          this.playAuth = res.data        })      }    },    components: {      aliPlayer    }  }&lt;/script&gt;&lt;style lang="stylus" rel="stylesheet/stylus"&gt;&lt;/style&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> aliplay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS文本加省略号]]></title>
      <url>/css/2018/04/29/CSS%E6%96%87%E6%9C%AC%E5%8A%A0%E7%9C%81%E7%95%A5%E5%8F%B7/</url>
      <content type="text"><![CDATA[  通常的文本末尾有三个点的省略号，可以通过 CSS 实现解决方式  在文本确定宽度的前提下加入以下样式即可overflow: hidden;white-space: nowrap;text-overflow: ellipsis;可能存在的问题  在 flex 布局下会发现省略号不出现  这时候需要在父元素添加一个 overflow: hidden 即可]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 实现 slot 多层嵌套]]></title>
      <url>/vue/2018/04/25/Vue-%E5%AE%9E%E7%8E%B0-slot-%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97/</url>
      <content type="text"><![CDATA[  在引用一些框架时，通常他们自己就已经有插槽，但有时需要对插槽进行拓展定义基础组件，向插槽中再插入一个插槽  在基础组件中引入了 Mint-UI 的 mt-header 组件  并通过其提供的具名插槽向组件右侧插入内容  但该组件是我们自定义的，我们并不知道组件被调用时会被插入什么内容  所以在该组件中插入该具名插槽的内容也是一个插槽  关键点在于这个插入的未知内容的插槽也必须是具名的&lt;template&gt;  &lt;mt-header&gt;    &lt;img class="logo" src="./images/logo.png" alt="logo" slot="left"&gt;    &lt;slot name="button" slot="right"&gt;&lt;/slot&gt;  &lt;/mt-header&gt;&lt;/template&gt;子组件引用基础组件，像二级插槽中插入具体内容，并指定二级插槽的名称  在引入组件时，只需要将待插入的内容插槽名称与基础组件中覆写的插槽名称对应即可&lt;template&gt;  &lt;div class="portal-panel"&gt;    &lt;in-header&gt;      &lt;div class="btn-group" slot="button"&gt;        &lt;mt-button&gt;登录&lt;/mt-button&gt;        &lt;mt-button&gt;注册&lt;/mt-button&gt;      &lt;/div&gt;    &lt;/in-header&gt;  &lt;/div&gt;&lt;/template&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> slot </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS DOM 操作技巧汇总]]></title>
      <url>/css/2018/04/24/CSS-DOM-%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</url>
      <content type="text"><![CDATA[官网30 Seconds of CSS]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IntelliJ IDEA 修改 Javascript 编码风格没有分号]]></title>
      <url>/javascript/intellij/idea/2018/04/22/IntelliJ-IDEA-%E4%BF%AE%E6%94%B9-Javascript-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%B2%A1%E6%9C%89%E5%88%86%E5%8F%B7/</url>
      <content type="text"><![CDATA[  现在觉得没有分号更酷解决方式  该界面下选择 Don’t use 即可]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> intellij </category>
        
          <category> idea </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> intellij </tag>
        
          <tag> idea </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 项目启动抛出 Syntax Error/ Unexpected token]]></title>
      <url>/vue/2018/04/20/Vue-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%8A%9B%E5%87%BA-Syntax-Error-Unexpected-token/</url>
      <content type="text"><![CDATA[  项目启动时抛出了标识符无法识别的错误错误原因  ES6 新增了不少标识符，但浏览器大多无法直接识别，需要借助 babel 对 ES6 代码进行转义  项目启动时抛出如下错误，表示 ... 运算符没能被识别，该运算符属于 ES6 的解构运算符  出现该问题的原因基本上可以定位是项目没有配置 babel          即时 package.json 文件中已经引入 babel ，但仍然需要在项目根目录创建一个 .balbelrc 文件进行配置      解决方式  在项目根目录创建 .babelrc 文件即可实现对 babel 的基本配置{  "presets": [    ["env", {      "modules": false    }],    "stage-2"  ],  "plugins": ["transform-runtime", "transform-vue-jsx"]}]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 项目启动抛出 Expected indentation of 2 spaces but found 1 tab]]></title>
      <url>/vue/eslint/2018/04/20/Vue-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%8A%9B%E5%87%BA-Expected-indentation-of-2-spaces-but-found-1-tab/</url>
      <content type="text"><![CDATA[  该问题是由于 ESLint 的验证规则不匹配解决方式  在 .eslintrc.js 文件的 rules 中加入 'no-tabs': 'off' 即可不检测该问题// https://eslint.org/docs/user-guide/configuringmodule.exports = {	...  'rules': {		...		'no-tabs': 'off'  }}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> eslint </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> eslint </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 项目启动抛出 Error/ No PostCSS Config found in]]></title>
      <url>/vue/2018/04/20/Vue-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%8A%9B%E5%87%BA-Error-No-PostCSS-Config-found-in/</url>
      <content type="text"><![CDATA[  项目启动时抛出 Error: No PostCSS Config found in … 的错误表示某个 css 文件不能被引入解决办法  在项目根目录创建 postcss.config.js 文件，并配置以下内容module.exports = {    plugins: {      'autoprefixer': {browsers: 'last 5 version'}    }  } ]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[ESLint 代码规范性验证]]></title>
      <url>/vue/eslint/2018/04/20/ESLint-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%80%A7%E9%AA%8C%E8%AF%81/</url>
      <content type="text"><![CDATA[  ESLint 是可组装的JavaScript和JSX检查工具官网ESLint - Pluggable JavaScript linter - ESLint中文]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> eslint </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> eslint </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 项目启动抛出 Module build failed/ Error/ No ESLint configuration found.]]></title>
      <url>/vue/eslint/2018/04/19/Vue-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%8A%9B%E5%87%BA-Module-build-failed-Error-No-ESLint-configuration-found</url>
      <content type="text"><![CDATA[  项目启动时控制台抛出 Module build failed: Error: No ESLint configuration found. 的错误出现错误的原因  因为项目根路径缺少 ESLint 的配置文件解决问题的方式  将 ESLint 相关配置文件添加至项目根路径// https://eslint.org/docs/user-guide/configuringmodule.exports = {  root: true,  parser: 'babel-eslint',  parserOptions: {    sourceType: 'module'  },  env: {    browser: true,  },  // https://github.com/standard/standard/blob/master/docs/RULES-en.md  extends: 'standard',  // required to lint *.vue files  plugins: [    'html'  ],  // add your custom rules here  'rules': {    // allow paren-less arrow functions    'arrow-parens': 0,    // allow async-await    'generator-star-spacing': 0,    // allow debugger during development    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0,    // 忽略函数空格检测    'space-before-function-paren': 0,    // 中缀操作符周围要不要有空格    'space-infix-ops': 0,    'no-trailing-spaces': 0,    'new-parens': 0  }}/build//config//dist//*.js]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> eslint </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> eslint </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL 循环插入数据]]></title>
      <url>/database/mysql/2018/04/19/MySQL-%E5%BE%AA%E7%8E%AF%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
      <content type="text"><![CDATA[  有时为了做数据，逐行插入效率过低，可使用以下循环的方式对数据进行插入语法  DELIMITER  用于修改 MySQL 默认的结束符          由于 MySQL 默认的结束符是 ; ，在事务执行中则会出现问题，所以需要修改        MySQL 不支持匿名方法，所以需要创建一个 PROCEDURE  来执行  创建事务后不会直接执行，需要手动执行，即输入 CALL repeatCourse();DELIMITER //CREATE PROCEDURE repeatCourse()BEGINDECLARE num INT;SET num = 1;WHILE num &lt; 30 DO	INSERT INTO `pt_course` (`name`, `code`)	SELECT CONCAT('看个视频就能学会啊', num), CONCAT('COU-201705-0005', num)	FROM pt_course	WHERE id = 548;SET num = num + 1;END WHILE;END //CALL repeatCourse();]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot+IDEA热部署]]></title>
      <url>/java/springboot/software/2018/04/18/SpringBoot+IDEA%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      <content type="text"><![CDATA[  SpringBoot 自身有提供插件可实现代码热部署IDEA 相关配置  开启项目自动构建代码相关配置  pom 中加入以下依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;  扩展 spring-boot-maven-plugin 的插件配置项&lt;build&gt;    &lt;finalName&gt;mop&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;!-- 如果没有该项配置devtools不会起作用，即应用不会restart --&gt;                &lt;fork&gt;true&lt;/fork&gt;                &lt;!-- 支持静态文件热部署 --&gt;                &lt;addResources&gt;true&lt;/addResources&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> software </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> intellij </tag>
        
          <tag> idea </tag>
        
          <tag> software </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot集成Swagger]]></title>
      <url>/java/springboot/swagger/2018/04/17/SpringBoot%E9%9B%86%E6%88%90Swagger/</url>
      <content type="text"><![CDATA[  Swagger 是一款目前世界最流行的API管理工具官网  Swagger  Swagger Annotation集成步骤  在项目 pom 中引入以下依赖&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;  在项目中配置 Swagger@Configuration@EnableSwagger2public class SwaggerConfig {    @Bean    public Docket api() {        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()).select().apis(RequestHandlerSelectors.any()).paths(or(regex("/api/.*"))).build();    }    private ApiInfo apiInfo() {        return new ApiInfoBuilder().title("轻实训-移动端 API").version("1.0").build();    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> swagger </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> swagger </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot抛出ContextPath must start with xx and not end with xx异常]]></title>
      <url>/java/springboot/error/2018/04/17/SpringBoot%E6%8A%9B%E5%87%BAContextPath-must-start-with-xx-and-not-end-with-xx/</url>
      <content type="text"><![CDATA[  该异常属于项目配置的根路径出错解决问题的办法  在 application.yml 中将 server.servlet.context-path 设置的路径前加一个 /server:  servlet:    context-path: /api]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot启动抛出Unregistering JMX-exposed beans on shutdown异常]]></title>
      <url>/java/springboot/error/2018/04/16/SpringBoot%E5%90%AF%E5%8A%A8%E6%8A%9B%E5%87%BAUnregistering-JMX-exposed-beans-on-shutdown/</url>
      <content type="text"><![CDATA[  在配置 SpringBoot 项目时可能会抛出 Unregistering JMX-exposed beans on shutdown异常抛出错误的原因  是因为以下依赖的 scope 为 provided 导致的&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;解决的办法  将 provided 改为 compile 即可&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Muse UI]]></title>
      <url>/vue/frame/2018/04/16/Muse-UI/</url>
      <content type="text"><![CDATA[  Muse-ui 基于 Vue 2.0 和 Material Design 的 UI 组件库官网  Github  使用文档]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> frame </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> frame </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mint-ui 基于 vue 的移动端框架]]></title>
      <url>/vue/frame/mintui/2018/04/16/Mint-ui-%E5%9F%BA%E4%BA%8E-vue-%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6/</url>
      <content type="text"><![CDATA[  Mint UI 是由饿了么前端团队推出的基于 Vue.js 的移动端组件库官网  Github  使用文档]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> frame </category>
        
          <category> mintui </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> frame </tag>
        
          <tag> mintui </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 实现阿里云直播推流在线列表查询]]></title>
      <url>/java/aliyun/2018/04/12/Java-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%9C%A8%E7%BA%BF%E5%88%97%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  阿里云直播推流在线列表可以通过 API 的方式进行查询获取官网查询推流在线列表初始化配置  Constants.ALI_ACCESS_KEY_ID 是阿里云服务密钥 id ，所有服务共用  Constants.ALI_ACCESS_SECRET 是阿里云服务密钥，所有服务共用  将客户端的初始化放置在静态块中可以保证配置只初始化一次private static IAcsClient iAcsClient;static {    // 初始化配置    String regionId = "cn-shanghai";    DefaultProfile profile = DefaultProfile.getProfile(regionId, Constants.ALI_ACCESS_KEY_ID, Constants.ALI_ACCESS_SECRET);    iAcsClient = new DefaultAcsClient(profile);    // 本地调试    // System.setProperty("http.proxyHost", "127.0.0.1");    // System.setProperty("http.proxyPort", "8080");}查询推流在线列表  Constants.ALI_LIVE_PULL_URL 是阿里云直播的推流地址  Constants.ALI_LIVE_APP_NAME 是阿流云直播的应用名称          如果不指定，则会查询出所有的应用的推流列表      只能是单纯的应用名称，和阿里云直播控制台设置的保持一直        获取到推流在线列表后，只需要进行流名称的匹配即可public Boolean checkLiveBegin(String streamName) {    // 查询推流在线列表    DescribeLiveStreamsOnlineListRequest listRequest = new DescribeLiveStreamsOnlineListRequest();    listRequest.setDomainName(Constants.ALI_LIVE_PULL_URL);    listRequest.setAppName(Constants.ALI_LIVE_APP_NAME.replace("/", ""));    try {        DescribeLiveStreamsOnlineListResponse response = iAcsClient.getAcsResponse(listRequest);        // 获取当前推流列表        List&lt;LiveStreamOnlineInfo&gt; onlineInfos = response.getOnlineInfo();        for (LiveStreamOnlineInfo onlineInfo : onlineInfos) {            if (onlineInfo.getStreamName().equals(streamName)) {                return true;            }        }    } catch (ClientException e) {        logger.error("获取拉流信息失败！", e);    }    return false;}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> aliyun </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> aliyun </tag>
        
          <tag> live </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 通过 HttpConnection 解决 Ajax 请求跨域问题]]></title>
      <url>/java/crossdomain/2018/04/02/Java-%E9%80%9A%E8%BF%87-HttpConnection-%E8%A7%A3%E5%86%B3-Ajax-%E8%AF%B7%E6%B1%82%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      <content type="text"><![CDATA[  $.ajax 在访问外部服务器时会出现跨域问题，尝试过很多前端的方式解决都没有效果，最终是使用 Java 发送请求得以解决包装 Java 发送 Http 请求的工具类  该工具类中包括发送 GET/POST 请求的方法  方法只需要传入请求的地址和参数列表即可  参数列表的格式为 name1=value1&amp;name2=value2public class HttpUtils {    public static String sendGet(String url, String param) {        String result = "";        BufferedReader in = null;        try {            String urlNameString = url + "?" + param;            URL realUrl = new URL(urlNameString);            // 打开和URL之间的连接            URLConnection connection = realUrl.openConnection();            // 设置通用的请求属性            connection.setRequestProperty("accept", "*/*");            connection.setRequestProperty("connection", "Keep-Alive");            connection.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");            // 建立实际的连接            connection.connect();            // 获取所有响应头字段            Map&lt;String, List&lt;String&gt;&gt; map = connection.getHeaderFields();            // 定义 BufferedReader输入流来读取URL的响应            in = new BufferedReader(new InputStreamReader(connection.getInputStream()));            String line;            while ((line = in.readLine()) != null) {                result += line;            }        } catch (Exception e) {            System.out.println("发送GET请求出现异常！" + e);            e.printStackTrace();        } finally {            try {                if (in != null) {                    in.close();                }            } catch (Exception e2) {                e2.printStackTrace();            }        }        return result;    }    public static String sendPost(String url, String param) {        PrintWriter out = null;        BufferedReader in = null;        String result = "";        try {            URL realUrl = new URL(url);            // 打开和URL之间的连接            URLConnection conn = realUrl.openConnection();            // 设置通用的请求属性            conn.setRequestProperty("accept", "*/*");            conn.setRequestProperty("connection", "Keep-Alive");            conn.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");            // 发送POST请求必须设置如下两行            conn.setDoOutput(true);            conn.setDoInput(true);            // 获取URLConnection对象对应的输出流            out = new PrintWriter(conn.getOutputStream());            // 发送请求参数            out.print(param);            // flush输出流的缓冲            out.flush();            // 定义BufferedReader输入流来读取URL的响应            in = new BufferedReader(new InputStreamReader(conn.getInputStream()));            String line;            while ((line = in.readLine()) != null) {                result += line;            }        } catch (Exception e) {            System.out.println("发送 POST 请求出现异常！"+e);            e.printStackTrace();        } finally {            try{                if(out!=null){                    out.close();                }                if(in!=null){                    in.close();                }            } catch(IOException ex){                ex.printStackTrace();            }        }        return result;    }}调用工具类  如果调用的是 GET 请求请求参数会被拼接到链接之后，这是参数列表则需要对各种符号进行转码  URLEncoder.encode(input, "UTF-8") 是 java.net.URLEncoder 包中的方法String result = sendGet("http://120.27.199.194:7001/run", "code=" + URLEncoder.encode(input, "UTF-8"));]]></content>
      <categories>
        
          <category> java </category>
        
          <category> crossdomain </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> crossdomain </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[父级操作子级 iframe]]></title>
      <url>/html/iframe/2018/04/01/%E7%88%B6%E7%BA%A7%E6%93%8D%E4%BD%9C%E5%AD%90%E7%BA%A7-iframe/</url>
      <content type="text"><![CDATA[  父级元素想要操作子级 iframe 的内部元素可以通过以下方式实现方式  aliPayFrame  可以是 iframe 标签的 id 或者 name$(window.frames["aliPayFrame"].document).find("html").html(response.data);注意点  window.frames["aliPayFrame"] 在 chrome 下无效  document.getElementById("trainingIntroduce").contentWindow 在 chrome 下有效]]></content>
      <categories>
        
          <category> html </category>
        
          <category> iframe </category>
        
      </categories>
      <tags>
        
          <tag> html </tag>
        
          <tag> iframe </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java支付宝订单查询]]></title>
      <url>/java/pay/2018/04/01/Java-%E6%94%AF%E4%BB%98%E5%AE%9D%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  电脑网站支付成功后可通过支付宝接口主动查询订单结果前置条件  该方法基于 Java 支付宝扫码支付 (新) 实现调用查询接口进行订单查询public class AliQueryServiceImpl extends AliCoreServiceImpl {    public Boolean getPayResult(Long orderId) {        AlipayTradeQueryRequest queryRequest = new AlipayTradeQueryRequest();        queryRequest.setBizModel(generateOrderInfo(orderId));        AlipayTradeQueryResponse response = null;        try {            response = alipayClient.execute(queryRequest);        } catch (AlipayApiException e) {            logger.error("支付宝查询订单" + orderId + "失败！", e);        }        if (response == null) {            logger.error("支付宝未获取订单" + orderId + "详情！");            return false;        }        if (response.isSuccess()) {            if (response.getTradeStatus().equals(TRADE_STATUS_SUCCESS) || response.getTradeStatus().equals(TRADE_STATUS_FINISHED)) {                // 更新订单状态                updateOrderInfo(response.getOutTradeNo(), OrderPay.aliPay.getCode());                return true;            }            logger.error("支付宝订单" + orderId + "交易失败，交易状态：" + response.getTradeStatus());            return false;        } else {            logger.error("支付宝订单" + orderId + "查询失败！");            return false;        }    }    private AlipayTradeQueryModel generateOrderInfo(Long orderId) {        OrderDTO order = orderManageService.getOrder(orderId);        AlipayTradeQueryModel model = new AlipayTradeQueryModel();        model.setOutTradeNo(order.getCode());        return model;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java支付宝扫码支付[新]]]></title>
      <url>/java/pay/2018/03/31/Java-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98-%E6%96%B0/</url>
      <content type="text"><![CDATA[  支付宝老版本的 Web 端扫码支付产品为即时到账，更新到新版后现在的产品为电脑网站支付官网电脑网站支付快速接入准备数据  电脑网站支付 应用需要在开发者页面端进行申请和签约  应用签约成功之后需要获取以下信息          app_id: 签约成功的应用唯一标识      app_private_key: 通过 RSA 密钥生成的应用私钥，由开发者自己通过签名软件生成[支付宝提供]      alipay_public_key: 通过应用私钥和公钥生成的支付宝公钥，由支付宝自动生成      下载 Java 版 SDK  前往 电脑网站支付 SDK 获取 下载 Java 的 SDK  该 SDK 目前不支持 Maven 方式引入，只能通过本地引入  正常开发模式只需要引入 alipay-sdk-java-3.0.0.jar 即可获取支付宝客户端  支付宝客户端是调用所有接口的前置条件，所以应该放置在顶层父类做一次初始化  SOPConstants.ALI_PAY_SEND_URL 是该支付方式的统一请求接口，值为 https://openapi.alipay.com/gateway.dopublic class AliCoreServiceImpl extends OrderCoreServiceImpl {    // 参数返回格式    private static final String ALI_PAY_FORMAT = "json";    // 编码集，支持 GBK/UTF-8    protected static final String ALI_PAY_CHARSET = "utf-8";    // 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2/RSA ，推荐使用 RSA2    protected static final String ALI_PAY_SIGN_TYPE = "RSA2";    // 订单支付成功状态    protected static final String TRADE_STATUS_SUCCESS = "TRADE_SUCCESS";    // 订单支付结束状态    protected static final String TRADE_STATUS_FINISHED = "TRADE_FINISHED";    // 支付宝客户端    protected static AlipayClient alipayClient;    static {        // 初始化支付宝客户端        alipayClient = new DefaultAlipayClient(                SOPConstants.ALI_PAY_SEND_URL,                SOPConstants.ALI_PAY_APP_ID,                SOPConstants.ALI_PAY_PRIVATE_KEY,                ALI_PAY_FORMAT,                ALI_PAY_CHARSET,                SOPConstants.ALI_PAY_PUBLIC_KEY,                ALI_PAY_SIGN_TYPE);    }}发起支付宝付款页面请求  新版的扫码支付对请求参数和响应参数都做了封装，只需要传入对应参数值即可  SOPConstants.ALI_PAY_RETURN_URL 是支付宝付款成功需要的同步回执地址  SOPConstants.ALI_PAY_NOTIFY_URL 是支付宝付款成功需要的异步回执地址  以上两个地址都需要能够外网访问  该请求方式是通过拼接请求使用 iframe 获取支付宝的付款二维码          通过客户端发起请求时不使用一般的 pageExecute() 而使用 sdkExecute()      sdkExecute() 获取的是请求之后的参数值，所以还需要拼接请求地址      SOPConstants.ALI_PAY_SEND_URL 是支付请求地址      public class AliPayServiceImpl extends AliCoreServiceImpl {    public String aliPay(Long orderId) {        // 创建统一下单请求        AlipayTradePagePayRequest payRequest = new AlipayTradePagePayRequest();        payRequest.setReturnUrl(SOPConstants.ALI_PAY_RETURN_URL);        payRequest.setNotifyUrl(SOPConstants.ALI_PAY_NOTIFY_URL);        // 将订单详情传入业务请求参数中        payRequest.setBizModel(generateOrderInfo(orderId));        String body = null;        try {            body = alipayClient.sdkExecute(payRequest).getBody();        } catch (AlipayApiException e) {            logger.error("订单" + orderId + "获取支付宝付款界面失败！");        }        if (body == null) {            logger.error("订单" + orderId + "未成功获取支付宝付款界面！");        }        return SOPConstants.ALI_PAY_SEND_URL + "?" + body;    }    private AlipayTradePagePayModel generateOrderInfo(Long orderId) {        // 获取订单信息        OrderDTO order = orderManageService.getOrder(orderId);        AlipayTradePagePayModel model = new AlipayTradePagePayModel();        model.setOutTradeNo(order.getCode());        model.setProductCode("FAST_INSTANT_TRADE_PAY");        model.setTotalAmount(String.valueOf(order.getPrice()));        model.setSubject("实训在线-" + order.getName());        model.setBody("实训在线-" + order.getName());        // 二维码获取方式为模式4，最简洁模式，只有二维码        model.setQrPayMode("4");        model.setQrcodeWidth(240L);        return model;    }}  控制层调用请求接口获取完整请求地址@RequestMapping("/ali/{orderId}")public String ali(Model model, @PathVariable String orderId) {    model.addAttribute("order", orderManageService.getOrder(IdEncoder.decodeId(orderId)));    model.addAttribute("orderType", OrderPay.aliPay.getCode());    model.addAttribute("aliPayUrl", aliPayService.aliPay(IdEncoder.decodeId(orderId)));    return "/order/pay/ali";}  上述方法中拼接完整的二维码请求地址可以直接放置到 iframe 的 src 属性中          如果页面没有成功获取，可根据报错信息前往 验签失败错误排查 进行解决      &lt;iframe id="aliPayFrame" src="${aliPayUrl}" frameborder="0"&gt;&lt;/iframe&gt;接收同步回执  该地址需要与之前初始化客户端时提交给支付宝的同步回执地址保持一致  回执地址不能有任何多余参数@RequestMapping("/ali/return")public String aliReturn(HttpServletRequest request) {    aliNotifyService.aliReturn(request);    return null;}  新版的同步回执中不会携带订单的状态信息，所以只能用做一般的信息接收，不能做为交易成功的依据          同步回执需要验签，但验签的方法支付宝已提供，即 AlipaySignature.rsaCheckV2()      public void aliReturn(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    Boolean result = false;    try {        // 回执验签        result = AlipaySignature.rsaCheckV2(parameterToMap(request, false), SOPConstants.ALI_PAY_PUBLIC_KEY, ALI_PAY_CHARSET, ALI_PAY_SIGN_TYPE);    } catch (AlipayApiException e) {        logger.error("支付宝订单" + orderCode + "同步回执验签失败！", e);    }    if (result) {        logger.info("支付宝订单" + orderCode + "同步回执接收成功！");    } else {        logger.error("支付宝订单" + orderCode + "同步回执无效！");    }}  对同步回执中的响应参数验签之前，需要先将参数转化为 map 形式private Map&lt;String, String&gt; parameterToMap(HttpServletRequest request, Boolean isNotify) {    // 获取回执内容    Map requestParams = request.getParameterMap();    // 过滤回执内容    Map&lt;String, String&gt; params = Maps.newHashMap();    for (Object o : requestParams.keySet()) {        String name = (String) o;        String[] values = (String[]) requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        if (isNotify) {            params.put(name, valueStr);        } else {            try {                params.put(name, new String(valueStr.getBytes("ISO-8859-1"), "utf-8"));            } catch (UnsupportedEncodingException e) {                logger.error("支付宝订单同步回执转码失败！", e);            }        }    }    return params;}接收异步回执  该地址需要与之前初始化客户端时提交给支付宝的异步回执地址保持一致  回执地址不能携带任何参数@RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic String aliNotify(HttpServletRequest request) {    return aliNotifyService.aliNotify(request);}  异步回执作为支付成功的依据，支付宝成功通知到本地后，需要明确告知支付宝交易已成功          交易成功后返回 success 即可      当订单支付成功后订单可以展现两种状态，TRADE_SUCCESS 或 TRADE_FINISHED      public String aliNotify(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 订单状态    String orderStatus = request.getParameter("trade_status");    boolean result = false;    try {        result = AlipaySignature.rsaCheckV2(parameterToMap(request, true), SOPConstants.ALI_PAY_PUBLIC_KEY, ALI_PAY_CHARSET, ALI_PAY_SIGN_TYPE);    } catch (AlipayApiException e) {        logger.error("支付宝订单" + orderCode + "异步回执验签失败，订单状态为：" + orderStatus + "！", e);    }    // 验签成功    if (result) {        // 订单已支付        if (orderStatus.equals(TRADE_STATUS_SUCCESS) || orderStatus.equals(TRADE_STATUS_FINISHED)) {            // 更新订单状态            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());            return "success";        } else {            logger.error("支付宝订单" + orderCode + "未支付，订单状态为：" + orderStatus + "！");            return "fail";        }    } else {        logger.error("支付宝订单" + orderCode + "异步回执接收失败，订单状态为：" + orderStatus + "！");        return "fail";    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java微信订单查询]]></title>
      <url>/java/pay/2018/03/31/Java-%E5%BE%AE%E4%BF%A1%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  Java 通过统一下单 API 进行订单支付后，除等待微信通过 notify_url 进行回调通知外，还可以主动查询订单状态前置条件可参考 Java 微信扫码支付 如果实现微信支付官网【微信支付】扫码支付开发者文档定义请求参数对象  订单查询请求参数（必填）public class QueryOrderRequest {    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 商户订单号，32位以内，不重复    private String out_trade_no;    // 随机字符串，32位以内    private String nonce_str;    // 签名，遵循签名算法    private String sign;}  查询订单请求参数（非必填）public class QueryOrderRequestExt extends QueryOrderRequest {    // 签名类型，默认MD5    private String sign_type;}定义接收参数对象  查询订单接收参数（必填）public class QueryOrderResponse {    // 返回状态码，通信标识，SUCCESS/FAIL    private String return_code;    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 随机字符串    private String nonce_str;    // 签名    private String sign;    // 业务结果，交易标识，SUCCESS/FAIL    private String result_code;    // 用户标识    private String openid;    // 交易类型，JSAPI，NATIVE，APP    private String trade_type;    // 交易状态，SUCCESS-成功 USERPAYING-支付中    private String trade_state;    // 付款银行    private String bank_type;    // 标价金额，单位分    private int total_fee;    // 现金支付金额    private int cash_fee;    // 微信支付订单号    private String transaction_id;    // 商户订单号    private String out_trade_no;    // 支付完成时间    private String time_end;    // 交易状态描述    private String trade_state_desc;}  查询订单接收参数（非必填）public class QueryOrderResponseExt extends QueryOrderResponse {    // 返回信息，非空则表示返回了错误信息    private String return_msg;    // 错误代码    private String err_code;    // 错误代码描述    private String err_code_des;    // 设备号    private String device_info;    // 是否关注公众号    private String is_subscribe;    // 应结订单金额    private String settlement_total_fee;    // 标价币种    private String fee_type;    // 现金支付币种    private String cash_fee_type;    // 附加数据    private String attach;}生成订单信息  SOPConstants.WECHAT_PAY_APP_ID 是公众账号 id  SOPConstants.WECHAT_PAY_MCH_ID 是商户id  WechatUtil.makeNonceStr() 是生成的随机字符串  WechatUtil.makeSign(BeanMap.create(ext)) 是根据请求参数制作签名  WechatUtil.truncateDataToXML(QueryOrderRequestExt.class, ext) 是将数据转换为 XML 形式private String generateOrderInfo(Long orderId) {    OrderDTO order = orderManageService.getOrder(orderId);    QueryOrderRequestExt ext = new QueryOrderRequestExt();    ext.setAppid(SOPConstants.WECHAT_PAY_APP_ID);    ext.setMch_id(SOPConstants.WECHAT_PAY_MCH_ID);    ext.setOut_trade_no(order.getCode());    ext.setNonce_str(WechatUtil.makeNonceStr());    ext.setSign(WechatUtil.makeSign(BeanMap.create(ext)));    return WechatUtil.truncateDataToXML(QueryOrderRequestExt.class, ext);}向微信发起订单查询请求  SOPConstants.WECHAT_PAY_QUERY_URL 是微信订单查询的请求 URL  WechatConnection.connect() 是向微信发起请求的通用方法  只有 ext.getResult_code() ext.getResult_code()  ext.getTrade_state() 的值都是 SUCCESS 才能确定订单支付成功public Boolean getPayResult(Long orderId) {    String orderInfo = generateOrderInfo(orderId);    QueryOrderResponseExt ext = null;    try {        ext = (QueryOrderResponseExt) WechatConnection.connect(SOPConstants.WECHAT_PAY_QUERY_URL, orderInfo, QueryOrderResponseExt.class);    } catch (IOException e) {        logger.error("微信查询订单" + orderId + "失败！", e);    }    if (ext == null) {        return false;    }    if (WechatConnection.SUCCESS_CODE.equals(ext.getResult_code())) {        if (WechatConnection.SUCCESS_CODE.equals(ext.getResult_code()) &amp;&amp; WechatConnection.SUCCESS_CODE.equals(ext.getTrade_state())) {            // 更新订单状态            orderPayService.updateOrderInfo(ext.getOut_trade_no(), OrderPay.wchatPay.getCode());            return true;        } else {            logger.error("订单" + orderId + "交易失败，交易状态：" + ext.getTrade_state());            return false;        }    } else {        logger.error("订单" + orderId + "查询失败！");        return false;    }}微信支付相关操作工具类  该工具类目前提供了数据转换、签名生成、随机数生成的通用方法public class WechatUtil {    private static Logger logger = LoggerFactory.getLogger(WechatUtil.class);    /**     * 数据转换为xml格式     *     * @param object     * @param obj     * @return     */    public static String truncateDataToXML(Class&lt;?&gt; object, Object obj) {        XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));        xStream.alias("xml", object);        return xStream.toXML(obj);    }    /**     * 数据转换为对象     *     * @param object     * @param str     * @return     */    public static Object truncateDataFromXML(Class&lt;?&gt; object, String str) {        XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));        xStream.alias("xml", object);        return xStream.fromXML(str);    }    /**     * 生成随机字符串     *     * @return     */    public static String makeNonceStr() {        StringBuffer str = new StringBuffer(DateUtil.getSysDateString("yyyyMMddHHmmssS"));        str.append((new Random().nextInt(900) + 100));        return str.toString();    }    /**     * 拼接签名数据     *     * @return     */    public static String makeSign(BeanMap beanMap) {        SortedMap&lt;String, String&gt; signMaps = Maps.newTreeMap();        for (Object key : beanMap.keySet()) {            Object value = beanMap.get(key);            // 排除空数据            if (value == null) {                continue;            }            signMaps.put(key + "", String.valueOf(value));        }        // 生成签名        return generateSign(signMaps);    }    /**     * 生成签名     *     * @param signMaps     * @return     * @throws Exception     */    public static String generateSign(SortedMap&lt;String, String&gt; signMaps) {        StringBuffer sb = new StringBuffer();        // 字典序        for (Map.Entry signMap : signMaps.entrySet()) {            String key = (String) signMap.getKey();            String value = (String) signMap.getValue();            // 为空不参与签名、参数名区分大小写            if (null != value &amp;&amp; !"".equals(value) &amp;&amp; !"sign".equals(key) &amp;&amp; !"key".equals(key)) {                sb.append(key).append("=").append(value).append("&amp;");            }        }        // 拼接key        sb.append("key=").append(SOPConstants.WECHAT_PAY_KEY);        // MD5加密        return Objects.requireNonNull(encoderByMd5(sb.toString())).toUpperCase();    }    /**     * 利用MD5进行加密     *     * @param str 待加密的字符串     * @return 加密后的字符串     */    private static String encoderByMd5(String str) {        // 生成一个MD5加密计算摘要        MessageDigest md = null;        try {            md = MessageDigest.getInstance("MD5");        } catch (NoSuchAlgorithmException e) {            logger.error("MD5加密失败！", e);        }        if (md == null) {            return null;        }        // 计算md5函数        md.update(str.getBytes());        // digest()最后确定返回md5 hash值，返回值为8为字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符        // BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值        return new BigInteger(1, md.digest()).toString(16);    }}微信支付请求建立类public class WechatConnection {    // 成功标志    public static final String SUCCESS_CODE = "SUCCESS";    /**     * 建立微信连接，并返回结果     *     * @param url     * @param info     * @param object     * @return     * @throws IOException     */    public static Object connect(String url, String info, Class&lt;?&gt; object) throws IOException {        // 建立连接        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();        conn.setConnectTimeout(8000);        conn.setRequestMethod("POST");        conn.setDoOutput(true);        // 发送数据        BufferedOutputStream bos = new BufferedOutputStream(conn.getOutputStream());        bos.write(info.getBytes());        bos.flush();        bos.close();        // 获取数据        BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));        // 接收数据        String line;        StringBuffer str = new StringBuffer();        while ((line = reader.readLine()) != null) {            str.append(line);        }        return WechatUtil.truncateDataFromXML(object, str.toString());    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> wechatpay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[BeanMap 实现对象转换 Map]]></title>
      <url>/java/map/2018/03/31/BeanMap-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2-Map/</url>
      <content type="text"><![CDATA[  通过 org.springframework.cglib.beans 的 BeanMap 可以实现对象将字段和字段值直接转换为 Map 的 key-value 形式实现方式SortedMap&lt;String, String&gt; signMaps = Maps.newTreeMap();BeanMap beanMap = BeanMap.create(ext);for (Object key : beanMap.keySet()) {    Object value = beanMap.get(key);    // 排除空数据    if (value == null) {        continue;    }    signMaps.put(key + "", String.valueOf(value));}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> map </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> map </tag>
        
          <tag> spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL DATE_ADD() 方法]]></title>
      <url>/database/mysql/2018/03/22/MySQL-DATE_ADD()-%E6%96%B9%E6%B3%95/</url>
      <content type="text"><![CDATA[  用于向日期添加指定的时间间隔语法DATE_ADD(date, INTERVAL num TYPE)示例DATE_ADD('2018-03-22 10:23:00', INTERVAL 30 MINUTE)解析  date 只要是合法的日期表达式即可  num 是希望添加的时间间隔值  TYPE 是时间间隔的单位          MICROSECOND      SECOND      MINUTE      HOUR      DAY      WEEK      MONTH      QUARTER      YEAR      SECOND_MICROSECOND      MINUTE_MICROSECOND      MINUTE_SECOND      HOUR_MICROSECOND      HOUR_SECOND      HOUR_MINUTE      DAY_MICROSECOND      DAY_SECOND      DAY_MINUTE      DAY_HOUR      YEAR_MONTH      ]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[ajaxForm 表单异步提交]]></title>
      <url>/jquery/2018/03/21/ajaxForm-%E8%A1%A8%E5%8D%95%E5%BC%82%E6%AD%A5%E6%8F%90%E4%BA%A4/</url>
      <content type="text"><![CDATA[  实现表单的异步提交官网GitHub - jquery-form/form: jQuery Form Plugin]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
          <tag> form </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[QuickSearch 快捷搜索]]></title>
      <url>/jquery/2018/03/21/QuickSearch-%E5%BF%AB%E6%8D%B7%E6%90%9C%E7%B4%A2/</url>
      <content type="text"><![CDATA[  可实现列表的无刷新过滤官网GitHub - riklomas/quicksearch]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 实现阿里云直播]]></title>
      <url>/java/jquery/aliyun/2018/03/19/Java-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B4%E6%92%AD/</url>
      <content type="text"><![CDATA[  阿里云播放器直接在线点播视频以及直播技术，此处记录直播实现过程官网阿里云直播-快速入门 准备步骤  创建 阿里云账号  根据 流程 完成实名认证，以确保可以使用阿里云相应服务  在密钥管理页面获取阿里云访问密钥，AccessKeyId 和 AccessKeySecret  开通阿里云直播服务关键点  阿里云直播服务端提供了 一系列 API ，但如果只是单纯的直播[推流和拉流] ，实际不需要使用这些 API推流准备  推流即直播人员进行视频播放的操作，这需要使用推流客户端 第三方推流工具 OBS  在推流工具中需要指定推流地址、流名称、鉴权密钥  如果上述信息阿里云验证合法，既可以开始直播，在阿里云后端可以看到正在直播的流信息拉流准备  拉流即直播观众通过视频播放器在线获取直播信息，播放器使用 阿里云播放器 即可，该播放器目前只是阿里云的点播和直播服务  获取拉流地址后传入播放器，即可开始观看直播Java 开发注意点  在阿里云直播的文档中有提供 Java SDK          目前 SDK 中推荐引入的版本号是 2.3.0 ，但其实所有 API 参照的都是最新版 SDK ，最新的版本号可在 阿里云SDK频道 找到        但如果只是单纯的直播[推流和拉流] ，则不需要进行以上操作  推流的关键点在于 直播鉴权          此处介绍的直播鉴权只是说的 auth_key 的拼接和验证规则      完整的推流和拉流地址并不知这些，需要依旧案例参考      获取推流地址  此处获取的只是推流地址的房间号及其他请求参数  完整的推流地址需要加上阿里云直播中心地址和用户的产品名称          直播中心地址 http://video-center.alivecdn.com      产品名称[支持自定义] /appName/        vhost 用于接收拉流地址，即申请阿里云直播时准备的直播域名  此处使用 Java MD5加密 实现字串加密，加密后长度需要是 32 位  加密串中的 Constants.ALI_LIVE_PRIVATE_KEY  可在阿里云后端的直播鉴权处获取// 获取推流地址public String getPushUri(String roomName, Long endTime) {    return getRoomName(roomName) + "vhost=" + Constants.ALI_LIVE_PULL_URL + "&amp;" + generateAuthKey(roomName, endTime);}// 房间号private String getRoomName(String roomName) {    return roomName + "?";}// 完整验签串private String generateAuthKey(String roomName, Long endTime) {    return "auth_key=" + endTime + generateUuid() + generateEncryptStr(roomName, endTime);}// 唯一标识private String generateUuid() {    String uuid = "0";    String uid = "0";    return "-" + uuid + "-" + uid + "-";}// 验签密钥private String generateEncryptStr(String roomName, Long endTime) {    String uri = Constants.ALI_LIVE_APP_NAME + roomName;    return md5(uri + "-" + endTime + generateUuid() + Constants.ALI_LIVE_PRIVATE_KEY);}获取拉流地址  此处获取的拉流地址是完整的，因为拉流地址是直接获取后传入前端的阿里云播放器中  注意房间名后面加的后缀 .m3u8 用于表示接受的直播视频类型，阿里云官方还提供其他几种类型，可在文档中查看  拉流地址和推流地址最大的区别在于请求地址的不同，拉流是请求自己提供给阿里云的直播域名，而拉流是请求阿里云的直播中心  而且推流时需要指定 vhost 告知阿里云直播域名，但拉流时不需要  获取到拉流地址后可直接参照 Java + jQuery 实现阿里云播放器接口 实现播放器的对接          在播放器的的配置中指明 isLive: true 表名是直播操作      上述笔记中实现的是点播接口，利用的通过 vid 获取 playAuth 的方式，这不适用于直播      直播需要直接指定 source: url 即可      public String getPullUrl(String roomName, Long endTime) {    roomName += ".m3u8";    return "http://" + Constants.ALI_LIVE_PULL_URL + generateUri(roomName) + generateAuthKey(roomName, endTime);}// 获取请求参数private String generateUri(String roomName) {	return Constants.ALI_LIVE_APP_NAME + getRoomName(roomName);}// 房间号private String getRoomName(String roomName) {    return roomName + "?";}// 完整验签串private String generateAuthKey(String roomName, Long endTime) {    return "auth_key=" + endTime + generateUuid() + generateEncryptStr(roomName, endTime);}// 唯一标识private String generateUuid() {    String uuid = "0";    String uid = "0";    return "-" + uuid + "-" + uid + "-";}// 验签密钥private String generateEncryptStr(String roomName, Long endTime) {    String uri = Constants.ALI_LIVE_APP_NAME + roomName;    return md5(uri + "-" + endTime + generateUuid() + Constants.ALI_LIVE_PRIVATE_KEY);}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> jquery </category>
        
          <category> aliyun </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> jquery </tag>
        
          <tag> aliyun </tag>
        
          <tag> player </tag>
        
          <tag> live </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Labelauty 复选框美化]]></title>
      <url>/jquery/2018/03/16/Labelauty-%E5%A4%8D%E9%80%89%E6%A1%86%E7%BE%8E%E5%8C%96/</url>
      <content type="text"><![CDATA[  一款对 HTML 原生复选框进行美化的简单插件官网jquery-labelauty]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
          <tag> checkbox </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 实现阿里云短信]]></title>
      <url>/java/aliyun/2018/03/11/Java-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1/</url>
      <content type="text"><![CDATA[  阿里云提供一套短信发送的服务可通过 Java 进行对接官网短信发送API(SendSms)—阿里云准备步骤  创建 阿里云账号  根据 流程 完成实名认证，以确保可以使用阿里云相应服务  在密钥管理页面获取阿里云访问密钥，AccessKeyId 和 AccessKeySecret  想要成功发送一条短信需要获取 短信签名 和 短信模版在项目 pom 中引入对接所需要的 jar 包&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;    &lt;version&gt;3.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt;    &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;获取对接需要的数据  将 AccessKeyId 、AccessKeySecret 、SignName 、TemplateCode 进行相应存储新建 MessageServiceImpl 类用于和阿里云短信接口对接@Servicepublic class MessageServiceImpl extends AbstractBaseService {		...}在上述类中生成一个静态块用于在初始化对接信息  Constants.ALI_ACCESS_KEY_ID 和 Constants.ALI_ACCESS_SECRET 是密钥，成对生成和使用  其他参数信息按照阿里云开发手册说明，均不需要改变// 用于从阿里云获取数据的权限客户端private static IAcsClient iAcsClient;static {    // 超时时间    System.setProperty("sun.net.client.defaultConnectTimeout", "10000");    System.setProperty("sun.net.client.defaultReadTimeout", "10000");    // 初始化配置    String regionId = "cn-hangzhou";    DefaultProfile profile = DefaultProfile.getProfile(regionId, Constants.ALI_ACCESS_KEY_ID, Constants.ALI_ACCESS_SECRET);    try {        String productId = "Dysmsapi";        String domain = "dysmsapi.aliyuncs.com";        DefaultProfile.addEndpoint(regionId, regionId, productId, domain);    } catch (ClientException e) {        throw new TSharkException("初始化短信接口配置失败！", e);    }    // 初始化权限客户端    iAcsClient = new DefaultAcsClient(profile);}创建用于发送短信的 sendMessage 方法  发送短信之前通常需要验证短信是否已发送，防止重复发送  为了验证短信是否发送可将通过短信发送的验证码存放于 Redis 中  Constants.ALI_MESSAGE_SIGN_NAME 是从阿里云获取的短信签名  为提高公用性，发送短信的方法支持从外部调用时传入具体模版编号  短信接口调用时如果出现异常反馈，请参照 短信接口调用错误码@Autowiredprivate RedisHelper redisHelper;public Boolean sendMessage(String mobile, String template) {    // 有效性验证    if (checkMobile(mobile)) {        throw new TSharkException("验证码已发送，请稍后再试！");    }    SendSmsRequest request = new SendSmsRequest();    SendSmsResponse response = null;    // 生成随机数    String random = String.valueOf(new Random().nextInt(999999));    request.setMethod(MethodType.POST);    request.setPhoneNumbers(mobile);    request.setSignName(Constants.ALI_MESSAGE_SIGN_NAME);    request.setTemplateCode(template);    request.setTemplateParam("{\"name\":\"" + mobile + "\", \"code\":\"" + random + "\"}");    try {        response = iAcsClient.getAcsResponse(request);    } catch (ClientException e) {        throw new TSharkException("接收短信回执失败！", e);    }    boolean result = response.getCode() != null &amp;&amp; response.getCode().equals("OK");    if (result) {        // 保存随机数        saveRandom(mobile, random);    }    return result;}通过 Redis 验证短信是否发送private Boolean checkMobile(String mobile) {    String randomKey = "random:" + mobile;    return redisHelper.get(randomKey) != null;}短信发送成功后需要将手机号和验证码成对存储于 Redis 中，以供之后使用private void saveRandom(String mobile, String random) {    String randomKey = "random:" + mobile;    if (checkMobile(mobile)) {        return;    }    redisHelper.set(randomKey, random);    // 5分钟失效    redisHelper.expire(randomKey, 5, TimeUnit.MINUTES);}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> aliyun </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> aliyun </tag>
        
          <tag> message </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java + jQuery 实现阿里云点播]]></title>
      <url>/java/jquery/aliyun/2018/03/11/Java-+-jQuery-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%82%B9%E6%92%AD/</url>
      <content type="text"><![CDATA[  阿里云播放器直接在线点播视频以及直播技术，此处记录点播实现过程官网获取阿里云视频播放凭证阿里云Aliplayer播放器准备步骤  创建 阿里云账号  根据 流程 完成实名认证，以确保可以使用阿里云相应服务  在密钥管理页面获取阿里云访问密钥，AccessKeyId 和 AccessKeySecret后端相关操作在项目 pom 中引入所需 jar 包&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;    &lt;version&gt;3.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;获取对接需要的数据  将 AccessKeyId 、AccessKeySecret 进行相应存储新建 VideoController 用于接收前端获取视频播放凭证的请求@Controller@RequestMapping("/api/video")public class VideoController extends AbstractBaseController {    @Autowired    private VideoServiceImpl videoServiceImpl;    /**     * 获取播放凭证     *     * @param videoId     * @return     */    @RequestMapping(value = "/auth", method = RequestMethod.POST)    @ResponseBody    public ResponseData playAuth(@RequestParam final String videoId) {        return new SimpleActionHandler(request) {            @Override            protected void doHandle(ResponseData responseData) throws Exception {                responseData.setData(videoServiceImpl.getVideoPlayAuth(videoId));            }        }.handle();    }}新建 VideoServiceImpl 用于和阿里云播放器接口对接@Servicepublic class VideoServiceImpl extends AbstractBaseService {	...}在 VideoServiceImpl 中添加获取客户端的 getClient() 方法  Constants.ALI_ACCESS_KEY_ID 和 Constants.ALI_ACCESS_SECRET 是密钥，成对生成和使用  其他参数信息按照阿里云开发手册说明，均不需要改变private DefaultAcsClient getClient() {    // 初始化配置    DefaultProfile profile = DefaultProfile.getProfile("cn-shanghai", Constants.ALI_ACCESS_KEY_ID, Constants.ALI_ACCESS_SECRET);    // 获取客户端    return new DefaultAcsClient(profile);}通过外部传入的视频 id 从客户端获取视频播放凭证public String getVideoPlayAuth(String videoId) {    GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest();    GetVideoPlayAuthResponse response = null;    // 播放id    request.setVideoId(videoId);    try {        response = getClient().getAcsResponse(request);    } catch (ClientException e) {        logger.error("视频客户端获取失败！", e);    }    if (response != null) {        return response.getPlayAuth();    }    return null;}前端相关操作引入播放器所需要的 css/js 文件  以下引入的 js 文件为通用版本，包括了 flash 和 h5 的播放器  如果只想单独引入 flash 或 h5 ，只需要将名称中间加上对应标识即可，例如 aliplayer-h5-min.js  css 文件为公有版本，无需区分类型&lt;link rel="stylesheet" href="//g.alicdn.com/de/prismplayer/2.5.1/skins/default/aliplayer-min.css"/&gt;&lt;script charset="utf-8" type="text/javascript" src="//g.alicdn.com/de/prismplayer/2.5.1/aliplayer-min.js"&gt;&lt;/script&gt;准备待转化为播放器的标签内容  标签中的 data-id 是将视频传入到阿里云播放器后端之后返回的一个 vid  该 vid 可以通过 接口上传 也可以通过阿里云后端上传，此处不做介绍&lt;div class="prism-player" id="prismPlayer" data-id="281fc1687cb245658dc5e7462e54bc66"&gt;&lt;/div&gt;初始化视频播放器  $.ts.doAction 是经过封装后的 ajax 操作  Aliplayer({...}) 则是具体的播放器初始化操作var playerTag = target.find("#prismPlayer");var videoId = playerTag.data("id");// 移除文字标识playerTag.empty();// 非空验证if (videoId === undefined) {    return;}$.ts.doAction("/api/video/auth", {    videoId: videoId}, function () {    Aliplayer({        id: "prismPlayer",        autoplay: true,        width: "100%",        vid: videoId,        playauth: this.data    });}, '', '', '');]]></content>
      <categories>
        
          <category> java </category>
        
          <category> jquery </category>
        
          <category> aliyun </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> jquery </tag>
        
          <tag> aliyun </tag>
        
          <tag> player </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis抛出You can't operate on a closed Connection!!!]]></title>
      <url>/java/mybatis/error/2018/03/08/MyBatis%E6%8A%9B%E5%87%BAYou-can't-operate-on-a-closed-Connection!!!/</url>
      <content type="text"><![CDATA[  有时候通过 Session 获取数据库连接时为空碰到的问题  一般通过以下方式获取数据库连接  但有时候会出现获取不到连接，从而抛出 You can’t operate on a closed Connection!!! 的异常Connection connection = this.SqlSession().getConnection();解决的方式  使用以下方式获取数据库连接可保证获取的连接存在与事务中不会莫名丢失SqlSessionTemplate st = (SqlSessionTemplate) this.getSqlSession();SqlSession session = SqlSessionUtils.getSqlSession(st.getSqlSessionFactory(), st.getExecutorType(), st.getPersistenceExceptionTranslator());Connection connection = session.getConnection();]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[video标签隐藏下载按钮]]></title>
      <url>/css/video/2018/03/01/video%E6%A0%87%E7%AD%BE%E9%9A%90%E8%97%8F%E4%B8%8B%E8%BD%BD%E6%8C%89%E9%92%AE/</url>
      <content type="text"><![CDATA[  通过CSS3的伪类样式强制将video标签的下载按钮隐藏实现方式video::-webkit-media-controls-enclosure {    overflow: hidden;}video::-webkit-media-controls-panel {    width: calc(100% + 30px);}]]></content>
      <categories>
        
          <category> css </category>
        
          <category> video </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
          <tag> video </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[List抛出ConcurrentModificationException]]></title>
      <url>/java/list/error/2018/03/01/List%E6%8A%9B%E5%87%BAConcurrentModificationException/</url>
      <content type="text"><![CDATA[  在对 List 进行遍历的同时进行 remove 元素操作，可能会抛出 java.util.ConcurrentModificationException 异常错误示范  在遍历 List 时获取元素实际上通过迭代器在进行，迭代器在获取下一个元素时会对 modCount 和 expectedCount 进行匹配  遍历的同时直接对 List 进行 remove 操作，会导致只有 modCount 发生变化，而expectedCount 未发生变化  所以迭代器在获取下一个元素会发现两个值不匹配则抛出 java.util.ConcurrentModificationException 异常for (CourseDTO course : courses) {    for (MemberCourseDTO memberCourse : memberCourses) {        if (course.getId().equals(memberCourse.getCourse().getId())) {            courses.remove(course);        }    }}正确处理  使用迭代器原生的 remove 方法去操作 List 元素即可for (Iterator&lt;CourseDTO&gt; it = courses.iterator(); it.hasNext(); ) {    CourseDTO course = it.next();    for (MemberCourseDTO memberCourse : memberCourses) {        if (course.getId().equals(memberCourse.getCourse().getId())) {            // 移除当前元素            it.remove();        }    }}Java 8 的处理方式question.getOptions().removeIf(option -&gt; option.getContent().trim().equals(""));]]></content>
      <categories>
        
          <category> java </category>
        
          <category> list </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> list </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS图片滤镜灰度]]></title>
      <url>/css/2018/02/22/CSS%E5%9B%BE%E7%89%87%E6%BB%A4%E9%95%9C%E7%81%B0%E5%BA%A6/</url>
      <content type="text"><![CDATA[  通过CSS可简单实现将彩色图片变为灰色图片实现方式#targetLanguagePanel .language-item img:hover {	filter: grayscale(100%);}]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript数组属性]]></title>
      <url>/javascript/array/2018/02/11/Javascript%E6%95%B0%E7%BB%84%E5%B1%9E%E6%80%A7/</url>
      <content type="text"><![CDATA[  Javascript数组可用来存储多个数组，但他也有些不常见的内置功能数组的真面目  数组的索引其实也是数组的属性，所以如下操作是等同的let array = ['Tom', 'Jerry']console.log(array[0]) =&gt; Tomconsole.log(array.0) =&gt; Tom   数组的内置属性let array = ['Tom', 'Jerry']console.log(array.length) =&gt; 2console.log(array['length']) =&gt; 2  数组其实可以添加自定义属性，因为数组其实也是一个object对象let array = ['Tom', 'Jerry']array.itemName = 'wow'console.log(array.itemName) =&gt; wow循环数组的元素  自从ES6发布之后，可以不再使用传统的 for 循环对数组进行遍历，而可以使用 for ... of 循环直接操作数组元素for (let item of array) {	console.log(item)}数组元素的数量不等于数组长度  通常情况下数组元素的数量就是数组的长度，但这种关系非常脆弱，参见如下代码let array = []array.lentgh = 3console.log(array.length) =&gt; 3array[5] = 'Lily'console.log(array.length) =&gt; 5]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> array </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> array </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue获取组件name属性]]></title>
      <url>/vue/components/2018/02/05/Vue%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6name%E5%B1%9E%E6%80%A7/</url>
      <content type="text"><![CDATA[  Vue在编写组件时一般都会显式的指明其name属性获取name属性this.$options.name]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> components </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> components </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Nginx实现Tomcat隐藏端口号]]></title>
      <url>/nginx/tomcat/2018/02/05/Nginx%E5%AE%9E%E7%8E%B0Tomcat%E9%9A%90%E8%97%8F%E7%AB%AF%E5%8F%A3%E5%8F%B7/</url>
      <content type="text"><![CDATA[  Tomcat默认可以使用80端口实现隐藏端口号，但80端口权限过高，通常会被防火墙禁用无法直接访问但是可以通过Nginx反向代理实现监听80端口转发到对应的Tomcat服务器实现方式  在Nginx的配置文件 nginx.conf 中添加如下配置          该文件的在 /usr/local/etc/nginx/ 下      server {	listen       80;	server_name  127.0.0.1;	server_name_in_redirect off;	proxy_set_header Host $host:$server_port;	proxy_set_header X-Real-IP $remote_addr;	proxy_set_header REMOTE-HOST $remote_addr;	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;	location / {		proxy_pass http://127.0.0.1:8090/;	}}  分别启动Tomcat和Nginx即可实现隐藏端口号直接访问的效果]]></content>
      <categories>
        
          <category> nginx </category>
        
          <category> tomcat </category>
        
      </categories>
      <tags>
        
          <tag> nginx </tag>
        
          <tag> tomcat </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Nginx安装与配置]]></title>
      <url>/nginx/homebrew/2018/02/05/Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  通过 homebrew 快捷安装 Nginx安装brew install nginx启动服务通过brew启动brew services start nginx直接启动sudo nginx停止服务通过brew停止brew services stop nginx直接停止sudo nginx -s stop]]></content>
      <categories>
        
          <category> nginx </category>
        
          <category> homebrew </category>
        
      </categories>
      <tags>
        
          <tag> nginx </tag>
        
          <tag> homebrew </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate防止setter()方法更新数据库]]></title>
      <url>/java/hibernate/2018/02/05/Hibernate%E9%98%B2%E6%AD%A2setter()%E6%96%B9%E6%B3%95%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="text"><![CDATA[  Hibernate从数据库获取到对象后直接调用其setter()方法对内部数据做更改，可能会导致直接将数据更新至数据库产生问题的原因  Hibernate分为三种基本状态：游离态，自由态，持久态  从数据库中获取到对象属于持久态，直接进行操作会导致处于Session中的数据发生改变，从而触发数据库更新解决办法  获取到当前的Session对象，将该对象从Session中清除super.getEntityDao().getSession().evict(userWork);]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue集成highlight.js]]></title>
      <url>/vue/2018/02/03/Vue%E9%9B%86%E6%88%90highlight.js/</url>
      <content type="text"><![CDATA[  highlight.js是一个比较实用的语法高亮插件，但其默认并不能在Vue中直接使用在项目的package.json文件中安装highlight.js{	...	"dependencies": {		...		"highlight.js": "^9.12.0"	},	...}编写集成文件，稍后会作为自定义插件引入Vueimport Hljs from 'highlight.js'import 'highlight.js/styles/googlecode.css'let Highlight = {}Highlight.install = (Vue, options) =&gt; {  Vue.directive('highlight', (el) =&gt; {    let blocks = el.querySelectorAll('pre code')        blocks.forEach((block) =&gt; {      Hljs.highlightBlock(block)    })  })}export default Highlight在main.js中引入上述文件...import Highlight from './assets/plugins/highlight/highlight.js'Vue.use(Highlight)...在需要使用到语法高亮的标签上使用v-highlight并传入待显示内容  由于定义的监听规则是带 pre code 的内容，所以可能需要手动为待显示内容进行一次标签包裹&lt;div v-highlight v-html="showFileContent"&gt;&lt;/div&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue自定义v-model]]></title>
      <url>/vue/2018/02/02/Vue%E8%87%AA%E5%AE%9A%E4%B9%89v-model/</url>
      <content type="text"><![CDATA[  Vue的v-model双向绑定非常实用，对于自定义组件也可以自定义实现v-model实现方案  在组件的 props 中定义 value 值用于接收父级传入的内容props: {  value: {    type: Boolean,    default: false  }}  在组件的 data() 中定义将 value 另存为的实际值data () {  return {    show: false  }}  在组件的 watch 中监听两个值的变化          监听 value 变化的目的是将最新的值专递给组件中的实际值      监听 show 变化的目的是当实际值发生变化时告知父容器传入值已发生变化      watch: {  value (val) {    if (val === this.show) {      return false    }    this.show = val  },  show (val) {    this.$emit('input', val)  }}  在父容器中使用 v-model 传入需要双向绑定的值即可]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java8 Lambda遍历集合]]></title>
      <url>/java/jdk8/2018/01/20/Java8-Lambda%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88/</url>
      <content type="text"><![CDATA[  Java8支持使用Lambda语法对集合进行遍历，语法如下ListallQuestions.forEach(question -&gt; {    if (question.getType().getCode().equals(typeCode)) {        filterQuestions.add(question);    }});Mapitems.forEach((k, v) -&gt; {    System.out.println("Item : " + k + " Count : " + v);    if("E".equals(k)) {        System.out.println("Hello E");    }});]]></content>
      <categories>
        
          <category> java </category>
        
          <category> jdk8 </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> jdk8 </tag>
        
          <tag> for </tag>
        
          <tag> map </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Git命令大全]]></title>
      <url>/git/2018/01/17/Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      <content type="text"><![CDATA[  列举一些git常用命令代码库相关常用 Git 命令清单 - 阮一峰的网络日志常规提交  添加被修改的文件到暂存区 git add .  提交暂存区文件 git commit -m xxxx  推送至服务器 git push]]></content>
      <categories>
        
          <category> git </category>
        
      </categories>
      <tags>
        
          <tag> git </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IntelliJ IDEA隐藏文件或文件夹]]></title>
      <url>/software/idea/2018/01/14/IntelliJ-IDEA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
      <content type="text"><![CDATA[  IDEA可以通过以下设置隐藏目录中不想看到的文件夹操作步骤  按Command+,打开Preferences窗口  在Editor &gt; File Types窗口的最下端找到lgnore files and folesrs  按照输入规则输入需要隐藏的文件夹即可]]></content>
      <categories>
        
          <category> software </category>
        
          <category> idea </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> idea </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IntelliJ IDEA解决Tomcat部署项目NoClassDefFoundError报错]]></title>
      <url>/software/idea/2018/01/14/IntelliJ-IDEA%E8%A7%A3%E5%86%B3Tomcat%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AENoClassDefFoundError%E6%8A%A5%E9%94%99/</url>
      <content type="text"><![CDATA[  使用Tomcat部署Web项目时，项目所需要的jar包都会被复制到对应的lib目录下，但有时会出现jar包复制不完全的情况，则会出现java.lang.NoClassDefFoundError的报错将未添加到lib目录下的jar包进去添加  按Command+;打开Project Structure窗口  找到对应的项目后在Output Layout窗口中查看Available Elements  打开对应项目，如果存在一些jar包列表则说明这些jar包没有被添加到lib目录下  选中需要的jar包点击右键并put into _WEB-INF_lib即可]]></content>
      <categories>
        
          <category> software </category>
        
          <category> idea </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> idea </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate @OneToOne 自动新增和删除]]></title>
      <url>/java/hibernate/2018/01/12/Hibernate-@OneToOne-%E8%87%AA%E5%8A%A8%E6%96%B0%E5%A2%9E%E5%92%8C%E5%88%A0%E9%99%A4/</url>
      <content type="text"><![CDATA[  Hibernate创建一对一关系时两张表主表保持一致则可以实现自动新增和删除主表配置  主表对应类中需要通过@OneToOne来表示其与从表的关系@Entity@Table(name = "sys_user")public class User {    @Id    @GeneratedValue(strategy = IDENTITY)    private Long id = new Long(0);    @OneToOne(cascade = {CascadeType.ALL}, mappedBy = "user", fetch = FetchType.LAZY)    @JsonIgnore    private UserAccount userAccount;    public UserAccount getUserAccount() {        return userAccount;    }    public void setUserAccount(UserAccount userAccount) {        this.userAccount = userAccount;    }}从表配置  从表中的id需要通过@GeneratedValue和@GenericGenerator来指明该值从主表中获取  从表中同时需要通过@OneToOne来表示其与主表的关系          在维护与主表关系中需要通过@PrimaryKeyJoinColumn来表示两个表是主键关联，不存在多余外键      @Entity@Table(name = "sys_user_account")public class UserAccount {    @Id    @GeneratedValue(generator = "generator")    @GenericGenerator(name = "generator", strategy = "foreign", parameters = @Parameter(name = "property", value = "user"))    private Long id = 0L;    @OneToOne(fetch = FetchType.LAZY)    @PrimaryKeyJoinColumn    private User user;    public UserAccount() {    }    public UserAccount(User user) {        this.user = user;    }    public Long getId() {        return id;    }    public void setId(Long id) {        this.id = id;    }    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}保存操作  主表在执行保存操作时，需要将从表注入其中，同时将主表的引入也注入到从表，才能实现两个对象的双向关联  当主表的id自增成功时，由于从表保有对主表的引用，所以也可以得到主表的idpublic void save(User user) {    if (user.isNew()) {        user.setUserAccount(new UserAccount(user));        super.save(user);    } else {        super.save(userModel);    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot从数据库加载配置信息]]></title>
      <url>/java/springboot/hibernate/2017/12/31/SpringBoot%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
      <content type="text"><![CDATA[  Spring Boot 通过@Value注解可实现获取配置文件中的数据，而配置文件中的数据可以通过修改MutablePropertySources从数据库注入该示例基于Hibernate实现实体类  根据Hibernate的配置，实体类对应数据库中的表即可@Entity@Table(name = "sys_config")@Inheritance(strategy = InheritanceType.SINGLE_TABLE)public class Config implements Serializable {    @Id    private Long id;    @Column    private String code;    @Column    private String value;    @Column    private String name;    @Column    private String description;  ...}服务类  服务类用于从数据库中获取列表信息@Servicepublic class SystemConfigService extends SimpleHibernateService&lt;Config, Long&gt; {   ...}配置类  该配置类会在系统启动时自动加载  根据内部逻辑会将从数据库取出的列表信息注入到MutablePropertySources属性集合中  动态注入的属性集合无需有对应的 .properties 文件存在@Configurationpublic class SystemConfig {    @Autowired    private ConfigurableEnvironment environment;    @Autowired    private SystemConfigService service;    @PostConstruct    public void initDatabasePropertySourceUsage() {        // 获取系统属性集合        MutablePropertySources propertySources = environment.getPropertySources();        try {            // 从数据库获取自定义变量列表            Map&lt;String, String&gt; collect = service.getAll().stream().collect(Collectors.toMap(Config::getCode, Config::getValue));            // 将转换后的列表加入属性中            Properties properties = new Properties();            properties.putAll(collect);            // 将属性转换为属性集合，并指定名称            PropertiesPropertySource constants = new PropertiesPropertySource("system-config", properties);            // 定义寻找属性的正则，该正则为系统默认属性集合的前缀            Pattern p = Pattern.compile("^applicationConfig.*");            // 接收系统默认属性集合的名称            String name = null;            // 标识是否找到系统默认属性集合            boolean flag = false;            // 遍历属性集合            for (PropertySource&lt;?&gt; source : propertySources) {                // 正则匹配                if (p.matcher(source.getName()).matches()) {                    // 接收名称                    name = source.getName();                    // 变更标识                    flag = true;                    break;                }            }            if (flag) {                // 找到则将自定义属性添加到该属性之前                propertySources.addBefore(name, constants);            } else {                // 没找到默认添加到第一位                propertySources.addFirst(constants);            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }}工具类  由于Spring Boot不支持静态变量的自动注入，所以需要使用一个非静态的setter方法将通过@Value注解获取到的属性信息赋值给对应静态变量  @DependsOn({"systemConfig"}) 的意思是说 Constants 依赖于 SystemConfig ，所以需要确保 SystemConfig 在 Constants 之前加载@Configuration@DependsOn({"systemConfig"})public class Constants {    // 资源服务器地址    public static String RESOURCE_SERVER_URL;    @Value("${resource.server.url}")    public void setResourceServerUrl(String resourceServerUrl) {        RESOURCE_SERVER_URL = resourceServerUrl;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot+Vue表单文件上传]]></title>
      <url>/java/springboot/vue/2017/12/31/SpringBoot+Vue%E8%A1%A8%E5%8D%95%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      <content type="text"><![CDATA[  Spring Boot + Vue 的文件上传本身没有什么难点，但如果涉及到是一个表单对象中存在文件，则会比较繁琐后端实体类  Spring Boot中对于文件的接收类型和Spring MVC保持一致，使用MultipartFile  与Spring MVC不同的是Spring Boot进行文件上传操作不需要添加配置信息，Spring Boot自身已经默认开启了文件上传功能...public class Work {  ...    @Transient    private MultipartFile referenceFile;  ...}后端接收请求的接口  SpringBoot与Vue进行集成，使用axios进行异步请求发送，对于接收对象类型的数据一般使用@RequestBody的注解将对象解析为JSON格式  但是MultipartFile类型的文件无法转换为JSON格式，所以此处需要使用@ModelAttribute的注解接收对象信息...@RestController@RequestMapping("/${contextPath}/works")public class WorkController extends SimpleController&lt;Work, WorkService&gt; {  ...    @ApiOperation("保存作业")    @PostMapping("")    public ResponseData saveRule(@ModelAttribute Work work) {  return workService.save(work);    }  ...}前端对文件数据的处理  使用默认的文件输入框进行文件上传会影响美观，所以通常将输入框隐藏后通过点击按钮进行调用  由于文件格式的input属性是只读的，所以无法使用v-model对其数据的更改进行实时获取  所以需要通过@change对其数据的更改进行监听，并赋值给表单的对应属性&lt;template&gt;  &lt;in-form ref="inForm" :form="work" :rules="rules" :is-file="true"&gt;    ...    &lt;el-button type="success" v-else @click="uploadReferenceFile"&gt;    上传答案 &lt;span v-text="work.reference"&gt;&lt;/span&gt;    &lt;input type="file" class="upload-file" ref="referenceFile" @change="setReferenceFile"&gt;    &lt;/el-button&gt;    ...  &lt;/in-form&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;...  export default {    ...    methods: {...      // 上传参考答案      uploadReferenceFile () {        this.$refs.referenceFile.click()      },      // 设置参考答案      setReferenceFile (item) {        let currentFile = item.target.files[0]        this.work.reference = currentFile.name        this.work.referenceFile = currentFile      }...  }&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt;  .upload-file    display none&lt;/style&gt;前端发起请求的方式  文件格式的数据无法通过JSON格式进行传递，所以需要使用FormData对表单数据进行转换  但FormData只能接受String和File格式的数据，对应Object格式的数据无法处理  如果涉及到Object格式的数据则需要前后端配合进行数据转换  通常情况下对象中关联的对象只涉及到其中的某一个值，所以前端在处理时可以单独将该值进行传递  后端在接收到该值后，可以在其Setter方法中将数据赋予对应的对象即可export function save ({url, data}, isFile) {  // 带文件的上传功能  if (isFile) {    let formData = new FormData()        // 遍历传入的数据    for (let key in data) {      // 获取当前值      let currentData = data[key]        // 对于空值进行过滤      if (currentData === '') {        continue      }            // 将对象中的键值对传入formData中      formData.append(key, currentData)    }        data = formData  }    return fetch({    url: url,    method: config.POST,    data  })}限制文件大小  只需要在::application.properties::中添加如下配置即可spring.http.multipart.max-file-size=10MBspring.http.multipart.max-request-size=10MB]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> vue </tag>
        
          <tag> form </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue支持JSX语法]]></title>
      <url>/vue/2017/12/18/Vue%E6%94%AF%E6%8C%81JSX%E8%AF%AD%E6%B3%95/</url>
      <content type="text"><![CDATA[  Vue中的渲染函数可以支持JSX语法，但需要进行如下配置官网渲染函数 &amp; JSX — Vue.js为项目添加依赖  首先需要引入 babel-plugin-transform-vue-jsx 插件          在::package.json::中的 devDependencies 加入如下配置      插件官网中提到的 babel-preset-env 可能已经存在，所以未指出      "babel-plugin-syntax-jsx": "^6.18.0","babel-plugin-transform-vue-jsx": "^3.5.0","babel-helper-vue-jsx-merge-props": "^2.0.3",在.babelrc中加入如下配置  transform-vue-jsx 是上述操作中导入的插件名称{  "presets": [    ["env", {      "modules": false    }],    "stage-2"  ],  "plugins": ["transform-runtime", "transform-vue-jsx"]}完成以上两点后即可按照Vue for JSX的语法进行编写，但编译器中可能会报错，需要做如下更改  将 &lt;script/&gt; 脚本类型改为 type="text/jsx"&lt;script type="text/jsx"&gt;	...&lt;/script&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> jsx </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue元素点击时获取当前对象]]></title>
      <url>/vue/2017/12/16/Vue%E5%85%83%E7%B4%A0%E7%82%B9%E5%87%BB%E6%97%B6%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1/</url>
      <content type="text"><![CDATA[  vue中在元素点击时获取当前对象需要手动传入当前对象在点击时传入当前对象  $event 表示当前被点击的对象&lt;el-menu-item v-for="submenu in menu.submenus" @click="clickSubmenu(submenu.operations, $event)"&gt;	&lt;/el-menu-item&gt;在触发的方法中通过声明参数进行接收clickSubmenu (operations, event) {  if (event &amp;&amp; hasClass(event.$el, 'is-active')) {    return false  }}]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Maven针对SpringBoot的多项目依赖配置]]></title>
      <url>/java/maven/springboot/2017/12/16/Maven%E9%92%88%E5%AF%B9Spring-Boot%E7%9A%84%E5%A4%9A%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  在Spring Boot中对于多项目依赖配置，可通过Maven实现创建一个父级的pom文件  在该pom中指定其 &lt;groupId/&gt;、&lt;artifactId/&gt; 、&lt;version/&gt;  &lt;packaging/&gt; 必须是pom  &lt;parent/&gt; 需要引入 spring-boot-starter-parent 表示继承Spring Boot的父级配置  &lt;modules/&gt; 中依次引入后续需要相互依赖的项目  &lt;dependencyManagement/&gt; 中对上述引入的项目进行完成依赖配置&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;        &lt;groupId&gt;com.innovaee.hts.parent&lt;/groupId&gt;    &lt;artifactId&gt;innovaee-hts-parent&lt;/artifactId&gt;    &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;name&gt;innovaee-hts-parent&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;1.5.8.RELEASE&lt;/version&gt;    &lt;/parent&gt;    &lt;modules&gt;        &lt;module&gt;hts-admin-backend&lt;/module&gt;  ...    &lt;/modules&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.innovaee.hts&lt;/groupId&gt;                &lt;artifactId&gt;hts-admin-backend&lt;/artifactId&gt;                &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;            &lt;/dependency&gt;  ...        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;&lt;/project&gt;在各个子项目的pom中对依赖关系进行配置  父级不再指向Spring Boot的父级，而是上述自定义父级&lt;parent&gt;    &lt;groupId&gt;com.innovaee.hts.parent&lt;/groupId&gt;    &lt;artifactId&gt;innovaee-hts-parent&lt;/artifactId&gt;    &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt;  从父级中获取需要的依赖配置&lt;dependency&gt;    &lt;groupId&gt;org.tshark.core&lt;/groupId&gt;    &lt;artifactId&gt;tshark-core&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  ...&lt;/dependency&gt;在需要被打包成jar包的项目中引入Spring Boot的编译插件&lt;build&gt;    &lt;finalName&gt;hts-admin&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;在父级pom所在的目录中执行打包命令对项目进行打包mvn clean package -Dmaven.test.skip=true]]></content>
      <categories>
        
          <category> java </category>
        
          <category> maven </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> maven </tag>
        
          <tag> springboot </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[es6为类创建多个构造函数]]></title>
      <url>/javascript/es6/2017/12/15/es6%E4%B8%BA%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      <content type="text"><![CDATA[  虽然ES6之后可以实现JavaScript创建Class，但自身并不提供函数重载，所以无法直接创建多个构造函数解决  原理则是对一个构造函数的传值进行类型判断，从而实现根据类型的不同调用不同的构造函数方法体export default class User {    constructor (obj) {    if (typeof obj === 'string') {      this._constructorSimple(obj)    } else if (typeof obj === 'object') {      this._constructorComplex(obj)    }  }    _constructorSimple (id) {    this.id = id    this.code = ''    this.name = ''    this.sex = '男'    this.age = 20    this.birthday = ''    this.address = ''    this.selectedGroup = []    this.selectedRoles = []  }    _constructorComplex (data) {    this.id = data.id    this.code = data.code    this.name = data.name    this.sex = data.sex    this.age = data.age    this.birthday = data.birthday    this.address = data.address    this.selectedGroup = data.groupIds.split(',')    this.selectedRoles = data.selectedRoles  }}]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> es6 </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> es6 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[vue-quill-editor 富文本框编辑器]]></title>
      <url>/vue/2017/12/07/vue-quill-editor-%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A1%86%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      <content type="text"><![CDATA[  基于quilljs实现的支持vue的富文本框编辑器官网  vue-quill-editor  Toolbar Module - Quill  vue-quill-image-upload图片支持上传服务器并调整大小  在 package.json 中加入 "quill-image-extend-module": "^1.1.2" 依赖  在编辑器组件中引入以下代码&lt;template&gt;  &lt;div class="in-editor-panel"&gt;    &lt;quill-editor ref="quillEditor" v-model="content" :options="editorOption" @change="onChange"&gt;    &lt;/quill-editor&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;  import 'quill/dist/quill.core.css'  import 'quill/dist/quill.snow.css'  import { quillEditor, Quill } from 'vue-quill-editor'  import { ImageExtend, QuillWatch } from 'quill-image-extend-module'  import { hasClass } from 'assets/scripts/dom/dom'  Quill.register('modules/ImageExtend', ImageExtend)  export default {    props: {      value: {        type: String,        default: ''      },      toolbarMode: {        type: Number,        default: 0      },      placeholder: {        type: String,        default: '请输入内容'      },      height: {        type: Number,        default: 170      },      imagePath: {        type: String,        default: ''      }    },    data () {      return {        content: '',        toolbars: [          [            ['bold', 'italic', 'underline', 'strike'],            ['blockquote', 'code-block'],            [{'header': 1}, {'header': 2}],            [{'list': 'ordered'}, {'list': 'bullet'}],            [{'script': 'sub'}, {'script': 'super'}],            [{'indent': '-1'}, {'indent': '+1'}],            [{'direction': 'rtl'}],            [{'size': ['small', false, 'large', 'huge']}],            [{'header': [1, 2, 3, 4, 5, 6, false]}],            [{'font': []}],            [{'color': []}, {'background': []}],            [{'align': []}],            ['clean'],            ['link', 'image', 'video']          ],          [            ['bold', 'italic', 'underline'],            ['blockquote', 'code-block'],            [{'list': 'ordered'}, {'list': 'bullet'}],            [{'header': [1, 2, 3, 4, 5, 6, false]}],            [{'color': []}, {'background': []}],            [{'align': []}],            ['link', 'image', 'video']          ],          [            ['bold', 'italic', 'underline'],            ['blockquote', 'code-block'],            [{'list': 'ordered'}, {'list': 'bullet'}],            [{'color': []}, {'background': []}],            ['insert']          ]        ],        editorOption: {          modules: {            ImageExtend: {              loading: true,              name: 'image',              size: 2,              action: `/api/file/upload/image?filePath=${JSON.stringify(this.imagePath)}`,              response: (res) =&gt; {                return res.data              }            },            toolbar: {              container: [],              handlers: {                'image': function () {                  QuillWatch.emit(this.quill.id)                }              }            }          },          placeholder: this.placeholder        }      }    },    computed: {      editor () {        return this.$refs.quillEditor.quill      }    },    watch: {      // 监听父组件传入的内容      value (newVal) {        this.$nextTick(() =&gt; {          this._listenerImage()        })        if (newVal === this.content) {          return false        }        // 传入的内容不等于编辑器自身内容，则更新        this.content = newVal      },      'content' () {        this._listenerImage()      }    },    created () {      // 指定工具栏      this.editorOption.modules.toolbar.container = this.toolbars[this.toolbarMode]    },    mounted () {      // 设置编辑器高度      this.editor.container.style.height = `${this.height}px`    },    methods: {      // 显示宽度修改框      _showWidthBox (event) {        // 获取当前图片对象        let currentImg = event.target        // 弹出宽度输入框        this.$prompt('请输入宽度', '提示', {          inputValue: currentImg.width,          confirmButtonText: '确定',          cancelButtonText: '取消'        }).then(({value}) =&gt; {          // 赋值新宽度          currentImg.width = value        }).catch(() =&gt; {})      },      // 监听图片点击      _listenerImage () {        // 获取DOM对象        let editor = document.getElementsByClassName('ql-editor')[0]        let img = editor.getElementsByTagName('img')        // 非空验证        if (img.length === 0) {          return        }        for (let i = 0; i &lt; img.length; i++) {          let currentImg = img[i]          // 绑定且防止重复绑定          currentImg.removeEventListener('dblclick', this._showWidthBox, false)          currentImg.addEventListener('dblclick', this._showWidthBox, false)        }      },      onChange () {        // 告知父组件内容发生变化        this.$emit('input', this.content)      }    },    components: {      quillEditor    }  }&lt;/script&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> editor </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[export和export default的区别]]></title>
      <url>/javascript/es6/2017/11/27/export%E5%92%8Cexport-default%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="text"><![CDATA[  export 本质上就是规定模块[js文件]的对外接口[属性或方法]export default 则是在 export 的基础上，为规定模块提供一个默认的对外接口export的使用  直接输出export let words = 'hello world!!!'export function output() {	// ...}  先定义再输出 推荐使用          需要注意的是，对于这种输出方式，不论最终 export 决定输出几个接口，都需要使用一堆大括号包裹      let firstWords = 'hello'let secondWords = 'world'let thirdWords = '!!!'function output() {	// ...}export {firstWords, secondWords, thirdWords, output}export default的使用  export default 用于规定模块的默认对外接口  很显然默认对外接口只能有一个，所以 export default 在同一个模块中只能出现一次  export default 除了不具备 export 所拥有的第二种输出方式以外，其在 import 方式上也和 export 存在一定区别          从以下两种 import 方式即可显著看出 export default 的 import 方式不需要使用大括号包裹      因为对于 export default 其输出的本来就只有一个接口，提供的是模块的默认接口，自然不需要使用大括号包裹        export的输出与import输入export function output() {	// ...}import {output} from './example'  export default的输出与import输入export default function output() {	// ...}import output from './example']]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> es6 </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> es6 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[vue-lazyload懒加载]]></title>
      <url>/vue/2017/11/24/vue-lazyload%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      <content type="text"><![CDATA[  用于vue中的懒加载插件，可实现图片懒加载等操作官网GitHub - hilongjw/vue-lazyload: A Vue.js plugin for lazyload your Image or Component in your application.]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> lazyload </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue生命周期图例]]></title>
      <url>/vue/2017/11/24/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E4%BE%8B/</url>
      <content type="text"><![CDATA[  以下是对Vue声明周期官方图例的简单解读]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue生命周期]]></title>
      <url>/vue/2017/11/24/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="text"><![CDATA[  每个Vue实例都有个完整的生命周期，也就是Vue实例从创建到销毁的整个过程，实际上在这个过程中Vue的实例经历了很多变化解读生命周期图例Vue生命周期图例每个钩子函数的触发时间  beforeCreate          在实例初始化之前被调用      数据观测和初始化事件都还没开始        created          实例已经创建完之后被调用      此处已经完成数据观测和初始化事件[数据、方法的运算，watch/event回调]        beforeMount          在对象挂载之前被调用      相关联的render函数首次被执行        mounted          new Vue() 声明中的 el 被 vm.$el 替换，并挂载到实例上之后，调用此钩子      在整个生命周期中只执行一次，即时之后实例被update        beforeUpdate          数据更新时被调用      此操作发生在虚拟DOM重新渲染和打补丁之前      可在该钩子中对状态做进一步更改，此时不会触发重新渲染，而是直接执行本次渲染        updated          虚拟DOM重新渲染和打补丁之后被调用      该钩子被调用时，组件的DOM元素已经被更新，理论上可以在此时对DOM进行操作，但不推荐在此时更改实例状态，因为可能会导致无限循环      该钩子在服务器首次渲染实例时不会被调用        beforeDestroy          实例销毁之前被调用      在此时实例依旧可以被调用        destroyed          实例销毁之后被调用      该钩子执行完毕之后会带来以下操作                  实例所指向的所有属性、方法都会解绑          所有的监听事件都会被移除          所有的子实例也会被销毁                    该钩子在服务器首次渲染实例时不会被调用      ]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[应用程序自定义快捷键]]></title>
      <url>/mac/2017/11/23/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="text"><![CDATA[  对于mac中的各种程序，都支持以下方式添加自定义快捷键进入系统偏好设置 -&gt; 键盘  在Tab列表中选择 快捷键  在功能列表中选择 应用快捷键点击底部的 + 号，按照要求为指定应用程序添加快捷键  需要注意的是 菜单标题 必须和应用程序中对应菜单标题保持一致]]></content>
      <categories>
        
          <category> mac </category>
        
      </categories>
      <tags>
        
          <tag> mac </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[var let const 的区别]]></title>
      <url>/javascript/es6/2017/11/23/var-let-const-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="text"><![CDATA[  var是ES6之前JavaScript用于定义变量的语法，而let const是ES6之后JavaScript用于定义变量的语法var存在的两个bug  JS没有块级作用域          通过var声明的变量，其作用域是函数的全部        循环内变量会过度共享          意思就是说在循环内部定义的变量，在循环外部依旧可以访问      let存在的意义  let声明的变量拥有块级作用域          let声明的变量其作用域只是外层快，而不是外层函数        let声明的全局变量不是全局对象的属性          通过let声明的全局变量无法通过window.变量名进行访问，其只存在于一个不存的作用域中        行如 for(let x in data) 的循环在每次迭代时都会为 x 创建新的绑定  let声明的变量无法重新被定义const的作用  const就是用于定义常量的]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> es6 </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> es6 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[better-scroll移动端滚动]]></title>
      <url>/vue/2017/11/23/better-scroll%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%9A%E5%8A%A8/</url>
      <content type="text"><![CDATA[  better-scroll的核心借鉴了iscroll的实现，其重点解决移动端各种滚动场景需求官网  GitHub - ustbhuangyi/better-scroll: inspired by iscroll, and it has a better scroll perfermance  Document]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> scroll </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[WebStorm空文件夹消失]]></title>
      <url>/software/webstorm/2017/11/23/WebStorm%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9%E6%B6%88%E5%A4%B1/</url>
      <content type="text"><![CDATA[  WebStorm中的项目文件夹内所有文件都删除后，该文件夹就无法显示，是因为项目根目录存在.idea文件夹，删除即可步骤  完全退出WebStorm  终端输入 ls -al  找到.idea文件夹，输入 rm -r .idea  启动WebStorm即可]]></content>
      <categories>
        
          <category> software </category>
        
          <category> webstorm </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> webstorm </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[WebStorm添加新建文件类型]]></title>
      <url>/software/webstorm/2017/11/23/WebStorm%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B/</url>
      <content type="text"><![CDATA[  WebStorm默认的New..新建文件可能不能满足自定义需求，所以需要手动添加某些文件类型步骤  输入 Command+, 进入Preferences界面，并找到Editor-File and Code Template分支  点击添加，依次输入Name和Extension保存即可]]></content>
      <categories>
        
          <category> software </category>
        
          <category> webstorm </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> webstorm </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue编写代理请求的方法改进]]></title>
      <url>/vue/webpack/2017/11/23/Vue%E7%BC%96%E5%86%99%E4%BB%A3%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95%E6%94%B9%E8%BF%9B/</url>
      <content type="text"><![CDATA[  vue升级到2.9.1后，通过其vue-cli构建的webpack项目目录结构发生以下变化发生的变化1. 在2.9.1之前，通过vue-cli构建的项目build目录如下，如左图2. 在2.9.1之后，通过vue-cli构建的项目build目录如下，如右图 ![](http://asing1elife.com/sources/images/FD738C66-A0DB-4492-959D-EB22CC7F23C4.png)  ![](http://asing1elife.com/sources/images/AD33A96F-6270-409A-94BB-C83EE75FE58D.png)3. 通过以上两张图可以明确看出新版本构建出的项目缺少了**dev-client.js**和**dev-server.js**文件造成的问题  缺少dev-server.js文件之后，所带来的问题是之前我们在需要编写代理请求时会在该文件中自定义如下路由信息，而现在应该将这些路由信息存放在哪var apiRoutes = express.Router()apiRoutes.get('/getDiscList', function (req, res) {  var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'  axios.get(url, {    headers: {      referer: 'https://c.y.qq.com/',      host: 'c.y.qq.com'    },    params: req.query  }).then((response) =&gt; {    res.json(response.data)  }).catch((e) =&gt; {    console.log(e)  })})app.use('/api', apiRoutes)解决的方式  其实在新版本中关于服务器的配置信息都被存放在webpack.dev.conf.js文件中，所以对于用来发送代理请求的自定义路由信息自然也应该存放到该文件中  只是存放的方式稍有变化，在新版本中服务器通过webpack-dev-server进行管理，所以需要在该server启动之前将代理请求接口映射完毕  webpack3内置了express() ，以下代码中的app就是express返回的对象devServer: {  ...  // 在服务器开启之前，将需要被代理的请求与本地接口进行一一对应  before (app) {    // 由于QQ音乐获取歌单列表的接口做了header信息的验证，所以需要通过代理的方式去模拟其规则范围的header，使用其允许的header发起请求    app.get('/api/getDiscList', function (req, res) {      // 真实的QQ音乐获取歌单列表的请求      const url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'      // 通过axios发送异步请求      axios.get(url, {        // 在发送请求时修改头文件，模拟合法的头文件，去欺骗服务器获取请求数据        headers: {          referer: 'https://c.y.qq.com/',          host: 'c.y.qq.com'        },        // 获取参数列表        // 由于浏览器请求参数是穿透传播的，所以当前端请求getDiscList时，传递的参数在次数可以直接获取到        params: req.query      }).then((response) =&gt; {        // res是本地方法接收本地请求的返回值        // response是访问服务器接口的返回值        // 此处只需要将从服务器获取的返回值通过json的方式传递给本地请求的返回值，即实现了一次代理转发        res.json(response.data)      }).catch((e) =&gt; {        // 捕获错误信息并输出        console.error(e)      })    })  }}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> webpack </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> webpack </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue修改项目启动端口号]]></title>
      <url>/vue/2017/11/23/Vue%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7/</url>
      <content type="text"><![CDATA[  Vue项目启动时默认端口号是8080，如果要启动多个项目就会发生冲突，通过以下方式可修改默认端口号在项目的package.json中可以找到如下代码  start属性指定的文件就是通过开发模式启动的服务文件"scripts": {  "dev": "node build/dev-server.js",  "start": "node build/dev-server.js",  "build": "node build/build.js",  "lint": "eslint --ext .js,.vue src"}在build目录下的dev-server.js中可以找到如下代码  可以发现uri在拼接port接口之前，port接口首先根据是生产还是开发，被赋予了不同的端口号  而开发环境下的端口号来自config目录var config = require('../config')...var port = process.env.PORT || config.dev.port...var uri = 'http://localhost:' + port在config目录下的index.js中可以找到如下代码  修改此处的port即可修改开发环境下启动项目的端口号dev: {	...  port: 8090,	...}]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JSONP实现]]></title>
      <url>/javascript/jsonp/2017/11/23/JSONP%E5%AE%9E%E7%8E%B0/</url>
      <content type="text"><![CDATA[  实现简单的JSONP语法网址GitHub - webmodules/jsonp: A simple JSONP implementation]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> jsonp </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> jsonp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Axios ajax异步库]]></title>
      <url>/vue/2017/11/23/Axios-ajax%E5%BC%82%E6%AD%A5%E5%BA%93/</url>
      <content type="text"><![CDATA[  axios是vue官方推荐使用的实现ajax异步的插件库官网GitHub - axios/axios: Promise based HTTP client for the browser and node.js]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> axios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[WebStorm for vue环境准备]]></title>
      <url>/vue/intellij/webstorm/2017/11/22/WebStorm-for-vue%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
      <content type="text"><![CDATA[  在WebStorm中导入项目后，vue的语法默认不能被识别，所以需要做到如下配置插件  输入 Command+, 进入Preferences界面，并找到Plugins分支  点击页面底部的Browse repositories进入到插件商店  在商店中搜索 Vue ，选中并安装  重启WebStorm语法  输入 Command+, 进入Preferences界面，并找到Languages Frameworks分支  打开分支选择第一项JavaScript  将分支页面中的JavaScript language version修改为 ECMAScript 6 即可]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> intellij </category>
        
          <category> webstorm </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> intellij </tag>
        
          <tag> webstorm </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue-CLI命令行工具]]></title>
      <url>/vue/2017/11/22/Vue-CLI%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
      <content type="text"><![CDATA[  vue-cli是Vue官网提供的一个命令行工具，可用于快速搭建大型单页应用在全局安装vue-clinpm install --global vue-cli创建一个基于webpack的新项目  执行该命令后会先下载templates  之后会依次要求输入一系列项目信息vue init webpack my-project跳转到项目根目录对项目进行安装npm install在项目根目录启动项目npm run dev]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Stylus CSS预处理框架]]></title>
      <url>/css/stylus/2017/11/22/Stylus-CSS%E9%A2%84%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6/</url>
      <content type="text"><![CDATA[  Stylus是一个CSS预处理框架，主要用于给Node项目做CSS预处理支持，可创建动态的、富有表现力的CSS，其本质上做的事与SASS/LESS相似官网  Expressive, dynamic, robust CSS — expressive, robust, feature-rich CSS preprocessor  stylus中文文档  stylus入门使用方法 - 埋名 - SegmentFault]]></content>
      <categories>
        
          <category> css </category>
        
          <category> stylus </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
          <tag> stylus </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[NPM相关操作]]></title>
      <url>/nodejs/npm/2017/11/22/NPM%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      <content type="text"><![CDATA[  NPM是Node.js的包管理模块操作安装sudo npm install -g n安装最新稳定版sudo n stable更新sudo npm install npm@latest -g清除缓存npm cache verify]]></content>
      <categories>
        
          <category> nodejs </category>
        
          <category> npm </category>
        
      </categories>
      <tags>
        
          <tag> nodejs </tag>
        
          <tag> npm </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 集成 Animate.css]]></title>
      <url>/vue/2017/11/21/Vue-%E9%9B%86%E6%88%90-Animate.css/</url>
      <content type="text"><![CDATA[  通过CSS实现了很多动画效果，可以直接调用官网Animate.css实现方式  下载 animate.css 文件并在项目的 main.js 中引入import Vue from 'vue'...import 'assets/plugins/animate/animate.css'.../* eslint-disable no-new */new Vue({  el: '#app',  render: h =&gt; h(App),  store,  router})结合 transition 组件一起使用  duration 可控制动画的加载速度&lt;transition leave-active-class="animated fadeOutRight" enter-active-class="animated fadeInRight" :duration="300"&gt;  &lt;mt-field class="search-input" placeholder="请输入搜索内容" v-show="search" v-model="searchContent"&gt;&lt;/mt-field&gt;&lt;/transition&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> transition </tag>
        
          <tag> animate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Velocity.js动画库]]></title>
      <url>/javascript/animate/2017/11/21/Velocity.js%E5%8A%A8%E7%94%BB%E5%BA%93/</url>
      <content type="text"><![CDATA[  通过JS实现了很多动画效果，可以直接调用官网Velocity.js 中文文档]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> animate </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> animate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Tween.js 动画库]]></title>
      <url>/javascript/animate/2017/11/21/Tween.js-%E5%8A%A8%E7%94%BB%E5%BA%93/</url>
      <content type="text"><![CDATA[  TweenJS是一个简单的JS动画库官网Tween]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> animate </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> animate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Circles 圆形进度条]]></title>
      <url>/javascript/charts/2017/11/19/Circles-%E5%9C%86%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
      <content type="text"><![CDATA[  生成一个圆形的进度条官网Create circular SVG charts with Circles : Lugo Labs]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> charts </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> charts </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Sublime插件推荐]]></title>
      <url>/software/sublime/2017/11/18/Sublime%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      <content type="text"><![CDATA[  列举一些比较好用的Sublime插件插件介绍  BracketHighlighter          成对的标签或符号给予高亮显示        Emmet          HTML/CSS语法提示        SideBarEnhancements          侧边栏右键增强        Sass          支持Sass        Less          支持Less        SublimeCodeIntel          代码自动补全        All Autocomplete          自动扫描项目全部文件，用于提高自动补全范围        jQuery          支持jQuery        DocBlockr          使用Enter或Tab进行快速注释        AutoFileName          自动提示文件路径        Vue Syntax Highlight          Vue语法高亮      ]]></content>
      <categories>
        
          <category> software </category>
        
          <category> sublime </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> sublime </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Lodash 扩展js通用方法]]></title>
      <url>/2017/11/18/Lodash-%E6%89%A9%E5%B1%95JS%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="text"><![CDATA[Lodash 扩展JS通用方法#javascript/plugin  Lodash是一个著名的javascript原生库，不需要引入其他第三方依赖。是一个意在提高开发者效率,提高JS原生方法性能的JS库官网  Lodash Documentation  lodash 中文文档语法集合[Collection]  _.find  在集合中获取到指定元素var users = [  { 'user': 'barney',  'age': 36, 'active': true },  { 'user': 'fred',    'age': 40, 'active': false },  { 'user': 'pebbles', 'age': 1,  'active': true }] // 自定义匹配规则_.find(users, function(o) { return o.age &lt; 40; })  _.filter 获取集合中满足条件的元素集var users = [  { 'user': 'barney', 'age': 36, 'active': true },  { 'user': 'fred',   'age': 40, 'active': false }] // =&gt; { 'user': 'fred',   'age': 40, 'active': false }_.filter(users, function(o) { return !o.active; })数组[Array]  _.findIndex 在数组中获取指定元素的索引          匹配的规则可自定义      匹配到则返回对应索引，否则返回-1      let fileType = currentFile.typelet currentIndex = _.findIndex(this.types, function (type) {	return fileType.toLowerCase().match(new RegExp(type))})  _.unionWith 连接两个数组          连接的规则可自定义      规则返回true的则跳过      this.examPaper.examQuestions = _.unionWith(this.examPaper.examQuestions, this.selectQuestions, (a, b) =&gt; {  return a.hexId === b.hexId})  _.drop 移除数组元素          默认移除第一个元素      可显式指定从第几个元素开始移除      _.drop(this.userWorkIds)]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[NPM修改镜像地址]]></title>
      <url>/nodejs/npm/2017/11/17/NPM%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E5%9C%B0%E5%9D%80/</url>
      <content type="text"><![CDATA[  由于NPM的镜像地址默认在境外，在国内使用会出现下载速度较慢的问题，所以需要修改镜像地址为国内的服务器镜像地址  官方          registry https://registry.npmjs.org/        淘宝          搜索 http://npm.taobao.org/      registry http://registry.npm.taobao.org/        NPMJS          搜索 http://cnpmjs.org/      registry http://r.cnpmjs.org/      步骤npm config set registry https://registry.npm.taobao.org// 配置后可通过下面方式来验证是否成功npm config get registry// 或npm info expressCNPMnpm install cnpm -g --registry=https://registry.npm.taobao.org]]></content>
      <categories>
        
          <category> nodejs </category>
        
          <category> npm </category>
        
      </categories>
      <tags>
        
          <tag> nodejs </tag>
        
          <tag> npm </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC配置i18n]]></title>
      <url>/java/springmvc/i18n/2017/11/14/SpringMVC%E9%85%8D%E7%BD%AEi18n/</url>
      <content type="text"><![CDATA[  i18n是internationalization首字母i和末尾字母n以及中间18个字母的简称，意于国际化在/src/main/resources下新建messages文件夹  新增以下文件          message.properties用于默认资源      message_zh_CN.properties用于中文资源      message_en_US.properties用于英文资源      spring-config.xml添加配置信息&lt;!-- 配置i18n资源文件 --&gt;&lt;bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;  &lt;!-- 资源文件路径 --&gt;  &lt;property name="basename" value="classpath:messages/message"/&gt;  &lt;!-- 默认编码 --&gt;  &lt;property name="defaultEncoding" value="UTF-8"/&gt;  &lt;!-- 指定默认资源文件 --&gt;  &lt;property name="useCodeAsDefaultMessage" value="true"/&gt;&lt;/bean&gt;spring-mvc.xml添加配置信息&lt;!-- 将Locale信息存放于Session中 --&gt;&lt;!-- id必须是localeResolver，否则会报cannot change HTTP Head ... --&gt;&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.SessionLocaleResolver"/&gt;&lt;!-- 配置拦截器获取Locale信息 --&gt;&lt;mvc:interceptors&gt;  &lt;bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/&gt;&lt;/mvc:interceptors&gt;IndexControler.java中的添加获取Locale信息方法public class IndexController {    @Autowired  private MessageSource messageSource;  @RequestMapping("")  public String main(Model model, HttpServletRequest request, HttpServletResponse response) {    // 设置语言格式    setLanguage(model, request, response, Locale.getDefault());        return "/index";  }    @RequestMapping("/{language}")  public String main(Model model, HttpServletRequest request, HttpServletResponse response, @PathVariable String language) {    // 分割参数    String[] languages = language.split("_");        // 设置系统语言    setLanguage(model, request, response, new Locale(languages[0], languages[1]));        return "/index";  }    /**   * 设定语言格式   */  private void setLanguage(Model model, HttpServletRequest request, HttpServletResponse response, Locale locale) {    // 获取LocaleResolver    LocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(request);        // 设置Locale信息    localeResolver.setLocale(request, response, locale);        // 传递正确的Locale信息到页面    model.addAttribute("encoding", messageSource.getMessage("encoding", new Object[0], locale));  }  }页面中添加spring的tag用于使用message.properties中的标签信息&lt;%@ taglib uri="http://www.springframework.org/tags" prefix="spring" %&gt;页面上使用spring标签获取标签信息&lt;spring:message code="title" /&gt;首页提供一个下拉框用于手动切换语言&lt;div class="form select-langugae-panel"&gt;  &lt;div class="form-group"&gt;    &lt;select class="select-content select-content-btn"&gt;      &lt;option value="zh_CN" &lt;c:if test="${encoding eq 'zh_CN' }"&gt;selected&lt;/c:if&gt;&gt;中文&lt;/option&gt;      &lt;option value="en_US" &lt;c:if test="${encoding eq 'en_US' }"&gt;selected&lt;/c:if&gt;&gt;English&lt;/option&gt;    &lt;/select&gt; &lt;i class="select-arrow"&gt;&lt;/i&gt;  &lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> i18n </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> i18n </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC+MyBatis项目搭建]]></title>
      <url>/java/springmvc/mybatis/2017/11/12/SpringMVC+MyBatis%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      <content type="text"><![CDATA[  SpringMVC作为一个敏捷开发的常用框架，和MyBatis进行集成需要如下步骤构建项目  创建一个Maven Project，并添加web.xml  在pom.xml中引入以下依赖包  为保证项目编译的JDK版本统一，需要加入以下配置&lt;build&gt;  &lt;plugins&gt;    &lt;plugin&gt;      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;      &lt;configuration&gt;        &lt;source&gt;1.8&lt;/source&gt;        &lt;target&gt;1.8&lt;/target&gt;      &lt;/configuration&gt;    &lt;/plugin&gt;  &lt;/plugins&gt;&lt;/build&gt;添加Spring依赖包&lt;!-- Spring核心包 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-core&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring IoC --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring包扫描 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring数据库连接 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring事务管理器 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring Web --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring WebMVC --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;添加MyBatis依赖包&lt;!-- MyBatis核心包 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.2.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- MyBatis Spring依赖包 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;  &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;添加数据库依赖包&lt;!-- MySQL连接 --&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;5.1.18&lt;/version&gt;&lt;/dependency&gt;&lt;!-- c3p0 --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.mchange&lt;/groupId&gt;  &lt;artifactId&gt;c3p0&lt;/artifactId&gt;  &lt;version&gt;0.9.5.1&lt;/version&gt;&lt;/dependency&gt;添加视图层依赖包&lt;!-- 视图层的核心包 --&gt;&lt;dependency&gt;  &lt;groupId&gt;taglibs&lt;/groupId&gt;  &lt;artifactId&gt;standard&lt;/artifactId&gt;  &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- JSTL --&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;jstl&lt;/artifactId&gt;  &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Servlet容器 --&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;  &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;在web.xml中添加配置  配置 DispatcherServlet&lt;!-- 配置DispatcherServlet --&gt;&lt;servlet&gt;  &lt;servlet-name&gt;asl-ums-dispatcher&lt;/servlet-name&gt;  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  &lt;!-- 加载Spring配置文件 --&gt;  &lt;init-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;!-- 项目启动时加载文件 --&gt;  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;  映射路径规则```xml  asl-ums-dispatcher  /## 创建**spring-mvc.xml**并添加配置```xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc"xsi:schemaLocation="                http://www.springframework.org/schema/beans                http://www.springframework.org/schema/beans/spring-beans.xsd                http://www.springframework.org/schema/mvc                http://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/context                http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 自动注入 --&gt;&lt;!-- 用于提供数据绑定、数字@NumberFormat和日期格式化@DateTimeFormat以及xml和json的默认读写支持 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 配置静态资源 --&gt;&lt;!-- 加入对js/gif/png等静态资源的处理 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 指定默认路径 --&gt;&lt;mvc:view-controller path="/" view-name="redirect:/index"/&gt;&lt;!-- 配置JSP显示 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;  &lt;property name="prefix" value="/WEB-INF/views"/&gt;  &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt;&lt;!-- 扫描指定路径下的类 --&gt;&lt;context:component-scan base-package="online.shixun.asl.module"&gt;  &lt;!-- 扫描带有@Controller注解的类 --&gt;  &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;  &lt;!-- 扫描带有@Service注解的类 --&gt;  &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;创建spring-config.xml并添加配置&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;!-- 指定数据库文件 --&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;&lt;!-- 配置c3p0连接池 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;  &lt;!-- 数据库连接信息 --&gt;  &lt;property name="driverClass" value="${driver}"/&gt;  &lt;property name="jdbcUrl" value="${url}"/&gt;  &lt;property name="user" value="${username}"/&gt;  &lt;property name="password" value="${password}"/&gt;  &lt;!-- 最大连接数 --&gt;  &lt;property name="maxPoolSize" value="30"/&gt;  &lt;!-- 最小连接数 --&gt;  &lt;property name="minPoolSize" value="10"/&gt;  &lt;!-- 获取连接的超时时间，毫秒 --&gt;  &lt;property name="checkoutTimeout" value="5000"/&gt;  &lt;!-- 连接失败后的重连次数 --&gt;  &lt;property name="acquireRetryAttempts" value="1"/&gt;&lt;/bean&gt;&lt;!-- 配置事务管理器，MyBatis采用jdbc的事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;  &lt;!-- 指定数据源 --&gt;  &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;!-- 配置声明式事务 --&gt;&lt;tx:annotation-driven/&gt;&lt;!-- 配置SqlSessionFactory --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;  &lt;!-- 指定数据源 --&gt;  &lt;property name="dataSource" ref="dataSource"/&gt;  &lt;!-- 指定MyBatis全局配置文件 --&gt;  &lt;property name="configLocation" value="classpath:spring-mybatis.xml"/&gt;  &lt;!-- 指定实体类扫描路径 --&gt;  &lt;property name="typeAliasesPackage" value="online.shixun.asl.dto"/&gt;  &lt;!-- 指定映射文件的扫描路径 --&gt;  &lt;property name="mapperLocations" value="classpath:mapper/*Mapper.xml"/&gt;&lt;/bean&gt;&lt;!-- 将Dao注入Spring容器中 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;  &lt;!-- 指定扫描路径 --&gt;  &lt;property name="basePackage" value="online.shixun.asl.module"/&gt;  &lt;!-- 扫描带有@MyBatisRepository --&gt;  &lt;property name="annotationClass" value="online.shixun.asl.core.MyBatisRepository"/&gt;&lt;/bean&gt;&lt;/beans&gt;创建spring-mybatis.xml并添加配置&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;!-- 配置全局属性 --&gt;    &lt;settings&gt;        &lt;!-- 使用数据库自增主键 --&gt;        &lt;setting name="useGeneratedKeys" value="true"/&gt;        &lt;!-- 显示SQL语句 --&gt;        &lt;setting name="logImpl" value="STDOUT_LOGGING"/&gt;    &lt;/settings&gt;&lt;/configuration&gt;项目配置完毕后，想要启动项目，则需要在Mapper映射路径下至少存在一个mapper.xml]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis二级缓存]]></title>
      <url>/java/mybatis/2017/11/12/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      <content type="text"><![CDATA[  MyBatis的二级缓存可以通过极少的配置项实现对数据库查询数据的缓存规则  映射文件中所有的 &lt;select/&gt; 语句都会被缓存  映射文件中所有的 &lt;insert/&gt; &lt;update/&gt; &lt;delete/&gt; 语句都会刷新缓存  基于以上两点，需要被缓存的数据库表的所有操作都应该放在同一个Mapper文件中在MyBatis的配置文件中添加以下配置  实际上即时不在配置文件中显式的声明该配置项，MyBatis的二级缓存也是默认开启的，因为该配置项的默认值就是true          &lt;setting name="cacheEnabled" value="true" /&gt;        在需要进行缓存的Mapper文件中添加以下配置          &lt;cache eviction="FIFO" flushInterval="60000" size="512" readOnly="true" /&gt;      可选配置  eviction 回收策略          LRU [default] 移除最长时间不被使用的对象      FIFO 按对象进入缓存的顺序进行移除      SOFT 移除基于垃圾回收器状态和软引用规则的对象      WEAK 更积极的移除基于垃圾回收器状态和弱引用规则的对象        flushInterval 刷新间隔，毫秒          没有默认值，表明没有刷新间隔，缓存只有在调用刷新语句时刷新        size 引用数目          1024 [default] 存储列表集合和对象的1024个引用        readOnly  只读          false [default] 可读写的缓存会返回缓存对象的拷贝，性能稍差，但安全性更高      true 只读的缓存会给所有调用者返回缓存对象的相同实例，所以该对象无法被修改，性能更高      可选属性  useCache 让单个 &lt;select/&gt; 语句自行选择是否被缓存  flushCache 让单个 &lt;select/&gt; 语句自行选择是否被刷新缓存]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
          <tag> cache </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Air-datepicker 日期选择器]]></title>
      <url>/jquery/2017/10/17/Air-datepicker-%E6%97%A5%E6%9C%9F%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      <content type="text"><![CDATA[  air-datepicker 是一款基于 jQuery 的简易日期选择器官网Air Datepicker引用  引入插件所需 css/js 文件&lt;link rel="stylesheet" type="text/css" href="plugins/air-datepicker/css/datepicker.min.css"&gt;&lt;script type="text/javascript" src="plugins/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="plugins/air-datepicker/js/datepicker.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="plugins/air-datepicker/js/i18n/datepicker.zh.js"&gt;&lt;/script&gt;  定义一个 input 用户展现内容          data-language="zh" 表示插件使用中文      &lt;input type="text" class="datepicker-input" data-language="zh"&gt;  调用插件初始化方法$(function() {    $(".datepicker-input").datepicker();});API  classes 自定义 className  inline 是否一直可见          false [default]        language 指定 i18n 国际化语言          ru [default]      可如上述在 input 中指定 data-language="zh"      也可以在插件初始化方法中通过 language: zh 指定        startDate 初始化显示日期          new Date() [default]        firstDay 每周的开始时间          0-6 表示星期天到星期六      没有默认值，若不指定则根据引入的 i18n 规则决定，例如引入 zh ，则第一天为周一，引入 en ，则第一天为周日        weekends 指定一组日期为周末          [6, 0] [default]        dateFormat 日期格式          没有默认值，若不指定则根据引入的 i18n 规则决定        keyboardNav  是否允许键盘操作          true [default]        position 日期选择器相对于输入框的显示位置          bottom left [default]        offset 位置偏移值          12 [default]        view 默认视图          days [default]      可选 days months years        minView 最小视图          days [default]      可选 days months years        minDate 可被选择的最小日期          minDate: new Date() 表示今天之前的日期都不可被选中        maxDate 可被选择的最大日期  disableNavWhenOutOfRange 可选范围之外的日期是否禁止查看          true [default]        multipleDates 是否可选择多个日期          false [default]        multipleDatesSeparator 自定义多个日期之间的分隔符          , [default]        range 允许选择日期范围          false [default]      无法与 multipleDates 同时使用        todayButton 是否显示[今天]按钮          false [default]      点击按钮不会直接选择当前日期，只会跳转到当前日期所在的视图页        clearButton 是否显示[清除]按钮          false [default]        autoClose 选择日期后，自动关闭面板          false [default]        timepicker 是否开启时间选择器          false [default]        timeFormat 时间格式          没有默认值，若不指定则根据引入的 i18n 规则决定        minHours 小时数最小值          0 [default]      可选范围 0-23        maxHours 小时数最大值          23 [default]      可选范围 0-23        minMinutes 分钟数最小值          0 [default]      可选范围 0-59        maxMinutes 分钟数最大值          59 [default]      可选范围 0-59        hoursStep 小时的滑动间隔          1 [default]        minutesStep 分钟的滑动间隔          1 [default]      ]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
          <tag> datepciker </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Flex 布局实现子项的完全居中]]></title>
      <url>/css/flex/2017/10/16/Flex-%E5%B8%83%E5%B1%80%E5%AE%9E%E7%8E%B0%E5%AD%90%E9%A1%B9%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B1%85%E4%B8%AD/</url>
      <content type="text"><![CDATA[  利用 Flex 布局的灵活性可以非常简洁的实现子元素相对于父元素的完全居中父容器指定宽高，并指定为 Flex 布局  为父容器添加 justify-content: center; 表示子元素位于主轴水平居中  为父容器添加 align-items: center; 表示子元素位于交叉轴垂直居中#container {    width: 500px;    height: 700px;    display: flex;    margin: 0 auto;    justify-content: center;    align-items: center;    background-color: red;}子元素指定宽高即可#container .top-content {    width: 200px;    height: 200px;    background-color: green;}]]></content>
      <categories>
        
          <category> css </category>
        
          <category> flex </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
          <tag> flex </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Flex 布局 - 项目]]></title>
      <url>/css/flex/2017/10/16/Flex-%E5%B8%83%E5%B1%80-%E9%A1%B9%E7%9B%AE/</url>
      <content type="text"><![CDATA[  Flex 布局中用于控制子元素的一些属性容器部分  前续关于 Flex 容器的详解参见 Flex 布局 - 容器属性order 定义项目的排列顺序  默认为 0  数值越小，排列越靠前flex-grow 定义项目的放大比例  默认为 0 ，如果存在剩余空间，也不会放大  数值越大，放大的优先级越高  如果所有的项目都是 flex-grow: 1 ，则等分剩余空间  如果一个项目是 flex-grow: 4 ，其他项目是 flex-grow: 1 ，则前者分配到的剩余空间比其他项多四倍flex-shrink 定义项目的缩小比例  默认为 1 ，如果空间不足，则项目缩小  如果所有项目都是 flex-shrink: 1 ，当空间不足时，所有项目等比例缩小  如果一个项目是 flex-shrink: 0 ，其他项目是 flex-shrink: 1 ，当空间不足时，前者也不会缩小flex-basis 定义在分配多余空间之前，项目占据的主轴大小  默认值为 auto ，即项目本来大小  可根据主轴方向设置为与 width 或 height 相同大小，项目则会占据固定空间flex 是 flex-grow 和 flex-shrink 以及 flex-basis 的简写  默认值是 0 1 auto  flex: auto 表示 1 1 auto  flex: none 表示 0 0 autoalign-self 允许单个项目与其他项目使用不一样的对齐方式  默认值是 auto ，表示继承父容器的 align-items 属性值  可覆盖定义在父容器中的 align-items]]></content>
      <categories>
        
          <category> css </category>
        
          <category> flex </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
          <tag> flex </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Flex 布局 - 容器]]></title>
      <url>/css/flex/2017/10/16/Flex-%E5%B8%83%E5%B1%80-%E5%AE%B9%E5%99%A8/</url>
      <content type="text"><![CDATA[  Flex 是 Flexible Box 的缩写，就是弹性布局，可以为盒子模型提供更大的灵活性任何一个容器都可以指定为 Flex 布局，其将会成为未来布局的首选方案概念  采用 Flex 布局的元素称为 Flex 容器  容器下的所有子元素自动成为容器成员，成为 Flex 项目  将元素的 display: flex 即可指定 Flex 容器  容器默认存在两根轴，水平的主轴和垂直的交叉轴 属性flex-direction 决定主轴的方向，即项目的排列方向  row [default]  主轴在水平方向，起点在左侧  row-reverse 主轴在水平方向，起点在右侧  column 主轴在垂直方向，起点在顶部  column-reverse 主轴在垂直方向，起点在底部flex-wrap 当一条轴线上无法排列所有子项，规定换行规则  nowrap [default] 不换行  wrap 换行，第一行在上方  wrap-reverse 换行，第一行在下方flex-flow 是 flex-direction 和 flex-wrap 的简写形式  row wrap [default]justify-content 定义项目在容器主轴上的对齐方式  flex-start [default] 左对齐  flex-end 右对齐  center 居中  space-between 两端对齐，每个项目之间的间距相等  space-around 每个项目两侧的间隔相等，即项目之间的间隔比项目与容器边框的间隔大一倍align-items 定义项目在容器交叉轴上的对齐方式  stretch [default] 如何项目未设置高度，则每个项目默认占据整个容器高度  flex-start 顶部  flex-end 底部  center 居中  baseline 项目第一行文字的基线对齐align-content 定义多条轴线的对齐方式，若容器只有一条轴线或容器没有多余空间，则不起作用  stretch [default] 项目占满整个交叉轴  flex-start 与交叉轴的顶部对齐  flex-end 与交叉轴的底部对齐  center 与交叉轴的中部对齐  space-between 与交叉轴的两端对齐，轴线之间的间隔平均分布  space-around 每条轴线两端的间隔相等，即轴线之间的间隔比轴线与边框的间隔要大一倍]]></content>
      <categories>
        
          <category> css </category>
        
          <category> flex </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
          <tag> flex </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[font-face 详解]]></title>
      <url>/css/2017/10/12/font-face-%E8%AF%A6%E8%A7%A3/</url>
      <content type="text"><![CDATA[  @font-face 是 CSS3 的一个模块，其主要作用是可将自定义字体嵌入到网页中，让网页字体的运用不只是限定在 Web 安全字体中语法  webFontName: 引入的自定义字体名称，将会为指定的元素添加 font-family: webFontName  source: 字体路径  format: 字体格式，用于帮助浏览器识别，truetype opentype truetype-aat embedded-opentype svg …  weight: 字体是否粗体  style: 字体样式@font-face {	font-family: &lt;webFontName&gt;;	src: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*;	[font-weight: &lt;weight&gt;];	[font-style: &lt;style&gt;];}格式  truetype - ttf          Windows 和 Mac 最常见字体      RAW 格式，不为任何网站优化      IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile Safari4.2+        opentype - otf          原始字体格式，内置在 truetype 基础之上      提供更多功能      Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile Safari4.2+        web-open-font-format - woff          Web 字体最佳格式      是一个开放的 truetype、opentype 压缩版本      支持元数据包的分离      IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+        embedded-opentype - eot          IE 专用字体      可以从 truetype 创建此格式      IE4+        svg - svg          基于 svg 渲染      Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+      @font-face {	font-family: 'webFontName';	src: url('webFontName.eot'); /* IE9 Compat Modes */	src: url('webFontName.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */       url('webFontName.woff') format('woff'), /* Modern Browsers */		 url('webFontName.ttf') format('truetype'), /* Safari, Android, iOS */		 url('webFontName.svg#webFontName') format('svg'); /* Legacy iOS */}使用  获取自定义字体的原始文件，可前往 DaFont 下载  在 Font Squirrel 将字体转换为兼容各浏览器的 Web 字体  按上述兼容性语法指定 @font-face 中的字体  在指定元素中调用该自定义字体]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
          <tag> font </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Struts2 项目搭建]]></title>
      <url>/java/struts/2017/09/21/Struts2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      <content type="text"><![CDATA[  Struts2 作为一个应用开发框架，在项目中引入需要如下步骤创建一个 Web Project 并添加默认的 web.xml 文件  这个好像没啥好说的引入以下 jar 包到 lib 目录中  commons-fileupload-1.3.3.jar  commons-lang3-3.6.jar  freemarker-2.3.23.jar  javassist-3.20.0-GA.jar  log4j-api-2.8.2.jar  ognl-3.1.12.jar  struts2-core-2.5.12.jar在 web.xml 中添加 filter 配置&lt;filter&gt;	&lt;filter-name&gt;struts2&lt;/filter-name&gt;	&lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;	&lt;filter-name&gt;struts2&lt;/filter-name&gt;	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;在 src 目录下添加 struts.xml 文件  要让 Struts2 支持异步的 json 数据访问在 &lt;package&gt; 的 extend 属性中添加 json-default  添加 struts2-json-plugin-2.5.12.jar 包  在对应的 &lt;action&gt;  请求的 &lt;result&gt; 中添加 type="json" 属性，并删除页面内容&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"        "http://struts.apache.org/dtds/struts-2.5.dtd"&gt;&lt;struts&gt;	&lt;package name="default-package" extends="struts-default, json-default"&gt;		&lt;!-- name 表示请求路径 --&gt;		&lt;!-- class 表示请求路径对应的处理类 --&gt;		&lt;!-- method 表示处理类中对应的方法 --&gt;		&lt;action name="category" class="online.shixun.hpeu.action.GoodsCategoryAction" method="list"&gt;			&lt;result name="success"&gt;/WEB-INF/views/category.jsp&lt;/result&gt;		&lt;/action&gt;				&lt;!-- 异步获取商品描述 --&gt;		&lt;action name="description" class="online.shixun.hpeu.action.GoodsAction" method="description"&gt;			&lt;result name="success" type="json"&gt;&lt;/result&gt;		&lt;/action&gt;	&lt;/package&gt;&lt;/struts&gt;接收/显示数据  Struts2 的特点在于对数据的接收/显示进行封装  要获取页面传递到 action 的参数，只需要在 action 中定义对应名称的私有属性，并提供 setter 方法即可  要将数据显示到页面中，只需要在 action 中定义对应名称的私有属性，并提供 getter 方法即可public class GoodsAction {		private GoodsServiceImpl goodsService = new GoodsServiceImpl();		// 从页面接收商品类别id	private Long categoryId;		// 从页面接收商品id	private Long goodsId;		// 从DB获取商品列表，用于展示到页面上	private List&lt;GoodsModel&gt; goods;		// 从DB获取商品描述信息，用于展示到页面上	private String description;		/**	 * 加载商品列表页	 * @return	 */	public String list() {		goods = goodsService.getGoodsByCategoryId(categoryId);				return "success";	}		/**	 * 获取商品描述信息	 * @return	 */	public String description() {		// 通过商品id获取商品描述信息		description = goodsService.getGoodsById(goodsId).getDescription();				return "success";	}	public void setCategoryId(Long categoryId) {		this.categoryId = categoryId;	}	public void setGoodsId(Long goodsId) {		this.goodsId = goodsId;	}	public String getDescription() {		return description;	}	public List&lt;GoodsModel&gt; getGoods() {		return goods;	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> struts </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> struts </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate项目搭建]]></title>
      <url>/java/hibernate/2017/09/21/Hibernate%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      <content type="text"><![CDATA[  Hibernate 作为一个全自动的持久层[ORM]框架，在项目中引入需要以下步骤基础步骤  进入 Hibernate官网 下载 Hibernate 源码包  解压源码包后进入下图中的目录，将目录中的所有 jar 包复制到项目的 lib 目录中  在项目 src 目录下新建 hibernate.cfg.xml 文件          若实体类使用注解，则需要在最后加入对实体类的映射      若实体类使用配置文件，则需要在最后引入对应配置文件      &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN"  "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt;  &lt;!-- 数据库配置信息 --&gt;  &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;  &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///asl_dev&lt;/property&gt;  &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt;  &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt;  &lt;!-- Hibernate 方言 --&gt;  &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;  &lt;!-- 是否显示 sql --&gt;  &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt;  &lt;!-- 是否格式化 sql --&gt;  &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;    &lt;!-- 注解实体类映射 --&gt;  &lt;mapping class="online.shixun.hpeu.model.GoodsModel"/&gt;  &lt;!-- 配置实体类映射 --&gt;  &lt;mapping resource="com/qingshixun/model/User.hbm.xml"/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt;制作 Hibernate 工具类  通过该工具类可以便捷的重复调用 Session 对象  但如果涉及到 CUD 操作，则需要另外开启事务，并管理事务的提交或回滚public class HibernateUtil {    private static SessionFactory sessionFactory;    static {        Configuration configuration = new Configuration().configure();        StandardServiceRegistryBuilder ssrb = new StandardServiceRegistryBuilder();        StandardServiceRegistry serviceRegistry = ssrb.applySettings(configuration.getProperties()).build();        sessionFactory = configuration.buildSessionFactory(serviceRegistry);    }    public static Session getSession() {        return sessionFactory.openSession();    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Shell 字符串]]></title>
      <url>/shell/2017/09/16/Shell-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="text"><![CDATA[  列举一些 Shell 脚本常用的字符串操作语法拼接  在双引号中通过 $ 可直接引入一个变量  如果引入变量之后紧接着存在内容，可以将引入变量放在双引号之外，与其他语言不同，不需要加号拼接  第三种语义最清晰，通过一组 {} 将引入变量与其他内容分隔开name=TomnewName="newName is $name"newNmae="newName is"$name"!"newName="newName is ${name}!"长度  引入变量时，在变量名前加一个 # 号可实现变量内容长度的输出name=Tomecho ${#Tom}截取  ${string:position}  表示从字符串指定索引开始截取  ${string:position:length} 表示从字符串指定索引开始截取指定长度的内容name="Hello World"echo ${name:2}echo ${name:2:5}]]></content>
      <categories>
        
          <category> shell </category>
        
      </categories>
      <tags>
        
          <tag> shell </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring事务隔离级别]]></title>
      <url>/java/springmvc/springboot/2017/09/14/Spring%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      <content type="text"><![CDATA[  Spring 事务隔离级别是指 Spring 如何去处理每个事务之间的关联，可用于防止一些数据错误隔离级别  TransactionDefinition.ISOLATION_DEFAULT [默认值]          表示使用底层数据库的默认隔离级别，通常为 TransactionDefinition.ISOLATION_READ_COMMITTED      数据库的隔离级别参见 MySQL 数据库隔离级别        TransactionDefinition.ISOLATION_READ_UNCOMMITTED          表示一个事务可以读取到另一个事务修改但还未提交的数据      无法防止脏读、不可重复读、幻读      不推荐使用        TransactionDefinition.ISOLATION_READ_COMMITTED          表示一个事务只能读取到另一个事务已经提交的数据      可防止脏读      推荐使用        TransactionDefinition.ISOLATION_REPEATABLE_READ          表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同      可防止脏读、不可重复读        TransactionDefinition.ISOLATION_SERIALIZABLE          表示所有事务一次逐个执行，事务之间完全不可能产生干扰      可防止脏读、不可重复读、幻读      过于严密的隔离级别会严重影响系统性能      不推荐使用      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> springboot </tag>
        
          <tag> spring </tag>
        
          <tag> transaction </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring事务传播行为]]></title>
      <url>/java/springmvc/springboot/2017/09/14/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/</url>
      <content type="text"><![CDATA[  Spring 事务的传播行为是指当存在多个事务同时存在的时候，Spring 应该如何处理这些这些事务传播行为  TransactionDefinition.PROPAGATION_REQUIRED [默认值]          如果当前存在事务，则加入该事务      如果当前不存在事务，则创建一个新的事务        TransactionDefinition.PROPAGATION_REQUIRES_NEW          创建一个新的事务      如果当前存在事务，则将当前事务挂起        TransactionDefinition.PROPAGATION_SUPPORTS          如果当前存在事务，则加入该事务      如果当前没有事务，则以非事务的方式继续执行        TransactionDefinition.PROPAGATION_NOT_SUPPORTED          以非事务方式运行      如果当前存在事务，则将当前事务挂起        TransactionDefinition.PROPAGATION_NEVER          以非事务方式运行      如果当前存在事务，则抛出异常        TransactionDefinition.PROPAGATION_MANDATORY          如果当前存在事务，则加入该事务      如果当前没有事务，则抛出异常        TransactionDefinition.PROPAGATION_NESTED          如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行      如果当前没有事务，则根据 TransactionDefinition.PROPAGATION_REQUIRED 决定      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> springboot </tag>
        
          <tag> spring </tag>
        
          <tag> transaction </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Shell 脚本入门]]></title>
      <url>/shell/2017/09/14/Shell-%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/</url>
      <content type="text"><![CDATA[  Shell 是一种编程语言，与其他语言一样，其也有很多语言结构区别  Shell 作为一种编程语言，有很多具体类别，例如：sh / bash / csh / zsh  日常所说的 Shell 更像是一种应用程序， 用于解释执行编写出来的 Shell 脚本入门  #! 是 Shell 脚本的约定标记，用于指明该脚本应该被什么解释器执行  echo 命令用于在屏幕上输出一句话#! /bin/shecho "hello shell !"运行直接调用解释器，将脚本作为参数参数  图示中是直接使用 bash 解释器来执行 hello.sh 脚本使用 source 或 . 执行脚本  使用该方法执行脚本时，不会创建子进程，而是直接在父进程中执行]]></content>
      <categories>
        
          <category> shell </category>
        
      </categories>
      <tags>
        
          <tag> shell </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Shell 变量]]></title>
      <url>/shell/2017/09/14/Shell-%E5%8F%98%E9%87%8F/</url>
      <content type="text"><![CDATA[  和所有编程语言一样，Shell 中也有变量的概念特点  只有字符串这一种类型  变量名和变量值 ~没有长度限制~  只要变量的内容为数字，则允许比较和整数[加减乘除]操作定义  = 号两侧不能有空格，否则视为语法错误variableName=value  当 value 中存在空格时，需要使用双引号将内容包裹住variableName="value have space"类型  局部变量          变量名之前加 local 修饰符      代码块或函数范围内可见        全局变量          变量名之前不加任何修饰符      在全局范围内可见      使用  要使用定义好的变量，只需要在变量名前加一个 $ 符号  变量名两侧增加 {} 只是为了识别变量边界，非必选  # 号用于表示单行注释，Shell 脚本中不存在多行注释name=Tomecho $nameecho ${name} #变量名可以被一对大括号包裹  被双引号包裹的变量名可以被识别，被单引号包裹的变量无法被识别]]></content>
      <categories>
        
          <category> shell </category>
        
      </categories>
      <tags>
        
          <tag> shell </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL数据库隔离级别]]></title>
      <url>/database/mysql/2017/09/14/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      <content type="text"><![CDATA[  数据库隔离级别用于处理数据库中的数据读写规则定义  脏读          事务 A 对数据进行了增删改，但未提交事务，事务 B 可读取到该数据      如果事务 A 进行回滚，则事务 B 读取到的数据是脏数据        不可重复读          事务 A 中发生了两次读操作      在第一次读操作和第二次读操作之间，事务 B 对该数据进行了修改      导致事务 A 两次读取的数据是不一致的        幻读          事务 A 对一定范围内的数据进行了修改      事务 B 在这个范围内新增了一条数据      这时事务 A 对这些数据进行的修改会丢失      隔离级别  Read-Uncommitted - Level 0          导致脏读        Read-Committed - Level 1          避免脏读      允许不可重复读和幻读        Repeatable-Read - Level 2          避免脏读      避免不可重复读和幻读        Serializable - Level 3          串行化读，事务只能依次执行      避免脏读      避免不可重复读和幻读      执行效率慢，慎重使用      总结  隔离级别越高，越能保证数据安全，但对并发性能的影响越大  Oracle 、SqlServer 的默认隔离级别是 Read-Committed  MySQL 的默认隔离级别是 Repeatable-Read]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL 插入查询数据]]></title>
      <url>/database/mysql/2017/09/14/MySQL-%E6%8F%92%E5%85%A5%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE/</url>
      <content type="text"><![CDATA[  以下语法可将查询结果直接插入指定表语法INSERT INTO pt_project (	name,	teachingDate,	teachingNo,	description)SELECT	pr.name,	pr.teachingDate,	pr.teachingNo,	pr.descriptionFROM	pt_project prWHERE	pr.course_id = '8';]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript 修改 input 验证提示]]></title>
      <url>/javascript/2017/08/21/Javascript-%E4%BF%AE%E6%94%B9-input-%E9%AA%8C%E8%AF%81%E6%8F%90%E7%A4%BA/</url>
      <content type="text"><![CDATA[  HTML5 为 form 中的 input 提供了一系列的验证提示，通过 Javascript 可以对验证提示的内容进行自定义定义一个 input 标签，并添加 required 属性&lt;input type="text" name="username" required&gt;定义一个方法，使用 setCustomValidity() 方法添加自定义的验证提示内容&lt;script type="text/javascript"&gt;function checkInput(input) {    if (input.value.length &lt; 20) {        input.setCustomValidity("输入内容不得少于20个字符");    } else {        input.setCustomValidity("");    }}&lt;/script&gt;在 input 标签中添加 invalid 属性，指定调用前续方法，并传入当前输入框&lt;input type="text" name="username" oninvalid="checkInput(this)" required&gt;]]></content>
      <categories>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery 防止子元素响应父元素的点击事件]]></title>
      <url>/jquery/2017/08/20/jQuery-%E9%98%B2%E6%AD%A2%E5%AD%90%E5%85%83%E7%B4%A0%E5%93%8D%E5%BA%94%E7%88%B6%E5%85%83%E7%B4%A0%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</url>
      <content type="text"><![CDATA[  当父元素绑定了一个 click  事件后，点击其中子元素默认也会相应该事件，如下方式可避免子元素响应父元素的点击事件实现方式$(".overlay").click(function(e){  if (e.target == e.currentTarget) {		// content ...	}});]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
          <tag> dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript 为 String 提供分离字符的全局方法]]></title>
      <url>/javascript/2017/08/20/Javascript-%E4%B8%BA-String-%E6%8F%90%E4%BE%9B%E5%88%86%E7%A6%BB%E5%AD%97%E7%AC%A6%E7%9A%84%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95/</url>
      <content type="text"><![CDATA[  在一个字符串的每个字符之间插入空格，并且这个方法可以直接被字符串调用实现方式String.prototype.spacify = function(){    return this.split("").join(" ");};]]></content>
      <categories>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Redis 持久化机制]]></title>
      <url>/database/redis/2017/08/19/Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
      <content type="text"><![CDATA[  对于如何将数据类型持久化存储，Redis 提供一下 4 种方式定时快照 snapshot实现  在 Redis 内存的一个定时器事件，每隔一段时间就检查数据是否符合定时快照触发的条件  若触发则创建一个子进程，默认与父进程共享地址空间，再通过子进程遍历整个内存进行存储操作缺陷  只能存储一段时间内的内存信息，若系统重启则会丢失上次快照与重启间的数据基于语句的追加文件 aof实现  每条使 Redis 内存数据发生改变的的命令都会被存储到一个 log 文件中  最终该 log 文件中存放的就是 Redis 的持久化数据缺陷  过多的 log 文件导致数据体积过大，当系统重启后再次加载数据时会比较慢          数据加载慢并不是因为读取速度慢，而是因为 log 中的每条命令都会需要在 Redis 中再次执行        由于每条命令都要写入 log ，所以会导致 Redis 的性能下降虚拟内存 vm - 已弃用实现  用户空间数据换入换出缺陷  代码复杂  重启慢Diskstore实现  弃用虚拟内存后采用的新方式，实际上是使用传统的 B-tree 格式存储数据总结  采用合适的数据类型存储数据，并尽可能使用紧凑存储参数  当业务场景无需持久化时，关闭所有的持久化机制可获得更好的性能及最大的内存使用量  不要让 Redis 使用的物理内存超过服务器的 3/5]]></content>
      <categories>
        
          <category> database </category>
        
          <category> redis </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> redis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Redis 内存优化方式]]></title>
      <url>/database/redis/2017/08/19/Redis-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/</url>
      <content type="text"><![CDATA[  Redis 内存优化是对数据类型做一些参数上的优化内存优化方式与参数  关闭 Redis 的虚拟内存[VM]功能，即 redis.conf 中 vm-enabled = no  设置 redis.conf 中 maxmemory ，用于告知 Redis 当使用了多少物理内存后拒绝继续写入的请求，可防止 Redis 性能降低甚至崩溃  可为指定的数据类型设置内存使用规则，从而提高对应数据类型的内存使用效率          Hash 在 redis.conf 中有以下两个属性，任意一个超出设定值，则会使用 HashMap 存值                  hash-max-zipmap-entires 64 表示当 value 中的 map 数量在 64 个以下时，实际使用 zipmap 存储值          hash-max-zipmap-value 512 表示当 value 中的 map 每个成员值长度小于 512 字节时，实际使用 zipmap 存储值                    List 在 redis.conf 中也有以下两个属性                  list-max-ziplist-entires 64          list-max-ziplist-value 512                      在 Redis 的源代码中有一行宏定义 REDIS-SHARED-INTEGERS = 10000 ，修改该值可以改变 Redis 存储数值类型的内存开销]]></content>
      <categories>
        
          <category> database </category>
        
          <category> redis </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> redis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS 实现图片宽度自适应]]></title>
      <url>/css/2017/08/19/CSS-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%AE%BD%E5%BA%A6%E8%87%AA%E9%80%82%E5%BA%94/</url>
      <content type="text"><![CDATA[  由于浏览器的大小可变，导致放置图片的容器也会随之变化，要让图片和容器大小一起变化，则需要实现图片宽度自适应编写 HTML  用父容器包裹图片，当浏览器的大小发生变化时，首先影响到父容器，而不是图片&lt;div class="img-wrap"&gt;    &lt;img src="FullSizeRender 3.jpg"&gt;&lt;/div&gt;&lt;div class="img-wrap"&gt;    &lt;img src="logo-ccnu.png"&gt;&lt;/div&gt;&lt;div class="img-wrap"&gt;    &lt;img src="thumbfma.png"&gt;&lt;/div&gt;编写 CSS 样式  指定父容器的展现方式是 inline-block ，则可以让父容器的宽度随内容变化而变化  指定图片的宽度为 100% ，则可以让图片的宽度随父容器宽度变化而变化，而且图片的宽高比使用不变&lt;style type="text/css"&gt;    .img-wrap {        display: inline-block;    }    .img-wrap img {    	width: 100%;    	vertical-align: middle;    }&lt;/style&gt;]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[HTML5+CSS3 为 input 标签编写验证提示]]></title>
      <url>/css/2017/08/17/HTML5+CSS3-%E4%B8%BA-input-%E6%A0%87%E7%AD%BE%E7%BC%96%E5%86%99%E9%AA%8C%E8%AF%81%E6%8F%90%E7%A4%BA/</url>
      <content type="text"><![CDATA[  通过 HTML5 + CSS3 可以实现 input 中有无内容的友好提示方式定义 input 标签并在后面跟上 span 标签  input 标签中必须指定 required 属性&lt;input type="number" name="age" min="0" required&gt;&lt;span class="inputTip"&gt;&lt;/span&gt;为 input 标签编写动态 css 样式  当 input 中没有内容时其对应的伪类标签为 invalid  当 input 中存在内容时其对应的伪类标签为 valid&lt;style type="text/css"&gt;	input:invalid+span::after {		content: "✖";		padding-left: 10px;	}	input:valid+span::after {		content: "✓";		padding-left: 10px;	}&lt;/style&gt;]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
          <tag> input </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery slice() 获取指定索引范围内的元素]]></title>
      <url>/jquery/2017/08/14/jQuery-slice()-%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E5%85%83%E7%B4%A0/</url>
      <content type="text"><![CDATA[  slice(start [, end]) 获取指定索引范围内的元素准备一些测试数据&lt;ul&gt;  &lt;li&gt;list item 1&lt;/li&gt;  &lt;li&gt;list item 2&lt;/li&gt;  &lt;li&gt;list item 3&lt;/li&gt;  &lt;li&gt;list item 4&lt;/li&gt;  &lt;li&gt;list item 5&lt;/li&gt;&lt;/ul&gt;将索引为 2 之后的 li 背景色改为红色$("li").slice(2).css("background-color", "red");将索引为 2 之后 4 之前，且不包含 4 的 li 背景色改为红色$("li").slice(2, 4).css("background-color", "red");]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Redis 数据类型]]></title>
      <url>/database/redis/2017/08/11/Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="text"><![CDATA[  Redis 核心对象是 RedisObject ，下图简单概括了 RedisObject 中的组成部分数据模型图数据类型String  常用命令为 set / get / decr / incr / mget  最常用的数据类型，普通的 key-value 存储都会被归为此类  在 Redis 内存存储默认是一个字符串，被 redisObject 引用  当遇到 decr / incr 操作时会转成数值型进行计算（前提是可以计算），此时 redisObject 中的 encoding 为 intHash  常用命令为 hget / hset / hgetall  用于存储复杂的对象数据，实现方式为 key-hash[field-value] ，其对应的 value 实际上是一个 HashMap  当数据较少时，Redis 并不会采用真正意义上的 HashMap 存储 value ，其在 redisObject 中对应的 encoding 实际上是 zipmap ，类似一维数组  当数据较多时，才会使用 HashMap ，其在 redisObject 中对应的 encoding 是 htList  常用命令为 lpush / rpush / lpop / rpop / lrange  最重要的数据类型之一，用于存放列表数据  与 Hash 类似，当数据较少时使用 ziplist 存值，反之则使用 List  Redis 中的 List 是一个双向链表，可支持反响查找和遍历  Redis 内部很多实现，例如发送缓冲队列用的就是该数据结构Set  常用命令为 sadd / spop / smembers / sunion  与 List 类似同样用于存放列表数据，但其优势在于快速去重  可判断某个对象是否存在与 Set 中  实际上是一个 value 用于为 null 的 HashMap ，通过计算 hash 来实现快速去重，以及判断对象是否存在也是依赖于此Sorted Set  常用命令为 zadd / zrange / zrem / zcard  相较于 Set ，Sorted Set 的优势在于自动排序，可实现一个有序且不重复的列表  其可以额外的优先级[Score]参数为成员排序  内部使用 HashMap 和 SkipList（跳跃表）来保证数据的存储去重和有序  HashMap 中存放成员到 score 的映射，SkipList 中存放所有成员，排序依据是 HashMap 中存放的 score]]></content>
      <categories>
        
          <category> database </category>
        
          <category> redis </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> redis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS box-shadow 详解]]></title>
      <url>/css/2017/08/04/CSS-box-shadow-%E8%AF%A6%E8%A7%A3/</url>
      <content type="text"><![CDATA[  box-shadow 是 CSS3 的语法特性，可以实现为元素添加阴影语法/* x轴偏移 y轴偏移 模糊半径 大小 颜色 位置 */box-shadow: offsetX offsetY blur spread color position;解析offsetX : x轴偏移  取正值向右偏移，负值向左偏移  box-shadow: 20px 0 10px 0 lightblue;  box-shadow: -20px 0 10px 0 lightblue;offsetY : y轴偏移  取正值向右偏移，负值向左偏移  box-shadow: 0 20px 10px 0 lightblue;  box-shadow: 0 -20px 10px 0 lightblue;blur : 模糊半径  取正值，值越大，阴影越模糊  取值为 0 则完全不模糊  取负值无效，按 0 处理  模糊的表现形式是向四周扩散，但四个边角最淡，想要模糊效果比较均匀，可将元素设置为圆形spread : 阴影大小  取正值，值越大，阴影越大  取负值，阴影大小的计算方式是元素宽高减去 spread 值，然后 blur 设置的模糊阴影会向内靠拢color : 阴影颜色position : 位置  默认阴影向外延展，取值 inset 会将阴影改为向内延展扩展box-shadow 和 background 一样支持设置多值box-shadow: 0 0px 10px 10px lightblue,			  0 0px 10px 10px lightblue inset;物体倒影&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;box-shadow&lt;/title&gt;    &lt;style type="text/css"&gt;    #shadowContainer {        width: 200px;        height: 200px;        background-color: red;        margin: 200px auto;        position: relative;        transition: transform 1s;        border-radius: 50%;        animation: circleUp 1s 2s both infinite alternate;    }    #shadowContainer::after {        content: "";        position: absolute;        bottom: -50px;        border-radius: 50%;        width: 100%;        height: 10px;        background-color: rgba(255, 67, 66, 1.000);        transition: transform 1s;        box-shadow: 0 0 20px 1px rgba(255, 67, 66, 0.5);        animation: circleShadowUp 1s 2s both infinite alternate;    }    @keyframes circleUp {    	0% {			transform: translateY(0);    	}    	100% {			transform: translateY(-40px);    	}    }    @keyframes circleShadowUp {    	0% {			transform: translateY(0) scale(1);    	}    	100% {			transform: translateY(40px) scale(0.75);    	}    }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id="shadowContainer"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
          <tag> shadow </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mac 快捷键]]></title>
      <url>/mac/2017/07/10/Mac-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="text"><![CDATA[  mac 的一些快捷键罗列，持续更新截图  3 种截图方式中加入 Control 可以让截图直接存入剪贴板          Command + Shift + 3 截取整个屏幕      Command + Shift + 4 截取选择区域      Command + Shift + 4 + BackSpace 截取指定窗口      浏览器  Command + L 跳转到地址栏  Control + Tab 标签页切换功能键  Control + Command + Space 呼出 emoji 窗口  Command + Alt + . 显示隐藏文件]]></content>
      <categories>
        
          <category> mac </category>
        
      </categories>
      <tags>
        
          <tag> mac </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL 查询重复记录]]></title>
      <url>/database/mysql/2017/06/19/MySQL-%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E8%AE%B0%E5%BD%95/</url>
      <content type="text"><![CDATA[  数据库中如果插入重复记录，需要有效排查出重复结果方法SELECT 	* FROM 	pt_university_institute_staffWHERE 	staffId IN (		SELECT 			co.staffId 		FROM (			SELECT 				staffId, count(*) AS count 			FROM 				pt_university_institute_staff 			GROUP BY 				staffId 			HAVING 				count &gt; 1		) co	);]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL 命令大全]]></title>
      <url>/database/mysql/2017/06/19/MySQL-%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      <content type="text"><![CDATA[  MySQL 一些常见命令查看版本号mysql -V重启/启动/停止mysql.server restart/start/stopbrew services restart/start/stop mysql连接远程数据库mysql -h 192.168.7.11 -u root -p [databaseName]连接本机数据库mysql -u root -p [databaseName]查看数据库列表show databases;创建数据库create database [databaseName];删除数据库drop database [databaseName];选择数据库use [databaseName];查看数据库表列表show tables;查看表结构describe [tableName];]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery 禁用右键菜单、复制功能]]></title>
      <url>/jquery/2017/06/18/jQuery-%E7%A6%81%E7%94%A8%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95-%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD/</url>
      <content type="text"><![CDATA[  通过jquery禁止浏览器右键功能菜单实现$(window).on({    // 禁用右键菜单    "contextmenu": function () {        return false;    },    // 禁用复制    "keydown": function (e) {        // win : ctrl+c        // mac : cmd+c        if ((e.ctrlKey || e.metaKey) &amp;&amp; e.keyCode === 67) {            return false;        }    }});码表  字母          A - 65      B - 66      C - 67      D - 68      E - 69      F - 70      G - 71      H - 72      I - 73      J - 74      K - 75      L - 76      M - 77      N - 78      O - 79      P - 80      Q - 81      R - 82      S - 83      T - 84      U - 85      V - 86      W - 87      X - 88      Y - 89      Z - 90        数字          0 - 48      1 - 49      2 - 50      3 - 51      4 - 52      5 - 53      6 - 54      7 - 55      8 - 56      9 - 57        小键盘          0 - 96      1 - 97      2 - 98      3 - 99      4 - 100      5 - 101      6 - 102      7 - 103      8 - 104      9 - 105      * - 106      + - 107      回 - 108      - - 109      . - 110      / - 111        功能键          F1 - 112      F2 - 113      F3 - 114      F4 - 115      F5 - 116      F6 - 117      F7 - 118      F8 - 119      F9 - 120      F10 - 121      F11	- 122      F12 - 123        扩展建          BackSpace - 8      Tab - 9      Enter - 13      Shift - 16      Ctrl - 17      Alt - 18      Caps Lock - 20      Esc - 27      ]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
          <tag> keycode </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux stat]]></title>
      <url>/linux/2017/06/15/Linux-stat/</url>
      <content type="text"><![CDATA[  stat-查看文件/目录信息查看文件/目录完整信息state ./course]]></content>
      <categories>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux rmdir]]></title>
      <url>/linux/2017/06/15/Linux-rmdir/</url>
      <content type="text"><![CDATA[  rmdir-删除目录 只能删除非空目录删除目录rmdir test递归删除目录  若子目录删除后导致父目录为空，则会一并删除父目录rmdir -p test/test1]]></content>
      <categories>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux rm]]></title>
      <url>/linux/2017/06/15/Linux-rm/</url>
      <content type="text"><![CDATA[  rm-删除文件或目录删除文件rm test.log强制删除文件，不会提示是否删除rm -f test.log逐个删除文件，并提示是否删除rm -i *.log删除目录rm -r test强制删除目录，不会提示是否删除rm -rf test]]></content>
      <categories>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux pwd]]></title>
      <url>/linux/2017/06/15/Linux-pwd/</url>
      <content type="text"><![CDATA[  pwd-显示当前完整目录显示当前目录pwd]]></content>
      <categories>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux mv]]></title>
      <url>/linux/2017/06/15/Linux-mv/</url>
      <content type="text"><![CDATA[  mv-移动文件\目录或更改文件\目录名称移动文件并更改文件名称mv test.log ./test1/test1.log移动多个文件mv a.log b.log ./test1/更改文件名称  若存在同名文件，则询问是否覆盖mv -i a.log b.log强制更改文件名称  若存在同名文件，直接覆盖mv -f a.log b.log移动文件夹  若test3不存在，则将test2名称改为test3，否则将test2移动到test3中mv test2 test3移动当前目录下所有文件到上级目录mv * ../]]></content>
      <categories>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux mkdir]]></title>
      <url>/linux/2017/06/15/Linux-mkdir/</url>
      <content type="text"><![CDATA[  mkdir-创建目录创建目录mkdir test同时创建多个目录mkdir -p test/test1创建指定权限的目录mkdir -m 777 test创建目录并显示创建信息mkdir -v test]]></content>
      <categories>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux ls]]></title>
      <url>/linux/2017/06/15/Linux-ls/</url>
      <content type="text"><![CDATA[  ls-查看目录详细信息列表ls -l包括隐藏文件ls -a包括所有子目录ls -r每行只列出一个文件，相当于竖向排列ls -1]]></content>
      <categories>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux cd]]></title>
      <url>/linux/2017/06/15/Linux-cd/</url>
      <content type="text"><![CDATA[  cd-目录跳转系统根目录cd /返回上级目录cd ..当前用户主目录cd  或  cd ~跳转指定目录cd ~/Document/innovaee/project返回进入此目录之前所在的目录cd -用上一个命令作为参数使用cd !$]]></content>
      <categories>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux alias]]></title>
      <url>/linux/2017/06/15/Linux-alias/</url>
      <content type="text"><![CDATA[  alias用于给命令添加一个简洁的别名添加永久性别名  输入 vi ~/.bashrc  在文件中添加需要的命令别名，例如 alias ll='ls -l' 并保存  输入 source ~/.bashrc 执行文件  将 source ~/.bashrc 写入 vi ~/.bash_profile 文件中并保存，可确保重启后命令依旧生效]]></content>
      <categories>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript数组排序]]></title>
      <url>/javascript/array/2017/06/08/Javascript%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
      <content type="text"><![CDATA[  Javascript 提供 sort() 函数用于排序但默认情况是使用字符串 Unicode 码点排序问题// 得到的结果是 [1, 10, 2, 5][1, 5, 2, 10].sort();解决[1, 5, 2, 10].sort((a, b) =&gt; a - b);]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> array </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> array </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery 手动触发 select 值改变]]></title>
      <url>/jquery/2017/05/31/jQuery-%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91-select-%E5%80%BC%E6%94%B9%E5%8F%98/</url>
      <content type="text"><![CDATA[  select 的 option 默认没有 click 事件，所以无法直接通过 jquery 控制 select 下某个 option 被选中为 select 定义 change 事件$myTrainingSelect.change(function () {	console.log("option change")})为需要被选中的 option 赋值 selected$myTrainingSelect.find("option[value='1'][data-type='open']").prop("selected", true);手动触发 select 的 change 事件$myTrainingSelect.trigger("change");]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Redis 安装与配置]]></title>
      <url>/database/redis/2017/05/31/Redis-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  Redis 是一种 NoSQL 数据库安装  通过 Homebrew套件管理器 可以快速安装 Redisbrew install redis配置  Redis 的配置文件路径是 /usr/local/etc/redis.conf  在该配置文件中找到 requirepass 后删除前面的注释，并修改密码即可为 Redis 设置密码，需要重启  可以通过 Homebrew  插件自启动 设置 Redis 的开机自启动注意  在 Redis 终端通过 set requirepass xxx 可以快速设置密码，不需要重启  但如果配置文件 redis.conf 中没有该属性的话，客户端像服务端发送 AUTH 请求会被拒绝  并返回 ERR Client sent AUTH, but no password is set  解决该问题需要在配置文件中设置密码命令  redis-cli -h 10.24.234.0 -p 6379 -a i_redis          连接远程服务器      -h 服务器 IP 地址      -p 端口号      -a 密码      ]]></content>
      <categories>
        
          <category> database </category>
        
          <category> redis </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> redis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Homebrew  插件自启动]]></title>
      <url>/software/homebrew/2017/05/31/Homebrew-%E6%8F%92%E4%BB%B6%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
      <content type="text"><![CDATA[  通过 brew install xxx 安装的插件可以通过以下方式设置自启动安装插件brew install redis将插件的自启动脚本通过软链接的方式映射到系统的自启动目录下sudo ln -f /usr/local/Cellar/redis/3.2.9/homebrew.mxcl.redis.plist /Library/LaunchAgents/加载启动脚本launchctl load /Library/LaunchAgents/homebrew.mxcl.redis.plist停止启动脚本launchctl unload /Library/LaunchAgents/homebrew.mxcl.redis.plist]]></content>
      <categories>
        
          <category> software </category>
        
          <category> homebrew </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> homebrew </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Swiper 轮播查看器]]></title>
      <url>/jquery/2017/05/22/Swiper-%E8%BD%AE%E6%92%AD%E6%9F%A5%E7%9C%8B%E5%99%A8/</url>
      <content type="text"><![CDATA[  Swiper 可以实现类似于相册图片查看的功能官网  Swiper  Swiper-中文APISwiper-API引入插件所需 css/js 文件&lt;link href="path/to/swiper.min.css" rel="stylesheet"&gt;&lt;script src="path/to/swiper.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script src="path/to/jquery.js" type="text/javascript"&gt;&lt;/script&gt;编写插件所需的基本布局  swiper-pagination 、swiper-button-prev 、swiper-button-next 、swiper-scrollbar 都是可选的&lt;div class="swiper-container"&gt;    &lt;!-- 轮播内容容器 --&gt;    &lt;div class="swiper-wrapper"&gt;        &lt;!-- 轮播内容 --&gt;        &lt;div class="swiper-slide"&gt;Slide 1&lt;/div&gt;        &lt;div class="swiper-slide"&gt;Slide 2&lt;/div&gt;        &lt;div class="swiper-slide"&gt;Slide 3&lt;/div&gt;        ...    &lt;/div&gt;    &lt;!-- 分页点 --&gt;    &lt;div class="swiper-pagination"&gt;&lt;/div&gt;        &lt;!-- 切换按钮 --&gt;    &lt;div class="swiper-button-prev"&gt;&lt;/div&gt;    &lt;div class="swiper-button-next"&gt;&lt;/div&gt;        &lt;!-- 滚动条 --&gt;    &lt;div class="swiper-scrollbar"&gt;&lt;/div&gt;&lt;/div&gt;调用初始化方法var itemSwiper = f7.swiper(".swiper-container", {    speed: 400,    spaceBetween: 100,    prevButton: $recruitContentPanel.find(".prev-btn"),    nextButton: $recruitContentPanel.find(".next-btn")});]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL GROUP BY 报错]]></title>
      <url>/database/mysql/2017/05/22/MySQL-GROUP-BY-%E6%8A%A5%E9%94%99/</url>
      <content type="text"><![CDATA[  使用 GROUP BY 时抛出 only_full_group_by 异常问题  通过 GROUP BY 查询时抛出下列异常Expression #2 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'xxx' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by解决  设置全局 sql_modeSET GLOBAL sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';  查询设置结果 SELECT @@GLOBAL.sql_mode;  在可视化工具中通过 SET GLOBAL sql_mode 设置的结果只在会话中生效，数据库重启后则失效  想要设置 sql_mode 全局生效则需要在 mysql 的 my.cnf 文件中填写 sql_mode  通过 homebrew 安装 mysql 后，在 /etc 目录下默认没有创建 my.cnf 文件，需要自行创建 cp /usr/local/opt/mysql/support-files/my-default.cnf /etc/my.cnf  进入到 _etc_my.cnf 文件中，在最后输入 sql_mode  重启 mysql]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL 随机获取数据]]></title>
      <url>/database/mysql/2017/05/20/MySQL-%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE/</url>
      <content type="text"><![CDATA[  想要将数据库中取出的数据随机排序，需要用到 MySQL 的 RAND() 函数RAND() 函数会在 0-1 之间随机生成一个数字在多条数据中随机获取一条SELECT 	*FROM	pt_skill_test_itemORDER BY RAND()LIMIT 1;随机获取多条数据SELECT 	*FROM	pt_skill_test_itemORDER BY RAND();]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL 分页优化]]></title>
      <url>/database/mysql/2017/05/15/MySQL-%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96/</url>
      <content type="text"><![CDATA[  MySQL 可以通过以下方式优化分页效率问题  MySQL 分页查询多行会导致查询出很多无用数据后再进行筛选，效率低下  例如 limit 1000, 10 会排序出前 1010 行数据，然后取最后 10 行解决  子查询先利用覆盖索引查询到满足条件的主键数据，再利用主键回表查找对应记录SELECT	co.name,	co.pointFROM	pt_course coINNER JOIN (	SELECT		id	FROM		pt_course 	LIMIT 1000, 10) cooON co.id = coo.id;]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[DateTimePicker 日期时间选择器]]></title>
      <url>/jquery/2017/05/15/DateTimePicker-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      <content type="text"><![CDATA[  Bootstrap 官网的有 DatePicker 和 TimePicker ，但不支持共用所以有网友结合二者开发出 DateTimePicker 插件，可以一直从年份选择到具体时间官网DateTimePicker该插件依赖于 Bootstrap 的样式，所以需要先引入其 css 文件&lt;link href="${ctx }/assets/plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet" type="text/css"&gt;再引入插件自身 css/js 文件&lt;link href="${ctx }/assets/plugins/bootstrap-datetimepicker/css/bootstrap-datetimepicker.css" rel="stylesheet" type="text/css"/&gt;&lt;script src="${ctx }/assets/plugins/bootstrap-datetimepicker/js/bootstrap-datetimepicker.js" type="text/javascript"&gt;&lt;/script&gt;如果需要用到国际化，则需要引入对应语言包&lt;script src="${ctx }/assets/plugins/bootstrap-datetimepicker/js/locales/bootstrap-datetimepicker.zh-CN.js" type="text/javascript"&gt;&lt;/script&gt;定义一个 input 用于展现内容&lt;input type="text" class="form-control date-time-picker" name="beginTime" readonly&gt;调用插件初始化方法$(".date-time-picker").datetimepicker({    format: "yyyy-mm-dd hh:ii",    language: "zh-CN",    weekStart: 1,    autoclose: true,    todayBtn: true,    todayHighlight: true});API  format : mm_dd_yyyy          日期时间显示的格式      关于分钟的格式符为 ii ，而不是 mm ，错写成 mm 将导致无法选择到正确的分钟数        weekStart : 0          每周的开始时间      规则是 0-6 对应周日到周六        autoclose : false          日期选择关闭后自动关闭选择面板        startView : 2 / month          默认显示的视图      支持写入数字或对应字符串      0 - hour / 1 - day / 2 - month / 3 - year / 4 - decade        minView : 0 / hour          能提供的最精确时间      规则与 startView 相同        maxView : 4 / decade          能提供的最大时间      规则与 startView 相同        todayBtn : false          显示“今天”按钮在面板最下方      为 true 则只是将日期跳转到当前日期      为 linked 则会直接选中当前日期        todayHighlight : false          高亮当前日期        keyboardNavigation : true          支持方向键改变日期        language : en          国际化支持      更改属性后还需要在插件的 locales 目录下引入对应国际化 js 文件      ]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
          <tag> datepicker </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL 表引擎的区别和选择]]></title>
      <url>/database/mysql/2017/05/13/MySQL-%E8%A1%A8%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E9%80%89%E6%8B%A9/</url>
      <content type="text"><![CDATA[  MySQL 的表引擎分为InnoDB和MyIsamInnoDB  支持事务和外键  采用聚簇索引  数据读取时采用行级锁，粒度更小，并发更强  读写之间可并发操作，读取时不需要加锁，根据隔离级别的不同，读取时遇到锁会读取快照  运行时会为数据建立哈希索引，但只存在于内存中，停库则丢失，重启后需要重新建立  行级锁定 [row-level]MyIsam  对数据和索引进行分开存储  索引缓存在内存中，存储的是数据的磁盘地址  数据读取时采用表级锁，无法实现读写并发，只支持读读并发  数据写入优先级高于读取优先级，因此大量的写入操作会导致表的死锁  支持 B-Tree 、R-Tree 、Full-text 索引  表级锁定 [table-level]总结  通常情况下使用InnoDB做为表引擎，因为其支持事务和外键，以及读写并发  对于读取量很大，基本没有写入操作的表，使用MyIsam做为表引擎，可加快表的读取速度]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Raty 打星评分]]></title>
      <url>/jquery/2017/05/12/Raty-%E6%89%93%E6%98%9F%E8%AF%84%E5%88%86/</url>
      <content type="text"><![CDATA[  raty 可以通过很简单的方式实现打星评分功能官网jQuery Raty - A Star Rating Plugin引入插件所需 css/js 文件&lt;link href="${ctx }/assets/plugins/jquery-raty/jquery.raty.css" rel="stylesheet" type="text/css"&gt;&lt;script src="${ctx }/assets/plugins/jquery-raty/jquery.raty.js" type="text/javascript"&gt;&lt;/script&gt;定义一个 div 用于展现内容&lt;div class="course-grade-panel" data-name="totalGrade" data-score="3"&gt;&lt;/div&gt;调用插件初始化方法$courseSummaryPanel.find(".course-grade-panel").raty({	  // 指定需要显示的图片路径    path: g_rootPath + "/assets/plugins/jquery-raty/images/",	  // 定义记录评分的 input[name]    scoreName: function () {        return $(this).data("name");    },	  // 评分赋初值	  // 如果 halfShow = true ，赋值支持小数点	  // score &lt;= x.25 则忽略小数点	  // x.26 &lt;= score &lt;= x.75 则计为半颗星	  // score &gt;= x.76 则计为一颗星    score: function () {        return $(this).data("score");    },	  // 只读    readOnly: function () {        if ($(this).data("score") &gt; 0) {            return true;        }    },	  // 设定星星的数量	  number: 10,	  // 如果设置为只读模式，将鼠标放到星星上则会显示以下文字	  noRateMsg: "现在不能评分！",	  // 禁止显示半颗星	  halfShow: false,	  // 更改 halfShow 的四舍五入规则	  round: {		down: .26,		full: .6,		up: .76	  }	  // 禁止打半颗星	  half: false});]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS 内嵌阴影]]></title>
      <url>/css/2017/05/12/CSS-%E5%86%85%E5%B5%8C%E9%98%B4%E5%BD%B1/</url>
      <content type="text"><![CDATA[  通过给 box-shadow 增加 inset 属性，可以实现内嵌阴影效果效果来源CSS box-shadow 详解语法box-shadow: 0 1px 5px 2px rgba(20%, 20%, 40%, 0.5) inset;解析  水平位移距离，必选  垂直位移距离，必选  模糊强度，不能为负  扩散强度，不能为负  阴影颜色  内阴影]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
          <tag> shadow </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Noty 页面通知]]></title>
      <url>/jquery/2017/05/08/Noty-%E9%A1%B5%E9%9D%A2%E9%80%9A%E7%9F%A5/</url>
      <content type="text"><![CDATA[  noty 可以在页面上多个位置弹出通知提示文本官网NOTY - a dependency-free notification library引入插件所需 css/js 文件  noty v3 并不依赖于 jQuery ，noty v2 需要依赖 jQuery&lt;link href="${ctx }/assets/plugins/noty/css/noty.css" rel="stylesheet" type="text/css"&gt;&lt;script type="text/javascript" src="${ctx }/assets/plugins/noty/js/noty.min.js"&gt;&lt;/script&gt;调用插件初始化方法new Noty({    type: "success",    layout: "topRight",    theme: "sunset",    text: "Hello World！！！",    timeout: 3000,    progressBar: true,    closeWidth: ["button"],    animation: {        open: 'noty_effects_open',        close: 'noty_effects_close'    },    id: false,    force: false,    killer: false,    queue: "global",    container: false,    modal: false,	  callbacks: {		afterClose: function () { ... }	  }}).show();API  type : alert          消息类型      alert_success_error_warning_info        layout : topRight          显示位置      顶部：top_topLeft_topCenter/topRight      中部：center_centerLeft_centerRight      底部：bottom_bottomLeft_bottomCenter/bottomRight        theme : mint          主题样式      relax_mint_metroui_sunset_bootstrap-v3/bootstrap-v4/semanticui/nest        text : “”          显示文本        timeout : false          超时时间，默认 false 表示不超时      可填写具体毫秒数，即表示超时时间为多少毫秒        progressBar : true          是否显示进度条      只有 timeout 不为 false 时，progressBar 才有效        closeWith : [‘click’]          关闭方式      选择 click 后将会在右上角出现一个关闭按钮      选择 button 后点击文本则会关闭通知      ]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread.wait()]]></title>
      <url>/java/multithreading/2017/05/05/Java-Thread.wait()/</url>
      <content type="text"><![CDATA[  wait() 和 notify() 必须在 synchronized 语句块中使用wait() 是强迫一个线程等待notify() 是通知一个线程继续运行功能  wait() 是针对已经获取对象锁的线程进行操作  当线程获取对象锁后，调用 wait() 主动释放对象锁，同时该线程休眠  直到其他线程调用 notify() 唤醒该线程，才继续获取对象锁，并执行  调用 notify() 唤醒线程并不是实时的，而是等相应的 synchronized 语句块执行结束，自动释放对象锁  再由 JVM 选取休眠的线程赋予对象锁，并执行，从而实现线程间同步、唤醒的操作对比  wait() 和 sleep() 都可以通过 interrupt() 打断线程的暂停状态，从而使线程立刻抛出 InterruptedException          通过 interrupt() 打断线程时，只需在 catch() 中捕获到异常即可安全结束线程      InterruptedException 是线程内部抛出，并不是 interrupt() 抛出      当线程执行普通代码时调用 interrupt() 并不会抛出异常，只有当线程进入 wait() / sleep() / join() 后才会立即抛出        wait() 和 sleep() 都可以暂定当前线程，其区别在于 wait() 在暂定的同时释放了对象锁  sleep() 是 Thread 的静态方法，wait() 是 Object 的一般方法实现public class WaitTest extends Thread {    private final Object self;    private final Object last;    public WaitTest(String name, Object self, Object last) {        super(name);        this.self = self;        this.last = last;    }    public void run() {        for (int i = 0; i &lt; 10; i++) {            // 锁住下一个对象            synchronized (last) {                // 锁住当前对象                synchronized (self) {                    if (super.getName().equals("A")) {                        System.out.println("第 " + (i + 1) + " 次运行！");                    }                    System.out.println(super.getName());                    // 等待一轮循环结束后唤醒当前线程                    self.notify();                }                try {                    // 释放下一个线程的对象锁                    last.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    public static void main(String[] args) {        Object a = new Object();        Object b = new Object();        Object c = new Object();        WaitTest waitA = new WaitTest("A", a, b);        WaitTest waitB = new WaitTest("B", b, c);        WaitTest waitC = new WaitTest("C", c, a);        waitA.start();        waitB.start();        waitC.start();    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Pagewalkthrough 页面引导]]></title>
      <url>/jquery/2017/05/03/Pagewalkthrough-%E9%A1%B5%E9%9D%A2%E5%BC%95%E5%AF%BC/</url>
      <content type="text"><![CDATA[  pagewalkthrough 可以在页面上生成引导操作，指引用户按照对页面元素进行了解官网jquery-pagewalkthrough页面插件所需 js/css 文件&lt;link type="text/css" rel="stylesheet" href="${ctx }/assets/plugins/pagewalkthrough/css/jquery.pagewalkthrough.css" /&gt;&lt;script type="text/javascript" src="${ctx }/assets/plugins/jquery-1.11.1.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="${ctx }/assets/plugins/pagewalkthrough/jquery.pagewalkthrough.js"&gt;&lt;/script&gt;在需要被引导的页面最下方加入引导内容&lt;div id="walkthrough-content"&gt;    &lt;div id="walkthrough-1"&gt;        &lt;h3&gt;欢迎加入轻实训在线教育平台&lt;/h3&gt;        &lt;p&gt;现在我们先对首页功能做一个初步了解&lt;/p&gt;        &lt;p&gt;点击下一步了解更多...&lt;/p&gt;    &lt;/div&gt;    &lt;div id="walkthrough-2" style="top: 0 !important;"&gt;这里是轻实训的LOGO，点击这里可以随时返回首页&lt;/div&gt;    &lt;div id="walkthrough-3"&gt;点击这里可以进入我的空间&lt;/div&gt;    &lt;div id="walkthrough-4"&gt;点击这里进入系统主菜单&lt;/div&gt;&lt;/div&gt;初始化插件$("body").pagewalkthrough({    name: "introduction",    steps: [{        popup: {            content: "#walkthrough-1",			  // 弹出方式 : modal/tooltip/mohighlight            type: "modal"        }    }, {        wrapper: "#logoImage",        popup: {            content: "#walkthrough-2",            type: "tooltip",            offsetHorizontal: 20,            offsetVertical: 50,            offsetArrowVertical: -10,			  // 弹出层位置 : top/left/right/bottom            position: "right"        }    }, {        wrapper: ".member-zone-tool",        popup: {            content: "#walkthrough-3",            type: "tooltip",            offsetHorizontal: 20,            offsetVertical: 50,            offsetArrowVertical: -30,            position: "right"        }    }, {        wrapper: "#memberProfileBtn",        popup: {            content: "#walkthrough-4",            type: "tooltip",            offsetHorizontal: 0,            offsetVertical: 50,            position: "left"        }    }],    onClose: function () {		  // 引导页关闭触发方法		  },	  // 按钮文字本地化    buttons: {        jpwClose: {            i18n: "点击关闭"        },        jpwNext: {            i18n: "下一步 &amp;rarr;"        },        jpwPrevious: {            i18n: "&amp;larr; 上一步"        },        jpwFinish: {            i18n: "完成 &amp;#10004;"        }    }});]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Atom 快捷键]]></title>
      <url>/software/atom/2017/05/02/Atom-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="text"><![CDATA[  Atom 一些常用的快捷键软件功能  Command+Shift+P          命令面板        Command+,          设置窗口        Command+T/P          搜索目录中的文件        Command+B          列出并搜索当前打开的所有文件        Ctrl+Shift+S          查看所有代码片段      内容编辑  Ctrl+G          跳转到文件指定行数        Command+R          跳转到指定符号[函数名、变量名 …]        Command+F2          在当前行创建/取消书签        Ctrl+F2          列出所有书签        F2          跳转到下一个标签        Shift+F2          跳转到上一个标签        Ctrl+Shift+W          选中光标所在单词        Ctrl+T          相互调换光标前后字符        Command+J          将下一行内容拼接到当前行尾        Ctrl+Command+Up          将当前行向上移动一行        Ctrl+Command+Down          将当前行向下移动一行        Command+Shift+D          复制当前行        Command+K+U          将光标所在单词转换为大写        Command+K+L          将光标所在单词转化为小写        Command+Alt+Q          取消当前段落格式化        Ctrl+Shift+K          删除当前行        Command+Backspace          从当前光标删除至行头        Command+Delete          从当前光标删除至行尾        Alt+Backspace          从当前光标删除至单词头        Alt+Delete          从当前光标删除至单词尾        Ctrl+Command+G          选中所有与光标所在单词相同的单词，并激活多光标模式        Command+D          选中下一个与光标所在单词相同的单词，并激活多光标模式        Ctrl+M          跳转到临近括号处        Ctrl+Command+M          选中当前括号中所有内容        Alt+Command+.          标签自动补全        Ctrl+Shift+U          设置当前文件编码格式        Ctrl+Space          查看代码提示        Alt+Command+[          折叠代码        Alt+Command+]          展开代码        Alt+Command+Shift+[          折叠所有代码        Alt+Command+Shift+]          展开所有代码        Ctrl+Shift+L          设置当前文件的代码格式      ]]></content>
      <categories>
        
          <category> software </category>
        
          <category> atom </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> atom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC使用MultipartFile实现文件上传]]></title>
      <url>/java/springmvc/2017/04/26/SpringMVC%E4%BD%BF%E7%94%A8MultipartFile%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      <content type="text"><![CDATA[  SpringMVC 接收 MultipartFile 需要在 spring-mvc.xml 中配置文件解析器配置&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;    &lt;property name="maxUploadSize" value="20971520"/&gt;    &lt;property name="defaultEncoding" value="UTF-8"/&gt;&lt;/bean&gt;依赖&lt;dependency&gt;	&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;	&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;	&lt;groupId&gt;commons-io&lt;/groupId&gt;	&lt;artifactId&gt;commons-io&lt;/artifactId&gt;&lt;/dependency&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> fileupload </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mac 10.12 允许任何来源]]></title>
      <url>/mac/2017/04/22/Mac-10.12-%E5%85%81%E8%AE%B8%E4%BB%BB%E4%BD%95%E6%9D%A5%E6%BA%90/</url>
      <content type="text"><![CDATA[  macos 10.12 之后在安全与隐私中不支持选择任何来源解决  打开终端输入 sudo spctl --master-disable结果]]></content>
      <categories>
        
          <category> mac </category>
        
      </categories>
      <tags>
        
          <tag> mac </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread.yield()]]></title>
      <url>/java/multithreading/2017/04/21/Java-Thread.yield()/</url>
      <content type="text"><![CDATA[  yield() 是 Thread 提供的一个静态方法，可直接通过 Thread 调用yield() 是提醒线程暂停功能  暂停当前正在执行的线程对象，并执行其他线程特点  让当前运行线程回到可运行状态，从而让拥有相同优先级的线程获取运行机会  其目的是让拥有相同优先级的线程之前能适当的轮转运行  实际上 yeld() 的可行性无法得到保证，因为回到可运行状态的线程依旧有可能有限被调度程序选中  yeld() 不会导致线程回到等待/睡眠/阻塞状态，所以对线程执行该方法后可能没有效果对比  sleep() 放线程进行停滞状态，导致线程在指定时间内停止运行  yield() 只是让线程回到可运行状态，但重新获取运行权的可能还是这个线程  sleep() 允许优先级较低线程在当前线程停滞后获取运行权  yield() 不可能让比当前线程优先级低的线程获取运行权实现public YieldTest extends Thread {	public YieldTest (String name) {		super(name);	}	public void run() {		for (int i = 1; i &lt;= 5; i++) {			System.out.println(this.getName() + " 运行 " + i + " 次");			if (i == 3) {				this.yield();			}		}	}	public static void main(String[] args) {		YieldTest tom = new YieldTest("tom");		YieldTest jerry = new YieldTest("jerry");		tom.start();		jerry.start();	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread 调度]]></title>
      <url>/java/multithreading/2017/04/21/Java-Thread-%E8%B0%83%E5%BA%A6/</url>
      <content type="text"><![CDATA[  Thread 调整线程优先级，称为线程调度线程优先级越高，则会获得更多的运行机会级别  优先级的取值范围是 1-10 ，但只提供 3 个常量          Thread.MAX_PRIORITY - 最高优先级，取值 10      Thread.MIN_PRIORITY - 最低优先级，取值 1      Thread.NORM_PRIORITY - 默认优先级，取值 5        虽然 JVM 提供了 10 个优先级，但不推荐使用常量以外的其他优先级，因为其一致性不佳  线程的优先级拥有继承关系，子类默认和父类拥有相同优先级方法  setPriority() 设置优先级  getPriority() 获取优先级]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread join()]]></title>
      <url>/java/multithreading/2017/04/21/Java-Thread-join()/</url>
      <content type="text"><![CDATA[  join() 是 Thread 提供的一个方法，线程启动后可直接调用join() 是等待线程终止功能  线程调用 join() 后，主线程必须等待该线程终止后，主线程才能终止场景  当主线程调用子线程后，子线程需要大量的耗时运算  由于多线程的特性，往往导致主线程会在子线程之前结束  那么主线程结束之前就无法获取到子线程的运算结果  当子线程调用 join() 后，会强制主线程必须等待子线程终止后，主线程才能终止  从而主线程就可以获取到子线程的运算结果实现  主线程的结束语句一定会等两个子线程都结束后才会运行public JoinTest implements Runnable {	private String name;	public JoinTest(String name) {		this.name = name;	}	public void run() {		System.out.println(name = " 线程开始运行！");		for (int i = 1; i &lt;= 5; i++) {			System.out.println(name = " 线程运行 " + i + " 次！");			try {				Thread.sleep(500);			} catch (InterruptedException e) {				e.printStackTrace();			}		}				System.out.println(name = " 线程运行结束！");	}	public static void main(String[] args) {		System.out.println("主线程开始运行！\n");		JoinTest tom = new JoinTest("tom");		JoinTest jerry = new JoinTest("jerry");		Thread tomThread = new Thread(tom);		Thread jerryThread = new Thread(jerry);		tomThread.start();		jerryThread.start();		try {			tomThread.join();			jerryThread.join();		} catch (InterruptedException e) {			e.printStackTrace();		}		System.out.println("\n主线程运行结束！");	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread 状态转换]]></title>
      <url>/java/multithreading/2017/04/18/Java-Thread-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</url>
      <content type="text"><![CDATA[  下图对 Thread 的所有状态进行流程描述分解  初始 - 新创建一个线程对象  就绪- 对象的 start() 被调用          处于该状态的线程位于可运行线程池中，等待获取 CPU 使用权        运行 - 执行程序代码  阻塞 - 因为某种原因放弃 CPU 使用权，暂时停止运行          处于该状态的线程直到重新进入就绪状态，才有机会回到运行状态      该状态具体分为三种                  等待 - 该线程执行 wait() ，JVM 将该线程放入等待池中，并释放持有的锁          同步 - 该线程在获取对象同步锁时，发现该同步锁被占用，JVM 则将该线程放入锁池中          其他 - 该线程执行 sleep() 或 join() 或发出 I/O 请求，JVM 将该线程改为阻塞状态                      死亡 - 线程执行结束或因抛出异常导致退出 run()]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 继承 Thread 类]]></title>
      <url>/java/multithreading/2017/04/17/Java-%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB/</url>
      <content type="text"><![CDATA[  如果只是启动一个线程，则可通过继承 Thread 类来实现但一般推荐使用 Runnable - Java 实现 Runnable 接口Thread 类实际上也是实现了 Runnable 接口注意  程序运行时，Java 虚拟机启动一个进程，主线程在 main() 调用时被创建  在 main() 中调用 ThreadTest 的两个对象，则启动两个线程  start() 的调用不会立即执行多线程代码，而是促使该线程变为可运行态，具体运行时间由操作系统决定  多线程是乱序执行的，每次执行的结果都不确定  在多线程中调用 sleep() 的目的是不让当前线程占用全部系统资源  如果一个对象的 start() 被重复调用，则会抛出 java.lang.IllegalThreadStateException 异常实现public class ThreadTest extends Thread {	private String name;	public ThreadTest (String name) {		this.name = name;	}	public void run() {		for (int i = 1; i &lt;= 5; i++) {			System.out.println(name + " 运行 " + i + " 次");			try {					// 单位毫秒				sleep(1000);			} catch (InterruptedException e) {				e.printStackTrace();			}		}	}	public static void main(String[] args) {		ThreadTest tom = new ThreadTest("tom");		ThreadTest jerry = new ThreadTest("jerry");		tom.start();		jerry.start();	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 实现 Runnable 接口]]></title>
      <url>/java/multithreading/2017/04/17/Java-%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3/</url>
      <content type="text"><![CDATA[  与 Java 继承 Thread 类 一样，实现 Runnable 接口也是启动 Java 线程的一种方式通过继承 Thread 类实现多线程的对象，不适合资源共享，而实现 Runnable 接口，则适合资源共享不论是通过继承 Thread 类或者实现 Runnable 接口来实现多线程，最终都是通过 Thread 的 API 控制线程注意  run() 是多线程程序的一个约定，所有的多线程代码都在其中执行  在启动多线程时，首先需要通过 Thread(Runnable target) 构造出线程对象，再调用 start() 运行多线程  所有的多线程代码都是通过 Thread 的 start() 来运行优势 - Runnable 相较于 Thread  适合拥有多个相同程序代码的线程去处理同一资源  可以避免 Java 中的单继承限制  代码可以被多个线程共享  代码和数据实现独立  增加程序的健壮性  线程池只能放入实现 Runnable 或 Callable 的类，不能直接放入继承 Thread 的类实现public class RunnableTest implements Runnable {	private String name;	public RunnableTest(String name) {		this.name = name;	}	public void run() {		for (int i = 1; i &lt;= 5; i++) {			System.out.println(name + " 运行 " + i + " 次");			try {				Thread.sleep(1000);			} catch (InerruptedException e) {				e.printStackTrace();			}		}	}	public static void main(String[] args) {		RunnableTest tom = new RunnableTest("tom");		RunnableTest jerry = new RunnableTest("jerry");		new Thread(tom).start();		new Thread(jerry).start();	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 身份证号码验证]]></title>
      <url>/java/validate/2017/04/16/Java-%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E7%A0%81%E9%AA%8C%E8%AF%81/</url>
      <content type="text"><![CDATA[  对身份证号码前 17 位通过一段算法规则进行计算，可得出身份证号码最后 1 位的值所以身份证号码最后一位实际上是身份证号码校验码结构  地址码 - 6 位          表示编码对象常住户口所在市区县的行政区域划分代码      按 GB/T2260 规定执行        出生日期码 - 8 位          表示编码对象出生的年月日      按 GB/T7408 规定执行        顺序码 - 3 位          表示在他同一地址码所标识的区域范围内，对同年同月同日出生的人编订的顺序码      顺序码奇数为男生，偶数为女生        校验码 - 1 位          前 17 位数字本体码加权求和                  S = Sum(Ai * Wi)          Ai : 表示 0 - 17 位身份证号码的数值 0 - 9          Wi : 表示 0 - 17 位身份证号码的加权因子 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2                    根据求和结果计算模                  Y = mod(S, 11)                    根据模查找对应校验码                  Y            0 1 2 3 4 5 6 7 8 9 10          校验码  1 0 X 9 8 7 6 5 4 3 2                    实现  通过计算获取第 18 位的校验码// 十七位数字本体码权重int[] weight = {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2};// mod 对应校验码字符值char[] validate = {'1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'};public char getValidateCode(String id17) {    int sum = 0;    int mode = 0;    for (int i = 0; i &lt; id17.length(); i++) {        sum = sum + Integer.parseInt(String.valueOf(id17.charAt(i))) * weight[i];    }    mode = sum % 11;    return validate[mode];}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> validate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> validate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux 杀死多个进程]]></title>
      <url>/linux/2017/04/13/Linux-%E6%9D%80%E6%AD%BB%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B/</url>
      <content type="text"><![CDATA[  对于拥有共同关键字的进程，可以通过一条命令批量 kill语法ps aux | grep "common" | cut –c 9-15 | xargs kill –9解析  ps aux 查看所有进程的命令  grep "common" 在前序命令查找到的进程中过滤出存在关键字 common 的进程  cut -c 9-15 在前序命令过滤出的进程中截取输出行的第 9 到 15 个字符，正好是进程 PID  xargs 将前序命令得到的结果作为 kill -9 的参数]]></content>
      <categories>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 代理之静态代理]]></title>
      <url>/java/proxy/2017/04/13/Java-%E4%BB%A3%E7%90%86%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="text"><![CDATA[  静态代理是指在程序运行前代理关系就已经存在其代理类和委托类会实现同一接口或是来自相同的父类定义共同接口public class Sell {	void sell();	void ad();}定义委托类public class Vendor implements Sell {	public void sell() {		System.out.println("In sell method");	}	public void ad() {		System.out.println("In ad method");	}}定义代理类  通过代理，可是实现对委托类被代理方法的修改，但不影响被代理方法的原始逻辑public class BusinessAgent implements Sell {	private Vendor vendor;	public BusinessAgent(Vendor vendor) {		this.vendor = vendor;	}	public void sell() {		System.out.println("-- before --");		vendor.sell();		System.out.println("-- after --");	}	public void add() {		System.out.println("-- before --");		vendor.ad();		System.out.println("-- after --");	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> proxy </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> proxy </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 代理之动态代理]]></title>
      <url>/java/proxy/2017/04/13/Java-%E4%BB%A3%E7%90%86%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="text"><![CDATA[  通过使用代理可以隐藏委托类的实现，并且实现客户与委托类之间的解耦，在不修改委托类的前提下为客户做一些额外处理类型  静态代理 - Java 代理之静态代理          虽然具备代理的两个优点      但局限在于运行前必须编写好代理类        动态代理          代理类在程序运行时才被创建      其优势在于可以对多个代理类进行统一处理，而不用修改每个代理类的实现      定义 InvocationHandler 接口，充当调用处理器  java.lang.reflect.InvocationHandler 是 Java 自带的调用处理器  为处于代理类和委托类之间的中间类提供实现接口  代理类作为参数 proxy 传入  参数 method 标识具体调用代理类的哪个方法  参数 args 是这个代理类方法的参数public interface InvocationHandler {	Object invoke(Object proxy, Method method, Object[] args);}定义委托类，使用动态代理，委托类必须实现某个接口public class Sell {	void sell();	void ad();}public class Vendor implements Sell {	public void sell() {		System.out.println("In sell method");	}	public void ad() {		System.out.println("In ad method");	}}定义中介类，其必须实现 InvocationHandler 接口  该类持有一个委托类的引用  中介类和委托类构成静态代理，中介类充当代理类，委托类依旧是委托类  中介类和代理类构成静态代理，中介类充当委托类，代理类依旧是代理类  所以实际上动态代理是由两组静态代理组成public class DynamicProxy implements InvocationHandler {	private Object object;	public DynamicProxy(Object object) {		this.object = object;	}	public void invoke(Object proxy, Mehtod method, Object[] args) {		System.out.println("-- before --");		Object result = method.invoke(object, args);		System.out.println("-- after --");		return result;	}}动态生成代理类  通过调用 Proxy.newProxyInstance() 获取代理类实例，其实现指定接口并将方法滴啊用分发到指定的调用处理器  该方法的声明 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)  参数 loader 是定义了代理类的 ClassLoader  参数 interfaces 是代理类实现的接口列表  参数 h 是调动处理器public class MainTest {	public static void main(String[] args) {		DynamicProxy dynamicProxy = new DynamicProxy(new Vendor());		Sell sell = (Sell) Proxy.newProxyInstance(Sell.class.getClassLoader(), new Class[]{Sell.class}, dynamicProxy);		sell.sell();		sell.ad();	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> proxy </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> proxy </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CORS 处理跨域请求]]></title>
      <url>/javascript/crossdomain/2017/04/12/CORS-%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
      <content type="text"><![CDATA[  CORS 是一个 W3C 标准，全称跨域资源共享 (Cross-orign resource sharing)其允许浏览器向跨域服务器发起异步请求，从而客服 ajax 受同源策略的限制使用  http-equiv 相当于 http 的响应头，其回应给浏览器一些有用的信息，用来帮助正确和精确的显示网页内容  以下规则表示允许任意域名下的网页跨域访问&lt;meta http-equiv="Access-Control-Allow-Origin" content="*"&gt;规则[1-8 为服务器提供，9-10 为浏览器 OPTIONS 请求默认自带]  Access-Control-Allow-Origin          指定允许哪些源的网页发送请求        Access-Control-Allow-Credentials          指定是否允许发送 cookie        Access-Control-Allow-Methods          指定允许哪些请求方法        Access-Control-Allow-Headers          指定允许哪些常规的头域字段，比如 Content-Type      常规头域字段有 Cache-Control 、Content-Language 、Content-Type 、Expires 、Last-Modified 、Pragma        Access-Control-Expose-Headers          指定允许哪些额外的头域字段，比如 X-Custom-Header      该字段只有需要获取基本字段以外的其他字段时，才需要使用        Access-Control-Max-Age          指定 preflight OPTIONS 请求的有效期，单位秒        Access-Control-Request-Method          告知服务器，浏览器将发送哪种请求，例如 POST        Access-Control-Request-Headers          告知服务器，浏览器将包含哪些额外的头域字段      类型  简单请求，满足以下两个条件          请求时如下三种之一                  HEAD          GET          POST                    http 头域不超过一下几种字段                  Accept          Accept-Language          Content-Language          Last-Event-ID          Content-Type 且内容限定为 application/x-www-form-urlencodedplain  multipart/form-data  text/plain                      非简单请求          不满足简单请求的两个条件，即为非简单请求      ]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> crossdomain </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> crossdomain </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OpenOffice 在 Linux 下安装使用]]></title>
      <url>/java/openoffice/linux/2017/04/11/OpenOffice-%E5%9C%A8-Linux-%E4%B8%8B%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      <content type="text"><![CDATA[  OpenOffice在linux下如何安装及使用官网OpenOffice安装  根据实际的 Linux 版本决定下载类型  在 tar 包所在目录，输入 tar -xzvf Apache_OpenOffice_4.1.3_Linux_x86-64_langpack-rpm_zh-CN.tar.gz 解压下载的 tar 包  接下来出来的文件在同目录下的 zn-CH  中，里面包含三个目录 RPMS readmes licenses  进入到 RPMS 中，执行 rpm -ivh *rpm 安装该目录下所有的 rpm 文件使用  进入默认安装目录 /opt/openoffice4/program 中  执行 /opt/openoffice4/program/soffice "-accept=socket,host=127.0.0.1,port=8100;urp;" -headless -nofirststartwizard &amp;  在命令的最后输入 &amp; 可确保服务在后端运行注意  若执行启动命令时报错 /opt/openoffice4/program/soffice.bin: error while loading shared libraries: libXext.so.6: cannot open shared object file: No such file or directory ，则需要安装 libXext 依赖包，根据 Linux 版本选择安装类型          执行 yum install libXext.x86_64      在 /usr/lib64 或 /usr/lib 中找到 libXext.so.6 文件，复制到 /opt/openoffice4/program/ 目录中      对复制过来的文件执行 chmod 777 libXext.so.6      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> openoffice </category>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> openoffice </tag>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java使用OpenOffice在线预览Office及PDF]]></title>
      <url>/java/openoffice/2017/04/11/Java%E4%BD%BF%E7%94%A8OpenOffice%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88-Office-%E5%8F%8A-PDF/</url>
      <content type="text"><![CDATA[  使用OpenOffice可实现在线预览office文件内容思路  用 OpenOffice 将 word / excel / ppt 转换为 pdf  用 pdf.js 将转换后的 pdf 显示在浏览器中显示准备  安装 OpenOffice ，参见 OpenOffice 在 Linux 下安装使用  启动 OpenOffice ，soffice "-accept=socket,host=localhost,port=8100;urp;" -headless -nofirststartwizard &amp;          Mac端需要跳转到 Applications/OpenOffice.app/Contents/program 才可启动服务        下载 JODConverter ，在其 lib 目录中找到 jodconverter-cli-2.2.2.jar ，并引入以下 jar 包  下载 PDF.js ，并引入到项目中          vue项目使用vue.js pdf viewer      在项目 pom.xml 中引入以下包&lt;dependency&gt;    &lt;groupId&gt;org.openoffice&lt;/groupId&gt;    &lt;artifactId&gt;juh&lt;/artifactId&gt;    &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openoffice&lt;/groupId&gt;    &lt;artifactId&gt;jurt&lt;/artifactId&gt;    &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openoffice&lt;/groupId&gt;    &lt;artifactId&gt;ridl&lt;/artifactId&gt;    &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openoffice&lt;/groupId&gt;    &lt;artifactId&gt;unoil&lt;/artifactId&gt;    &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openoffice&lt;/groupId&gt;    &lt;artifactId&gt;jodconverter&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;    &lt;scope&gt;system&lt;/scope&gt;    &lt;systemPath&gt;${basedir}/../lib/jodconverter-2.2.2.jar&lt;/systemPath&gt;&lt;/dependency&gt;调用服务并转换文件  通过 OpenOfficeConnection 调用 OpenOffice 服务，并将传入文件转换为 PDF 格式public static File fileToPdf(File file) {    // 文件全路径名    String fileName = file.getPath();    // 存放转换结果的 pdf 文件    File pdfFile = new File(fileName.substring(0, fileName.lastIndexOf(".")) + Constants.REPORT_FILE_PREVIEW_SUFFIX);    // 非空验证    if (!file.exists() || !file.isFile()) {        return null;    }    // 存在则不再转换    if (pdfFile.exists() &amp;&amp; pdfFile.isFile()) {        return pdfFile;    }    // 获取连接    OpenOfficeConnection connection = new SocketOpenOfficeConnection(Constants.OPEN_OFFICE_CONNECTION_PORT);    try {        // 建立连接        connection.connect();        // 开始转换        DocumentConverter converter = new OpenOfficeDocumentConverter(connection);        converter.convert(file, pdfFile);        // 关闭连接        connection.disconnect();    } catch (ConnectException e) {        logger.error("PDF 转换失败，OpenOffice 服务未启动！", e);        throw new TSharkException("PDF 转换失败，OpenOffice 服务未启动！", e);    }    return pdfFile;}在页面准备显示内容的区域  页面上通过 iframe 引入 pdf.js 中的 viewer.html  并传入待显示的 pdf 文件&lt;iframe src="${ctx}/assets/plugins/pdf/web/viewer.html?file=&lt;c:url value="/api/report/intro/preview/file/${fileNamePrefix}/${fileNameSuffix}"/&gt;" width="100%" height="100%" frameborder="0" scrolling="hidden"&gt;&lt;/iframe&gt;后端返回待显示的文件流  后端将待显示的 pdf 文件通过 ResponseEntity 传入到前端public ResponseEntity&lt;byte[]&gt; preview(String fileName) throws IOException {    // 获取文件    File file = new File(Constants.REPORT_SOURCE_FILE_PATH + fileName);    // 转换并返回结果    byte[] pdfFileBytes = FileUtils.readFileToByteArray(OnlinePreviewUtil.fileToPdf(file));    HttpHeaders httpHeaders = new HttpHeaders();    httpHeaders.setContentType(MediaType.valueOf("application/pdf"));    httpHeaders.setContentLength(pdfFileBytes.length);    httpHeaders.add(HttpHeaders.ACCEPT_RANGES, "bytes");    return new ResponseEntity&lt;byte[]&gt;(pdfFileBytes, httpHeaders, HttpStatus.OK);}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> openoffice </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> openoffice </tag>
        
          <tag> pdf </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Uploadifive 批量文件上传]]></title>
      <url>/jquery/2017/04/08/Uploadifive-%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      <content type="text"><![CDATA[  uploadifive 的前身是 uploadify uploadify 是用 flash 实现的批量文件上传，但目前 flash 技术已被淘汰，取而代之的 HTML5 才是大势所趋于是就有了采用 HTML5 实现批量文件上传的 uploadifive官网Uploadify下载 uploadifive 的插件包，需要注意的是 uploadifive 目前是收费插件引入插件所需 js 、css 文件&lt;script src="${ctx }/assets/plugins/jquery-2.1.3.min.js" type="text/javascript"&gt;&lt;/script&gt;&lt;script src="${ctx }/assets/plugins/uploadifive/jquery.uploadifive.js" type="text/javascript"&gt;&lt;/script&gt;&lt;link href="${ctx }/assets/plugins/uploadifive/uploadifive.css" rel="stylesheet" type="text/css"/&gt; 定义一个 input 标签用于上传文件&lt;input id="fileUpload" type="file" /&gt;调用 uploadifive 初始化方法$(function () {	$("#fileUpload").uploadifive({		"uploadScript": "/api/upload/file"	});});属性  auto - Boolean - true          当文件被添加到上传队列时，会自动上传        buttonClass - String          为上传按钮指定一个类选择器        buttonText - String - SELECT FILES          定义显示在按钮上的文本内容        uploadScript - String - uploadifive.php          上传文件到服务器的后端请求路径        checkScript - String          验证待上传文件是否已存在于文件目录中的后端请求路径      文件不存在则返回 0 ，存在则返回 1        dnd - Boolean - true          允许拖拽上传文件        fileObjName - String          为待上传的文件指定字段名称供后端接收        fileSizeLimit - String          指定单个文件的大小限制      默认单位是 KB ，但可以在数字后明确标识 MB 或 GB ，插件内部会自动转换为 KB        fileType - String          指定允许上传的文件类型      支持模糊匹配，例如 image/* 只允许上传图片，image/png 则只允许上传 png 格式的图片      允许多种类型的文件则需要通过 | 进行分隔      模糊匹配采用的格式是 MIME types ，可参见 Media Types        formData - JSON          指定文件上传时需要一起提交的其他数据对象        height - Number - 30          指定上传按钮的高度        width - Number - 100          指定上传按钮的宽度        itemTemplate - String          指定文件上传队列的 HTML 模版      模版的最外层 div 必须指定类选择器为 uploadifive-queue-item      .filename 显示文件名称      .close 提供关闭按钮      .fileinfo 显示文件信息      progress-bar 显示上传进度        method - String - post          指定上传文件的提交方式      取值为 post 或 get        multi - Boolean - true          支持多文件上传        overrideEvents - JSON          可指定多个插件默认事件中的事件名称，被指定的事件将不会执行        queueID - String          指定用于显示上传队列的父级元素      若启用了 dnd 功能，则将文件拖放到该父元素中，会触发文件上传        queueSizeLimit - Number          指定上传队列中一次可容纳的最大文件数量        removeCompleted - Boolean - false          文件上传完毕后从上传队列中移除        simUploadLimit - Number          一次可上传的文件数量        truncateLength - Number          指定文件名称的截取长度      设置该值后，文件名称超过该长度将会被截取        uploadLimit - Number          指定允许上传的最大文件数量      该值的设定不会影响上传队列中可添加的文件数量      事件添加新文件到上传队列中"onAddQueueItem": function (file) {	console.log(file.name);}将文件从上传队列中删除"onCancel": function (file) {	console.log(file.name);}验证文件是否已存在"onCheck": function (file, exists) {	console.log(file.name);	console.log(exists ? "存在" : "不存在");}清空上传队列"onClearQueue": function (queue) {	console.log(queue.css());}销毁 uploadifive 实例"onDestroy": function () {	console.log("uploadifive 实例被销毁");}将文件拖拽到上传队列中"onDrop": function (files, fileDropCount) {	console.log(files.length);	console.log("拖拽文件数量：" + fileDropCount)}上传文件出错"onError": function (errorType) {	console.log("QUEUE_LIMIT_EXCEEDED: 超过上传队列允许的文件数量");	console.log("UPLOAD_LIMIT_EXCEEDED: 超过上传文件允许的文件数量");	console.log("FILE_SIZE_LIMIT_EXCEEDED: 超过上传文件允许的大小限制");	console.log("FORBIDDEN_FILE_TYPE: 被禁止上传的文件类型");	console.log("404_FILE_NOT_FOUND: 未找到文件");}浏览器不支持 HTML5"onFallback": function () {	console.loh("浏览器不支持 HTML5");}初始化 uploadifive 完成"onInit": function () {	console.log("uploadifive 已初始化完成");}文件上传中"onProgress": function (file, event) {	console.log(file.name);	console.log(event.lengthComputable ? "文件上传进度可计算" : "文件上传进度不可计算");	console.log("文件已上传" + evenet.loaded + "字节");	console.log("文件总共" + evenet.total + "字节");}上传队列中的所有文件上传完成"onQueueComplete": function (uploads) {	console.log(uploads.attempts);	console.log("上传成功的文件数量：" + uploads.successful);	console.log("上传失败的文件数量：" + uploads.errors);	console.log("上传文件总数量：" + uploads.count);}选择某个文件"onSelect": function (queue) {	console.log("被取消的文件数量：" + queue.cancelled);	console.log("上传队列中的文件数量：" + queue.count);	console.log("上传错误的文件数量：" + queue.errors);	console.log("被添加到上传队列中的文件数量：" + queue.queued);	console.log("被选择的文件数量：" + queue.selected);}文件被上传"onUpload": function (filesToUpload) {	console.log("将被上传的文件数量：" + filesToUpload);}每一个文件上传完成"onUploadComplete": function (file, data) {	console.log(file.name);	console.log("后端异步操作返回结果：" + JSON.parse(data));}每一个文件上传开始"onUploadFile": function (file) {	console.log(file.name);}方法取消文件上传  从上传队列中指定被取消上传的文件  取消上传的显示方式，为 true 表示直接取消，为 false 则会有一个淡出隐藏的效果$("#uploadFile").uploadifive("cancel", $('.uploadifive-queue-item').first().data('file'), true);清空上传队列$("#uploadFile").uploadifive("clearQueue");在控制台输出 uploadifive 详细信息$("#uploadFile").uploadifive("debug");销毁 uploadifive 实例$("#uploadFile").uploadifive("destroy");开始上传文件  从上传队列中指定被上传的文件  第二个参数未指定则默认上传队列中所有文件$("#uploadFile").uploadifive("upload", $('.uploadifive-queue-item').first().data('file'));]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
          <tag> upload </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery ajax 参数列表]]></title>
      <url>/jquery/ajax/2017/04/06/jQuery-ajax-%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8/</url>
      <content type="text"><![CDATA[  $.ajax() 只有一个参数，该参数为 key-value 对象jQuery 发送的所有 ajax 请求，都是通过调用该 ajax 方法实现参数列表  accepts - Object          用于通知服务器该请求需要接受哪种类型的返回结果      有必要的话，推荐在 $.ajaxSetup() 中设置一次        async - Boolean          默认为 true ，即异步        beforeSend - Function          请求发送前的回调方法，默认参数为 xhr 和 settings      函数中显示返回 false 将取消本次请求        cache - Boolean          请求是否开启缓存，默认为 true      当 dataType 的值等于 script 或 jsonp 时，默认为 false        contents - Object          通过字符串或正则表达式配对的对象      根据给定的内容类型，解析请求的返回结果        contentType - String          编码类型，相对应与 http 请求头域中的 Content-Type 字段      默认值为 application/x-www-form-urlencoded; charset=UTF-8        context - Object          设置 ajax 回调函数的上下文      默认上下文为 ajax 请求传入的参数设置对象      例如设置为 document.body ，则所有回调函数将以 body 为上下文        converts - Object          数据类型转换器对象      默认为 {"* text": window.String, "text html": true, "text json": jQuery.parseJSON, "text xml": jQuery.parseXML}      可写成 converters: {"json jsonp": function(msg){}}        crossDomain - Boolean          是否跨域，默认为 false        data - Object / Array          发送到服务器的数据，默认为 key-value 格式对象      如果将 traditional 设置为 true ，则会将 data 参数的内容序列化，如将 {a:1, b: 2} -&gt; &amp;a=1&amp;b=2        traditional - Boolean          按照默认方式序列化 data 对象，默认为 false        dataFilter - String          处理 XMLHttpRequest 原始响应数据的回调，默认参数为 data 和 type      data 是 ajax 返回的原始数据      type 是调用 dataType 参数的值        dataType - String          预期服务器返回的数据类型 [ xml / html / script / json / jsonp / text ]      设置为 xml 或 text ，返回数据不会被处理        success - Function          请求成功后的回调，默认参数为 xhr 和 textStatus 以及 successString      使用 jsonp 请求时，该方法被 done(function (data, textStatus, jqXHR) {}) 替代        error - Function          请求失败时的回调，默认参数为 xhr 和 textStatus [ null / timeout / error / abort / parsererror ] 以及 errorString      该方法可以设置为一个包含函数的数组，从而保证每个函数一次被调用      跨域脚本或 JSONP 请求时，该方法不会被调用      使用 jsonp 请求时，该方法被 fail(function (jqXHR, textStatus, errorThrown) {}) 替代        complete - Function          请求完成后的回调，默认参数为 xhr 和 textStatus [ success / notmodified / error / timeout / abort / parsererror ]      不论结果是 success 或 error ，都会触发该回调      该方法可以设置为一个包含函数的数组，从而保证每个函数一次被调用      使用 jsonp 请求时，该方法被 always(function (data or jqXHR, textStatus, jqXHR or errorThrown) {}) 替代        global - Boolean          表示是否出发全局 ajax 事件，默认为 true      设置为 false 将导致 ajaxStart / ajaxStop / ajaxSend / ajaxError 不被触发      跨域脚本或 JSONP 请求时，改值默认为 false        headers - Object          设置请求头，默认为 key-value 格式对象      该设置会在 beforeSend 被调用之前生效，所以在 beforeSend 中可覆盖该设置        isModified - Boolean          只有上次请求响应改变时，才允许请求成功，默认为 false      设置为 true ，若数据自上次请求后没有更改过，则会报错      已 http 包中的 Last-Modified 头信息作为判断依据        isLocal - Boolean          将当前运行环境设置为本地，默认为 false      设置为 true ，将影响请求发送时的协议        jsonp - String          显示指定 jsonp 请求中的回调函数的名称      若设置为 jsonp: test ，则会替换掉默认 callback ，以 test=? 传给服务器      若设置为 jsonp: false  ，则需要明确设置 jsonpCallback 的值        jsonpCallback - String / Function          为 jsonp 请求指定一个回调函数名称或回调函数体，用来取代默认生成的随机函数名      回调函数的返回值就是 jsonpCallback 的结果        mimeType - String          设置一个 MIME 类型，用于覆盖 xhr 的 MIME 类型        username - String          设置认证请求中的用户名        password - String          设置认证请求中的密码        processData - Boolean          ajax 方法默认会将传入的 data 隐式转换为查询字符串，用于配合默认的 contentType      设置为 false ，则不会进行上述转换操作        scriptCharset - String          只能在 dataType: script 设置后使用      设置后将影响  标签上的 charset 属性      仅推荐在跨域请求中使用        statusCode - Object          一组 http 状态码和回调函数对应的 key-value 格式对象，例如 {404: function () {}}      可用于根据不同的 http 状态码，执行不同的回调        timeout - Number          设置超时时间        type - String          可设置为 8 种 http method 之一，不区分大小写        url - String          ajax 请求的 url 地址        xhr - Function          在回调中创建并返回 XMLHttpRequest 对象        xhrFields - Object          设置原生的 xhr 对象，默认为 key-value 格式对象      ]]></content>
      <categories>
        
          <category> jquery </category>
        
          <category> ajax </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
          <tag> ajax </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring的@Transactional详解]]></title>
      <url>/java/springboot/springmvc/2017/04/05/Spring%E7%9A%84@Transactional%E8%AF%A6%E8%A7%A3/</url>
      <content type="text"><![CDATA[  Spring 提供的事务管理机制为不同的事务 API 提供一致的编程模型管理方式  编程式事务          TransactionTemplate [推荐]      PlatformTransactionManager [基于底层]        声明式事务 [推荐]          基于 &lt;tx/&gt; 和 &lt;aop/&gt; 的 xml 配置文件      使用 @Transactional 注解 [推荐]      配置方式  使用 @Transactional 注解的声明式配置参见 SpringMVC声明式事务配置注意点  默认情况下，数据库处于紫铜提交模式，每个语句处于单独的事务中  对于正常的事务管理，应当是一组相关操作处于同一个事务中  Spring 默认将底层连接的自动提交设置为 false  有些数据连接池提供自动提交的开关设置，但 c3p0 未提供  JDBC 规范明文指出当连接对象建立时应该处理自动提交模式，对于自动提交的开关应该进行显示处理  当一个连接关闭时，未提交的事务应该回滚，虽然 JDBC 规范未明确指出，但 c3p0 默认将 autoCommitOnClose 设置为 false  MyBatis 会自动参与到 Spring 的事务管理中，只要二者引用的数据源一致@Transactional 属性  value - String          限定描述符，用于指定使用的事务管理器        isolation - enum          事务隔离级别，参见 Spring 事务隔离级别        propagation - enum          事务传播行为，参见 Spring 事务传播行为        readOnly - boolean          事务只读属性，默认读写      false = 读写，true = 只读      只读属性用于特殊情景优化，例如在使用 Hibernate 时，默认使用读写事务        timeout - int          事务超时时间，单位秒      如果超过该时间事务还没完成，则自动回滚事务      默认设置为底层事务系统的超时值，如果底层未设置，则为 none        rollbackFor - Class 对象数组，必须继承自 Throwable          导致事务回滚的异常类数组        rollbackForClassName - 类名数组，必须继承自 Throwable          导致事务回滚的异常类名称数组        noRollbackFor - Class 对象数组，必须继承自 Throwable          不会导致事务回滚的异常类数组        noRollbackForClassName - 类名数组，必须继承自 Throwable          不会导致事务回滚的异常类名称数组      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> springmvc </tag>
        
          <tag> spring </tag>
        
          <tag> transaction </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Maven POM 解析]]></title>
      <url>/java/maven/2017/04/05/Maven-POM-%E8%A7%A3%E6%9E%90/</url>
      <content type="text"><![CDATA[  描述Maven的pom文件中各项配置作用基础结构&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;    &lt;!-- maven 版本号，是固定值 --&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;!-- 项目包名 --&gt;    &lt;groupId&gt;org.seckill&lt;/groupId&gt;    &lt;!-- 项目名 + 模块名 --&gt;    &lt;artifactId&gt;seckill&lt;/artifactId&gt;    &lt;!-- 打包类型，默认 jar --&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;!-- 版本号 0.0.0 大版本号.分支版本号.小版本号 --&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;!-- 项目描述名 --&gt;    &lt;name&gt;seckill Maven Webapp&lt;/name&gt;    &lt;!-- 项目地址 --&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;!-- 项目描述 --&gt;    &lt;description&gt;product second kill system&lt;/description&gt;    &lt;!-- 开发者信息 --&gt;    &lt;developers&gt;        &lt;developer&gt;            &lt;name&gt;ThkcDo&lt;/name&gt;        &lt;/developer&gt;    &lt;/developers&gt;    &lt;!-- 许可证信息 --&gt;    &lt;licenses&gt;        &lt;license&gt;            &lt;name&gt;xxx&lt;/name&gt;        &lt;/license&gt;    &lt;/licenses&gt;    &lt;!-- 组织信息 --&gt;    &lt;organization&gt;        &lt;name&gt;ThkcDo&lt;/name&gt;    &lt;/organization&gt;    &lt;!-- 依赖类库列表 --&gt;    &lt;dependencies&gt;        &lt;!-- 测试相关依赖，使用 junit4 ，因为 junit4 是基于注解的 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;!-- 依赖范围，compile 默认类型，表示编译测试运行都有效 --&gt;            &lt;!-- test 表示只在测试时使用 --&gt;            &lt;!-- provided 表示在编译和测试时有效 --&gt;            &lt;!-- runtime 表示在测试和运行时有效 --&gt;            &lt;!-- system 表示在编译和测试时有效，但需要和本机系统关联，也就是依赖包的路径来自于本机，可移植性差 --&gt;            &lt;!-- import 表示从其他 pom 中导入依赖 --&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;!-- 设置依赖是否可选，默认 false --&gt;            &lt;optional&gt;false&lt;/optional&gt;            &lt;!-- 排除依赖传递列表 --&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;                    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;!-- 依赖管理，用于父模块声明公共依赖供子模块调用 --&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;                &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;	  &lt;!-- 构建信息 --&gt;    &lt;build&gt;        &lt;finalName&gt;seckill&lt;/finalName&gt;        &lt;!-- 插件列表 --&gt;        &lt;plugins&gt;            &lt;!-- 具体插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;                &lt;version&gt;2.4&lt;/version&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> maven </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> maven </tag>
        
          <tag> pom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript 获取 XMLHttpRequest 对象]]></title>
      <url>/javascript/ajax/2017/04/05/Javascript-%E8%8E%B7%E5%8F%96-XMLHttpRequest-%E5%AF%B9%E8%B1%A1/</url>
      <content type="text"><![CDATA[  浏览器通过 XMLHttpRequest 对象实现 Ajax 功能 而 IE6 以下版本只支持通过 ActiveXObject 对象实现 Ajax 功能以下提供一个全平台兼容获取 Ajax 支持对象的方法实现方式function getXHR(){  var xhr = null;	// 浏览器支持 XMLHttpRequest  if(window.XMLHttpRequest) {		xhr = new XMLHttpRequest();  } else if (window.ActiveXObject) {		// IE6 以下浏览器只支持 AactiveXObject    	try {			// 获取 MSXML3 标准      	xhr = new ActiveXObject("Msxml2.XMLHTTP");	    } catch (e) {  		    try {				// 备选方案，功能不完善，不推荐使用      		xhr = new ActiveXObject("Microsoft.XMLHTTP");		    } catch (e) {         		alert("您的浏览器暂不支持Ajax!");      	}    	}  }  return xhr;}]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> ajax </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> ajax </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Protostuff 自定义序列化]]></title>
      <url>/java/2017/04/04/Java-Protostuff-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      <content type="text"><![CDATA[  虽然 Java 提供内置的序列化 API Serializable ，但其效率并不是最高的Google 提供了一个效率很高的序列化 API Protobuf ，但其使用过于复杂开源社区在 Protobuf 的基础上封装出 Protostuff ，在不丢失效率的前提上，让使用步骤变得更简单一般情况下 Protostuff 序列化后的数据大小是 Serializable 的 1/10 之一，速度更是两个量级以上依赖&lt;dependency&gt;	&lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;	&lt;artifactId&gt;protostuff-core&lt;/artifactId&gt;	&lt;version&gt;1.1.1&lt;/version&gt;	&lt;/dependency&gt;&lt;dependency&gt;	&lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;	&lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;	&lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;创建 Schema 序列化规则对象  规则对象只接受任何带 set/get 方法的 POJO 对象private RuntimeSchema&lt;RecordDTO&gt; schema = RuntimeSchema.createFrom(RecordDTO.class);数据序列化public void setRecord(RecordDTO record) {	// 将未序列化的对象数据通过 schema 规则进行序列化	// LinkedBuffer 缓存器的作用是当对象数据过大时，可以对数据进行缓存，从而实现分布序列化	byte[] bytes = ProtobufIOUtil.toByteArray(record, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));}数据反序列化public RecordDTO getRecord(byte[] bytes) {	// 空的对象数据	RecordDTO record = schema.newMessage();	// 将被序列化的对象数据通过 schema 规则反序列化转换到空的对象数据中	ProtobufIOUtil.mergeFrom(bytes, record, schema);	return record;}]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> serializable </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery one() 防止重复点击]]></title>
      <url>/jquery/2017/04/02/jQuery-one()-%E9%98%B2%E6%AD%A2%E9%87%8D%E5%A4%8D%E7%82%B9%E5%87%BB/</url>
      <content type="text"><![CDATA[  $.one() 方法的意思是给指定按钮绑定一次性事件，即使用一次便失效实现方式$(".submit-btn").one("click", function () {	...});]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis批量新增]]></title>
      <url>/java/mybatis/2017/03/31/MyBatis%E6%89%B9%E9%87%8F%E6%96%B0%E5%A2%9E/</url>
      <content type="text"><![CDATA[  通过循环 values 语句实现批量新增数据&lt;insert id="saveTimetables"&gt; INSERT INTO pt_timetable (  id,  lessonNo ) VALUES  &lt;foreach collection="list" item="item" separator=","&gt;   (    #{item.id},              #{item.lessonNo}          )  &lt;/foreach&gt;&lt;/insert&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Apache POI 操作 Excel 导入]]></title>
      <url>/java/poi/2017/03/31/Java-Apache-POI-%E6%93%8D%E4%BD%9C-Excel-%E5%AF%BC%E5%85%A5/</url>
      <content type="text"><![CDATA[  Java 可以通过 Apache POI 操作 Excel 的导入导出Apache POI 是一套操作 Microsoft Office 套件的开源 Java API官网Apache POI依赖  要使用 Apache POI 的功能需要引入以下两个 jar 包          操作 Excel 2003 (.xls) 及之前的版本，只用导入 poi 即可      操作 Excel 2007 (.xlsx) 及以后的版本，则还需要导入 poi-ooxml 才可      &lt;dependency&gt;	&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;	&lt;artifactId&gt;poi&lt;/artifactId&gt;	&lt;version&gt;3.10.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;	&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;	&lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;	&lt;version&gt;3.10.1&lt;/version&gt;&lt;/dependency&gt;判断文件版本  通过上传的文件类型，判断 Excel 的版本，根据具体版本返回解析类          上传 Excel 文件的方式和普通的文件上传没有差异      对于 springMVC 则可以使用 MultipartFile 进行文件获取      private static Workbook getWorkbook(MultipartFile excelFile) throws IOException {    // 获取文件输入流    InputStream inputStream = excelFile.getInputStream();    // 获取文件内容    String fileName = excelFile.getOriginalFilename();    // 获取文件类型    String fileType = fileName.substring(fileName.indexOf("."));    // 判断文件类型    if (("xls").equalsIgnoreCase(fileType)) {        return new HSSFWorkbook(inputStream);    } else if (("xlsx").equalsIgnoreCase(fileType)) {        return new XSSFWorkbook(inputStream);    } else {        logger.error("Excel 文件解析失败，格式错误！");        throw new TSharkException("Excel 文件解析失败，格式错误！");    }}获取到 Excel 文件解析类后则对文件进行解压  解压的方式是依次遍历 Excel 内容：sheet-row-column  遍历时需要考虑到每个阶段非空的情况  遍历 row 的时候需要考虑过滤表头的情况，一般表头可能是表格信息（具体情况需要根据模版决定）public static List&lt;List&lt;Object&gt;&gt; getExcelContent(MultipartFile excelFile) {    // 行列表    List&lt;List&lt;Object&gt;&gt; contents = Lists.newArrayList();    Workbook workbook;    try {        // 解析 Excel 获取 Workbook        workbook = getWorkbook(excelFile);    } catch (IOException e) {        logger.error("获取 Excel 内容失败！", e);        throw new TSharkException("获取 Excel 内容失败！", e);    }    // 遍历所有表    for (int i = 0; i &lt; workbook.getNumberOfSheets(); i++) {        // 获取当前表        Sheet sheet = workbook.getSheetAt(i);        // 非空验证        if (null == sheet) {            continue;        }        // 遍历当前表中所有行,过滤掉标题行        for (int j = sheet.getFirstRowNum() + 1; j &lt;= sheet.getLastRowNum(); j++) {            // 获取当前行            Row row = sheet.getRow(j);            // 非空验证            if (null == row) {                continue;            }            // 单元格列表            List&lt;Object&gt; cells = Lists.newArrayList();            // 遍历当前行中所有单元格            for (int k = row.getFirstCellNum(); k &lt;= row.getLastCellNum(); k++) {                // 获取当前单元格                Cell cell = row.getCell(k);                // 非空验证                if (null == cell) {                    continue;                }                // 获取单元格格式化后的内容                cells.add(formatCellValue(cell));            }            // 获取所有行的单元格列表            contents.add(cells);        }    }    return contents;}遍历文件内容  遍历内容到最后是获取单元格内容，而单元格的内容获取需要进行一定的格式化处理private static Object formatCellValue(Cell cell) {    Object cellValue = null;    switch (cell.getCellType()) {        case Cell.CELL_TYPE_STRING:            cellValue = cell.getRichStringCellValue().toString();            break;        case Cell.CELL_TYPE_NUMERIC:            // 获取具体类型            String dataFormat = cell.getCellStyle().getDataFormatString();            // 具体类型判断            if (("General").equalsIgnoreCase(dataFormat)) {                cellValue = new DecimalFormat("0").format(cell.getNumericCellValue());            } else if (("m/d/yy").equalsIgnoreCase(dataFormat)) {                cellValue = DateUtil.dateToString(cell.getDateCellValue());            } else {                cellValue = new DecimalFormat("0.00").format(cell.getNumericCellValue());            }            break;        case Cell.CELL_TYPE_BOOLEAN:            cellValue = cell.getBooleanCellValue();            break;        case Cell.CELL_TYPE_BLANK:            cellValue = "";            break;        default:            break;    }    return cellValue;}处理过滤得到的数据  将 Excel 中的内容遍历到 List 列表中后，则需要对列表中的有效内容进行读取          读取的具体内容索引根据模版实际情况决定      在读取内容的同时则可以对数据进行持久化操作      private List&lt;UniversityMemberDTO&gt; generateUniversityMembers(List&lt;List&lt;Object&gt;&gt; contents) {    List&lt;UniversityMemberDTO&gt; universityMembers = Lists.newArrayList();    // 遍历内容列表    for (List&lt;Object&gt; content : contents) {        UniversityMemberDTO universityMember = new UniversityMemberDTO();        // 登录名        universityMember.setLoginName((String) content.get(0));        // 真实姓名        universityMember.setRealName((String) content.get(1));        // 联系方式        universityMember.setMobile((String) content.get(2));        // 邮箱        universityMember.setEmail((String) content.get(3));        // 专业名称        universityMember.setMajorName((String) content.get(4));        // 学院名称        universityMember.setInstituteName((String) content.get(5));        // 用户类型        universityMember.setType(getUniversityMemberType((String) content.get(6)));        universityMembers.add(universityMember);    }    return universityMembers;}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> poi </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> poi </tag>
        
          <tag> excel </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC的CacheManager配置]]></title>
      <url>/java/springmvc/2017/03/27/SpringMVC%E7%9A%84CacheManager%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  Spring 3.1 后提供一个新特性 基于注释驱动的缓存可以通过在方法上加入注解，从而缓存该方法返回的数据编写配置文件&lt;!-- 使用缺省名称为 cacheManager 的缓存管理器，其缺省实现为 org.springframework.cache.support.SimpleCacheManager --&gt;&lt;cache:annotation-driven/&gt;&lt;!-- 配置 cacheManager --&gt;&lt;bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager"&gt;&lt;!-- 配置缓存集合 --&gt;&lt;property name="caches"&gt;&lt;set&gt;&lt;!-- 缺省方案 --&gt;&lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="default"/&gt;&lt;!-- 自定义方案 --&gt;&lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="dictionaryCache"/&gt;&lt;/set&gt;&lt;/property&gt;&lt;/bean&gt;在需要缓存的方法上加缓存注释，并指定自定义名称@Cacheable(value = "dictionaryCache")public List&lt;DictionaryDTO&gt; getDictionaries(String className) {return dictionaryDao.getDictionaries(className);}清空缓存  allEntries = true 表示清空所有缓存  key = "#dictionary.getName()" 表示只清空方法参数中带有指定key的缓存@CacheEvict(value = "departmentService", allEntries = true)public ResponseData removeDictionary(Long id) {...}@CacheEvict(value = "departmentService", key = "#dictionary.getName()")public void addDictionary(DictionaryDTO dictionary) {...}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> cache </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC声明式事务配置]]></title>
      <url>/java/springmvc/2017/03/25/SpringMVC%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  Spring 的事务管理机制用处在于保证数据统一性在事务执行过程中如果出现报错，Spring 的事务管理机制会回滚事务，保证数据库的数据不会出现只更改一部分的情况但触发事务回滚的报错必须是 RuntimeExpection，只有这种异常可以被 Spring 事务捕获到如果随意使用 try-catch 对报错进行包裹，会导致报错在方法体内被处理报错信息不再向上抛出，即 Spring 捕获不到关键的 RuntimeExpection根据持久层类型选择正确的事务管理器进行配置  MyBatis 采用的是 JDBC 的事务管理器  Hibernate 采用的是 Hibernate 自己的事务管理器  dataSource 是数据源&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;配置声明式事务  默认使用注解管理事务行为，注解也是管理实务的最佳行为&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;通过 @Transactional 指定需要事务管理的方法体  事务注解最好是打到具体的方法体上，如果打到类名上则意味着整个类都需要进行事务控制，多余的事务控制会影响事务的执行时间  方法体中存在增删改操作才需要事务控制  只读操作不需要事务控制@Transactionalpublic void executeSkill() { ... }]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> transaction </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis集成到Spring之生成Session工厂]]></title>
      <url>/java/springmvc/mybatis/2017/03/24/MyBatis%E9%9B%86%E6%88%90%E5%88%B0Spring%E4%B9%8B%E7%94%9F%E6%88%90Session%E5%B7%A5%E5%8E%82/</url>
      <content type="text"><![CDATA[  虽然 Spring 自身没有对 MyBatis 提供支持但 MyBatis 主动对 Spring 进行了整合依赖依赖&lt;dependency&gt;&lt;groupId&gt;org.mybatis&lt;/groupId&gt;&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;&lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;配置  在 Spring 中集成 MyBatis 需要使用 SqlSessionFactoryBean 来生成 MyBatis 所需的 Session 工厂&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;...&lt;/bean&gt;  SqlSessionFactoryBean 实际上并不是真正的 Session 工厂，其经历了如下转换SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();SqlSessionFactory sessionFactory = factoryBean.getObject();属性  指定数据源          该数据源通常引用的是一个数据库连接池的配置项别名      &lt;property name="dataSource" ref="dataSource" /&gt;        MyBatis 全局配置文件          mybatis-config.xml 中的内容是 MyBatis settings 配置表      &lt;property name="configLocation" value="classpath:mybatis-config.xml" /&gt;        自动扫描 Mapper 文件          &lt;property name="mapperLocations" value="classpath:mapper/*Mapper.xml" /&gt;      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis集成到Spring之注入Dao接口]]></title>
      <url>/java/springmvc/mybatis/2017/03/24/MyBatis%E9%9B%86%E6%88%90%E5%88%B0Spring%E4%B9%8B%E6%B3%A8%E5%85%A5Dao%E6%8E%A5%E5%8F%A3/</url>
      <content type="text"><![CDATA[  MyBatis 的 MapperScannerConfigurer 可以将 Dao 接口和 Mapper 文件注入到 Spring 容器中配置&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;...&lt;/bean&gt;属性  指定 Session 工厂          通常情况下系统只会存在一个 DataSource ，这时 MapperScannerConfigurer 会自动装配 Session 工厂，无需手动指定      必须使用 value 注入 Bean 的名称，而不是使用 ref 对 Bean 进行引用      sqlSessionFactory 的实例在 MyBatis 集成到 Spring 之生成 Session 工厂      &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;        指定 Dao 接口的扫描路径          同时指定多个路径只需要通过逗号分隔即可      &lt;property name="basePackage" value="org.seckill.module" /&gt;      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Maven 项目管理器]]></title>
      <url>/java/maven/2017/03/23/Maven-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      <content type="text"><![CDATA[  maven的基础介绍和命令官网Apache Maven介绍  基于对象模型（POM），通过一段描述信息对项目的构建、报告和文档进行管理的软件项目管理工具安装  在终端中运行 brew install maven 即可一键安装结构  bin      存放运行脚本  boot   包含一个类加载器框架  conf    存放配置文件  lib        存放依赖类库命令  查看版本号 mvn -v  编译项目 mvn complie  测试项目 mvn test  打包项目 mvn package  删除项目 target 目录 mvn clean  安装项目 jar 包到本地目录 mvn install  创建项目，按提示输入项目信息 mvn archetype:generate  创建项目，直接指定项目信息 mvn archtype:generate -DgroupId=org.secskill -DartifactId=secskill -Dversion=1.0]]></content>
      <categories>
        
          <category> java </category>
        
          <category> maven </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> maven </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL 新增时忽略重复主键]]></title>
      <url>/database/mysql/2017/03/22/MySQL-%E6%96%B0%E5%A2%9E%E6%97%B6%E5%BF%BD%E7%95%A5%E9%87%8D%E5%A4%8D%E4%B8%BB%E9%94%AE/</url>
      <content type="text"><![CDATA[  在新增数据时，如果主键重复会报错解决  在 INSERT INTO 之间加入 IGNORE 关键字，可以防止报错，数据虽然不会插入成功，但会返回 0INSERT IGNORE INTO (	id,	name)VALUES (	1,	'Tom')]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis的settings配置表]]></title>
      <url>/java/mybatis/2017/03/22/MyBatis%E7%9A%84settings%E9%85%8D%E7%BD%AE%E8%A1%A8/</url>
      <content type="text"><![CDATA[  &lt;settings/&gt; 标签是 MyBatis 中的属性配置项，可以改变 MyBatis 的运行时行为规则  标签中的 value 为该设置的默认值  缓存全局开关          &lt;setting name="cacheEnabled" value="true" /&gt;        延迟加载全局开关          值为 true 时所有对象延迟加载      可通过在具体的查询中设置 fetchType 来覆盖该设置      &lt;setting name="lazyLoadingEnabled" value="false" /&gt;        所有对象直接加载          &lt;setting name="aggressiveLazyLoading" value="true" /&gt;        允许单一语句返回多个结果集，需要兼容驱动          &lt;setting name="multipleResultSetsEnabled" value="true" /&gt;        使用列标签代替类名          &lt;setting name="useColumnLabel" value="true" /&gt;        允许 JDBC 使用数据库自增主键          &lt;setting name="useGeneratedKeys" value="true" /&gt;        指定自动映射到字段的规则          NONE 取消自动映射      PARTIAL 只映射没有定义嵌套结果集映射的结果集      FULL 自动映射任何结果集      &lt;setting name="autoMappingBehavior" value="PARTIAL" /&gt;        指定当自动映射碰到未知列的处理规则          NONE 不做任何处理      WARNING 输入警告日志      FAILING 抛出 SqlSessionException 异常      &lt;setting name="autoMappingUnknownColumnBehavior" value="NONE" /&gt;        配置默认执行器          SIMPLE 普通执行器      REUSE 重用预处理语句      BATCH 重用语句并执行批量更新      &lt;setting name="defaultExecutorType" value="SIMPLE" /&gt;        设置驱动等待数据库响应的超时时间          该设置项默认没有值      值的范围是任意正整数      值的单位是秒      &lt;setting name="defaultStatementTimeout" value="" /&gt;        为驱动的结果集数量设置提示值          该设置项默认没有值      值的范围是任意正整数      可在具体查询中通过 fetchSize 覆盖该设置项      &lt;setting name="defaultFetchSize" value="" /&gt;        允许在嵌套语句中使用分页 RowBounds          &lt;setting name="safeRowBoundsEnabled" value="false" /&gt;        允许在嵌套语句中使用分页 RowHandler          &lt;setting name="safeRowHandlerEnabled" value="true" /&gt;        开启驼峰命令规则自动转换功能          例如：create_time &gt; createTime      &lt;setting name="mapUnderscoreToCameCase" value="false" /&gt;        利用本地缓存机制防止循环引用和加速重复嵌套查询          SESSION 缓存一个会话中执行的所有查询      STATEMENT 本地会员只用在语句执行中，对相同 SqlSession 的不同调用不会共享数据      &lt;setting name="localCacheScope" value="SESSION" /&gt;        当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型          OTHER 一般类型      NULL 空值      VARCHAR 字符串      &lt;setting name="jdbcTypeForNull" value="OTHER" /&gt;        指定某个对象的方法触发一次延迟加载          多个方法名称通过逗号划分      &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString /&gt;"        指定动态 SQL 生成的默认语言          &lt;setting name="defaultScriptingLanguage" value="org.apache.ibatis.scripting.xmltags.XMLLanguageDriver" /&gt;        当结果集为 NULL 时，调用映射对象的 setter 方法为结果赋值          结果集类型是 List 时，调用 setter 方法      结果集类型是 Map 时，调用 put 方法      该属性对于基本类型无效      &lt;setting name="callSetterOnNulls" value="false" /&gt;        当对象所有列都返回 NULL 时，将整个对象设置为 NULL          &lt;setting name="returnInstanceForEmptyRow" value="false" /&gt;        指定日志名称的前缀          该设置项没有默认值      值可以是任何字符串      &lt;setting name="logPrefix" value="" /&gt;        指定日志的具体实现方式          该设置项没有默认值      值可以是 slf4j / log4j / log4j2 / jdk_logging / commons_logging / stdout_logging / no_loggging      未指定值的时候会在上述支持列表中自动查找      &lt;setting name="logImpl" value="" /&gt;        指定创建具有延迟加载能力的对象所用到的代理工具          值可以是 CGLIB / JAVASSIST      &lt;setting name="proxyFactory" value="JAVASSIST" /&gt;        指定 VFS 的实现          该设置项没有默认值      值可以是自定义 VFS 的实现类全名      多个 VFS 可以通过逗号划分      &lt;setting name="vfsImpl" value="" /&gt;        允许使用方法签名中的名称作为语句参数名称          仅在 Java 8 环境中生效，并且需要在环境变量中加上 -parameters      &lt;setting name="useActualParamName" value="true" /&gt;      完整配置示例&lt;settings&gt;  &lt;setting name="cacheEnabled" value="true"/&gt;  &lt;setting name="lazyLoadingEnabled" value="true"/&gt;  &lt;setting name="multipleResultSetsEnabled" value="true"/&gt;  &lt;setting name="useColumnLabel" value="true"/&gt;  &lt;setting name="useGeneratedKeys" value="false"/&gt;  &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt;  &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt;  &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt;  &lt;setting name="defaultStatementTimeout" value="25"/&gt;  &lt;setting name="defaultFetchSize" value="100"/&gt;  &lt;setting name="safeRowBoundsEnabled" value="false"/&gt;  &lt;setting name="mapUnderscoreToCamelCase" value="false"/&gt;  &lt;setting name="localCacheScope" value="SESSION"/&gt;  &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt;  &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt;&lt;/settings&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL 新增或更新]]></title>
      <url>/database/mysql/2017/03/19/MySQL-%E6%96%B0%E5%A2%9E%E6%88%96%E6%9B%B4%E6%96%B0/</url>
      <content type="text"><![CDATA[  根据 id 决定是执行新增操作还是更新操作实现方式INSERT INTO pt_member_course (	id,	learnDuration)VALUES (	#{id},	#{learnDuration})ON DUPLICATE KEY UPDATE	learnDuration = #{learnDuration}]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IntelliJ IDEA 修改类注释模版]]></title>
      <url>/software/idea/2017/03/19/IntelliJ-IDEA-%E4%BF%AE%E6%94%B9%E7%B1%BB%E6%B3%A8%E9%87%8A%E6%A8%A1%E7%89%88/</url>
      <content type="text"><![CDATA[  创建 Java 类时在文件顶栏自动生成的注释内容实现方式]]></content>
      <categories>
        
          <category> software </category>
        
          <category> idea </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> idea </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS滚动条上下边距]]></title>
      <url>/css/2017/03/09/CSS%E6%BB%9A%E5%8A%A8%E6%9D%A1%E4%B8%8A%E4%B8%8B%E8%BE%B9%E8%B7%9D/</url>
      <content type="text"><![CDATA[  父容器设置了内边距，但在内容滚动时，设置了内边距的位置依旧会出现内容解决  上下边距使用外边距  左右边距使用内边距]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
          <tag> padding </tag>
        
          <tag> margin </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iframe沙箱模式]]></title>
      <url>/html/iframe/2017/03/07/iframe%E6%B2%99%E7%AE%B1%E6%A8%A1%E5%BC%8F/</url>
      <content type="text"><![CDATA[  iframe中存在一个sandbox属性可以实现沙箱模式，通过给这个属性设值，可以限制iframe中能进行的操作，从而不影响父窗口的运行属性  allow-same-orign 允许将内容作为普通来源对待，否则会被设为来自一个独立的源  allow-top-navigation 允许包含文档导航内容  allow-forms 允许表单提交  allow-scripts 允许脚本执行  allow-modals 允许模态窗口  allow-orientation-lock 允许锁定父窗口屏幕方向  allow-pointer-lock 允许使用指针锁API  allow-popups 允许弹出窗口  allow-popups-to-escape-sandbox 允许弹出沙箱窗口  allow-presentation 允许控制session  ”“ 允许上述所有规则，默认语法&lt;iframe sandbox="allow-scripts allow-same-origin allow-popups"&gt;&lt;/iframe&gt;]]></content>
      <categories>
        
          <category> html </category>
        
          <category> iframe </category>
        
      </categories>
      <tags>
        
          <tag> html </tag>
        
          <tag> iframe </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery.wrap()动态添加父元素]]></title>
      <url>/jquery/2017/02/28/jQuery.wrap()%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E7%88%B6%E5%85%83%E7%B4%A0/</url>
      <content type="text"><![CDATA[  通过 wrap() 实现动态添加父元素直接添加父元素$(".inner").wrap("&lt;div class='new'&gt;&lt;/div&gt;");添加父元素的同时执行一个方法$(".inner").wrap(function () {    return "&lt;a class='fancybox' rel='group' href='" + $(this).attr("src") + "'&gt;&lt;/a&gt;"});]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Fancybox 图片查看器]]></title>
      <url>/jquery/2017/02/28/Fancybox-%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8/</url>
      <content type="text"><![CDATA[  快捷图片查看插件官网fancyBox - Fancy jQuery Lightbox Alternative在页面中添加插件所需要的js/css文件&lt;script type="text/javascript" src="${ctx }/assets/plugins/jquery-1.11.1.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="${ctx }/assets/plugins/fancybox/js/jquery.fancybox.pack.js"&gt;&lt;/script&gt;&lt;link href="${ctx }/assets/plugins/fancybox/css/jquery.fancybox.css" rel="stylesheet" type="text/css" media="screen"&gt;在需要查看的img标签外添加一个a标签&lt;a class="fancybox" rel="group" href="image1.jpg"&gt;	&lt;img src="image1.jpg" /&gt;&lt;/a&gt;初始化插件$(".fancybox").fancybox();API  padding          图片距离弹出框的距离      整数或数组      整数表示四个方向的内边距都为该整数      数组则表示各个方向不同的值 [top, right, bottom, left]      默认值：15        margin          弹出框距离浏览器四个方向的距离      整数或数组      整数表示距离四个方向的距离都为该整数      数组则表示各个方向不同的值 [top, right, bottom, left]      默认值：20        width          当auotoSize=false时弹出框的宽度      仅适用于 iframe、swf、inline、ajax和html模式      数字或 auto      默认值：800        height          当auotoSize=false时弹出框的高度      仅适用于 iframe、swf、inline、ajax和html模式      数字或 auto      默认值：600        minWidth          弹出框的最小宽度      数字      默认值：100        minHeight          弹出框的最小高度      数字      默认值：100        maxWidth          弹出框的最大宽度      数字      默认值：9999        maxHeight          弹出框的最大高度      数字      默认值：9999        autoSize          自动尺寸      如果设置为true，则要设置autoHeight和autoWidth为true      true或false      默认值：true        autoHeight          自动调整高度      如果设置为true，那么ajax、inline、html模式下的弹出框将自动调整高度      true或false      默认值：false        autoWidth          自动调整宽度      如果设置为true，那么ajax、inline、html模式下的弹出框将自动调整宽度      true或false      默认值：false        autoResize          自动调整尺寸      设置为true，当浏览器窗口大小改变的时候将自动调整弹出框大小      布尔值      默认值：!isTouch        autoCenter          自动居中      如果设置为true，那么弹出框总是居中的      布尔值      默认值：!isTouch        fitToView          如果设置为true，弹出框将会在打开之前自动适应大小      布尔值      默认值：true        aspectRatio          如果设置为true，那么重置大小将会被图片的比例所影响      布尔值      默认值：false        topRatio          弹出框距离顶部与距离底部的比例      如果为0.5，则表示居中      数字      默认值：0.5        leftRatio          弹出框距离左边与距离右边的比例      如果为0.5，则表示居中      数字      默认值：0.5        scrolling          添加到scrollbars滚动条上的样式      auto_yes_no/visible      默认值：auto        wrapCSS          环绕元素的样式      字符串        arrows          如果设置为true，导航箭头将会被显示      布尔值      默认值：true        closeBtn          如果设置为true，将会显示关闭图标      布尔值      默认值：true        closeClick          如果设置为true，当用户点击内容的时候将会关闭弹出框      布尔值      默认值：false        nextClick          如果设置为true，当用户点击内容的时候将会导航到下一页      布尔值      默认值：false        mouseWheel          是否启用鼠标滚动切换      布尔值      默认值：true        autoPlay          是否自动播放弹出框的图片      布尔值      默认值：false        playSpeed          播放毫秒速度      数字      默认值：3000        preload          预加载的图片数      数字      默认值：3        modal          如果设置为true，将会禁止导航和关闭      布尔值      默认值：false        loop          是否循环播放      布尔值      默认值：true        scrollOutside          如果设置为true，将会视图避免垂直方向的滚动条，针对 iframe和html      布尔值      默认值：true        index          重写开始的图片索引      数字      默认值：0        type          重写内容的类型      image_inline_ajax_iframe_swf/html      默认值：null        href          重写内容的链接地址      字符串      默认值：null        content          重写被展示的内容      字符串      默认值：null        title          重写标题      字符串      默认值：null      ]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Tomcat连接池配置]]></title>
      <url>/tomcat/2017/02/18/Tomcat%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  Tomcat 连接池配置方式在tomcat的 /conf/server.xml 中配置连接池信息&lt;Resource      name="jdbc/htsDB"      auth="Container"     factory="org.apache.naming.factory.BeanFactory"      type="com.mchange.v2.c3p0.ComboPooledDataSource"     driverClass="com.mysql.jdbc.Driver"     idleConnectionTestPeriod="60"     maxPoolSize="50"     minPoolSize="2"     maxStatements="0"     acquireIncrement="2"      user="root"     password="qazpl,"     jdbcUrl="jdbc:mysql://192.168.7.11:3306/hts_dev?useUnicode=true&amp;amp;characterEncoding=utf-8"/&gt;在tomcat的 /conf/context.xml 中指定连接池别名&lt;ResourceLink global="jdbc/htsDB" name="jdbc/htsDB" type="javax.sql.DataSource"/&gt;  在项目的数据库配置文件中指定连接池&lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;    &lt;property name="jndiName"&gt;        &lt;value&gt;java:comp/env/jdbc/htsDB&lt;/value&gt;    &lt;/property&gt;&lt;/bean&gt;]]></content>
      <categories>
        
          <category> tomcat </category>
        
      </categories>
      <tags>
        
          <tag> tomcat </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis防止死循环]]></title>
      <url>/java/mybatis/error/2017/02/18/MyBatis%E9%98%B2%E6%AD%A2%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
      <content type="text"><![CDATA[  mybatis的mapper文件中如果存在错误，会导致项目启动时加载mapper进入死循环，却不输出错误重新buildSqlSessionFactory()  重写org.mybatis.spring.SqlSessionFactoryBean的buildSqlSessionFactory()方法public class FixedSqlSessionFactory extends SqlSessionFactoryBean {    @Override    protected SqlSessionFactory buildSqlSessionFactory() throws IOException {        try {            return super.buildSqlSessionFactory();        }catch (Exception e){            e.printStackTrace();        }finally {            ErrorContext.instance().reset();        }        return null;    }}修改配置文件中的引用为上述包装类&lt;bean id="sqlSessionFactory" class="com.innovaee.hts.sop.web.FixedSqlSessionFactory"&gt;    &lt;property name="dataSource" ref="dataSource"/&gt;    ...&lt;/bean&gt;启动项目，则会在控制台输出具体错误信息]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Tomcat防止内存溢出]]></title>
      <url>/tomcat/2017/02/17/Tomcat%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
      <content type="text"><![CDATA[  JDK8 版本之前在 IDE 中使用 Tomcat ，如果项目占用内存过大， 可能会导致内存溢出，从而 Tomcat 崩溃解决方式-server -Xms512m -Xmx512m -XX:PermSize=64M -XX:MaxPermSize=128m]]></content>
      <categories>
        
          <category> tomcat </category>
        
      </categories>
      <tags>
        
          <tag> tomcat </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Jenv管理多个Java版本]]></title>
      <url>/homebrew/2017/02/17/Jenv%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAJava%E7%89%88%E6%9C%AC/</url>
      <content type="text"><![CDATA[  通过 homebrew 安装 jenv ，jenv是多版本 JDK 管理工具官网  jEnv - Manage your Java environment前提  安装 Homebrew套件管理器在终端中输入brew install jenv配置环境变量echo 'export PATH="$HOME/.jenv/bin:$PATH"' &gt;&gt; ~/.bash_profileecho 'eval "$(jenv init -)"' &gt;&gt; ~/.bash_profile添加JDKjenv add /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home oracle64-1.6.0.39 added查看JDK版本列表jenv versions更改全局版本jenv global oracle64-1.6.0.39]]></content>
      <categories>
        
          <category> homebrew </category>
        
      </categories>
      <tags>
        
          <tag> homebrew </tag>
        
          <tag> jenv </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Homebrew套件管理器]]></title>
      <url>/software/homebrew/2017/02/17/Homebrew%E5%A5%97%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      <content type="text"><![CDATA[  Mac 上快速安装软件的脚本工具官网Homebrew — macOS 不可或缺的套件管理器安装  在终端中输入如下脚本`/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"`插件  安装 brew install git  安装路径默认为 _usr_local/Cellar  更新 brew upgrade git  卸载 brew uninstall git  搜索 brew search /git/  显示已安装列表brew list  更新所有 brew update  查看是否存在更新 brew outdated应用  安装 brew cask install java  其他操作与安装插件无异，只是中间多了一个cask参数]]></content>
      <categories>
        
          <category> software </category>
        
          <category> homebrew </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> homebrew </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate枚举映射策略]]></title>
      <url>/java/hibernate/2017/02/15/Hibernate%E6%9E%9A%E4%B8%BE%E6%98%A0%E5%B0%84%E7%AD%96%E7%95%A5/</url>
      <content type="text"><![CDATA[  稍微解释一下Hibernate枚举策略枚举类型映射到数据库的方式  int，即获取枚举的索引值存入数据库，从0开始  String，即获取枚举的name属性存入数据库Hibernate默认把枚举类型的字段当做基本类型(int)的字段来映射  可以通过注解的方式进行控制          @Enumerated(EnumType.ORDINAL)  默认方式，int型      @Enumerated(EnumType.STRING)  String型，会获取枚举的name属性      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
          <tag> enum </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java支付宝扫码支付[旧]]]></title>
      <url>/java/pay/2017/02/14/Java%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98-%E6%97%A7/</url>
      <content type="text"><![CDATA[  在实际开发过程中，首先采用当面付模式进行开发，但没有成功，个人认为当面付更适合线下模式之后改用即时到账模式才成功接入支付宝扫码支付功能以下内容是基于即时到账模式开发要使用支付宝即时到账接口，首先需要签约即时到账产品， 申请地址审核进度通常需要1个工作日，但实际几小时即可之后需要获取和设置如下关键信息pid:2088621150311111          合作伙伴身份IDkey:zrqyf6dfli7dvji4mmi4sw1111111111      MD5密钥notify_url:http://127.0.0.1:8080/sop/order/notify/ali    异步通知回调地址return_url:http://127.0.0.1:8080/sop/order/notify/ali/return  同步通知回调地址官网支付宝-开放平台模式  当面付 ，消费者扫描商户二维码完成支付。并不适用于Web网页端扫码支付  即时到账 ，用户在线向开发者的支付宝账号支付资金。Web网页端扫码支付首选开发步骤  下载支付宝提供的即时到账 DEMO          按下图所示将alipay下所有文件复制到项目开发目录，支付宝已将接口的调用、请求、验签等操作完成，我们只需要包装好数据后调用即可        打开AlipayConfig.java，将其中关键信息替换成之前准备好的内容          除了下述四个信息，其他内容均不需要修改      ** partner**即pid，key即md5密钥，都可以在 mapi网关产品密钥 获取      notify_url是支付宝异步通知链接，由支付宝主动调用，一旦用户完成支付，即调用该地址      不可添加自定义参数      必须保证外网可正常访问      使用POST方式发送/接收数据      没有时间限制      如果是https，则必须安装ssl证书，并且需要正规的证书机构签发，自签名的无法识别      return_url，是支付宝同步跳转通知，用户完成支付后，在支付页面完成跳转      不可添加自定义参数      必须保证外网可正常访问，但可在本机测试      使用GET方式发送/接收数据      一分钟超时      // 合作身份者ID，签约账号，以2088开头由16位纯数字组成的字符串，查看地址：https://b.alipay.com/order/pidAndKey.htmpublic static String partner = SOPConstants.ALI_PAY_PARTNER_ID; // MD5密钥，安全检验码，由数字和字母组成的32位字符串，查看地址：https://b.alipay.com/order/pidAndKey.htmpublic static String key = SOPConstants.ALI_PAY_MD5_KEY;// 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问public static String notify_url = SOPConstants.ALI_PAY_NOTIFY_URL;// 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问public static String return_url = SOPConstants.ALI_PAY_RETURN_URL;  在订单支付页面创建一个空的div，用于接收调用即时到账接口返回的表单数据$.ts.doAction("/api/order/pay/ali", {    orderId: orderId}, function () {    // 提交表单内容    $orderSubmitPanel.find("#returnAli").append(this.data);   // 打开订单状态轮询页面，确保支付完成后，支付页面能自动跳转    $.ts.openModalWindow("/api/order/pay/ali/tip/" + orderId, 350, 300);}, "", "", "");@RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic ResponseData ali(HttpServletRequest request, @RequestParam("orderId") final String orderId) {    SimpleActionHandler actionHandler = new SimpleActionHandler(request) {        @Override        protected void doHandle(ResponseData responseData) throws Exception {            responseData.setData(orderPayService.aliPay(IdEncoder.decodeId(orderId)));        }    };    return actionHandler.handle();}  按照 请求参数说明 包装请求参数，并建立请求          建立请求的操作支付宝已在AlipaySubmit.java中实现，只需要调用其中buildRequest()方法并传入参数即可      public String aliPay(Long orderId) {    // 获取订单信息    OrderDTO order = orderManageService.getOrder(orderId);    // 包装请求参数    Map&lt;String, String&gt; params = Maps.newHashMap();    // 调用接口    params.put("service", AlipayConfig.service);    // 签约账号id    params.put("partner", AlipayConfig.partner);    // 收款支付账号，默认与签约账号相同    params.put("seller_id", AlipayConfig.seller_id);    // 编码格式，支付GBK和UTF-8    params.put("_input_charset", AlipayConfig.input_charset);    // 支付类型    params.put("payment_type", AlipayConfig.payment_type);    // 异步通知回调地址    params.put("notify_url", AlipayConfig.notify_url);    // 同步通知跳转地址    params.put("return_url", AlipayConfig.return_url);    // 防钓鱼时间戳    params.put("anti_phishing_key", AlipayConfig.anti_phishing_key);    // 客户端IP    params.put("exter_invoke_ip", super.getClientIP());    // 订单号    params.put("out_trade_no", order.getCode());    // 标题    params.put("subject", "轻实训-" + order.getName());    // 金额    params.put("total_fee", String.valueOf(order.getPrice()));    // 建立请求    return AlipaySubmit.buildRequest(params, "get", "确认");}  由于调用即时到账接口返回的表单数据会自动提交，而接收表单数据的div是在订单提交页面，因此按照表单提交默认方式，会导致订单提交页面被替换成支付宝扫码页面  所以需要修改AlipaySubmit.java中的buildRequest()方法，在其拼接的表单中加入target=“_blank”，让表单提交时在新页面打开public static String buildRequest(Map&lt;String, String&gt; sParaTemp, String strMethod, String strButtonName) {    //待请求参数数组    Map&lt;String, String&gt; sPara = buildRequestPara(sParaTemp);    List&lt;String&gt; keys = new ArrayList&lt;String&gt;(sPara.keySet());    StringBuffer sbHtml = new StringBuffer();    sbHtml.append("&lt;form id=\"alipaysubmit\" name=\"alipaysubmit\" action=\"" + ALIPAY_GATEWAY_NEW                  + "_input_charset=" + AlipayConfig.input_charset + "\" method=\"" + strMethod                  + "\" target=\"_blank\"&gt;");    for (int i = 0; i &lt; keys.size(); i++) {        String name = (String) keys.get(i);        String value = (String) sPara.get(name);        sbHtml.append("&lt;input type=\"hidden\" name=\"" + name + "\" value=\"" + value + "\"/&gt;");    }    //submit按钮控件请不要含有name属性    sbHtml.append("&lt;input type=\"submit\" value=\"" + strButtonName + "\" style=\"display:none;\"&gt;&lt;/form&gt;");    sbHtml.append("&lt;script&gt;document.forms['alipaysubmit'].submit();&lt;/script&gt;");    return sbHtml.toString();}  用户通过支付宝扫描二维码完成支付后，支付宝会主动调用notify_url进行回执          由于回执时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该回执地址一个访问许可，否则会被安全框架屏蔽      @RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic String aliNotify(HttpServletRequest request) {    return orderPayService.aliNotify(request);}  接收并处理支付回执后，必须通知支付宝回执接收成功，否则支付宝会认为回执发送失败，并发送数次通知  支付宝发送异步通知后，如果没有获取到成功回执（返回success），则会按一定规律重发（4m,10m,10m,1h,2h,6h,15h）  接收支付宝的回执信息时，必须进行验签，改操作支付宝已实现，我们只需要调用AlipayNotify.java中的verify()方法即可  验签成功后需要判断操作状态，从回执参数中获取trade_status，参数值为TRADE_SUCCESS即为支付成功  还有一个订单状态是TRADE_FINISHED，该状态表示订单已完成，即超过三个月的退款期限，一旦订单到达这个状态，支付宝会再次调用notify_url进行回执，若业务系统没有退款流程，则无需处理该状态public String aliNotify(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 交易状态    String tradeStatus = request.getParameter("trade_status");    // 验签    if (AlipayNotify.verify(getNotifyData(request))) {        // 交易成功        if (tradeStatus.equals("TRADE_SUCCESS")) {            // 更新订单信息            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());        }        return "success";    } else {        return "fail";    }}  处理回执内容，用于验签private Map&lt;String, String&gt; getNotifyData(HttpServletRequest request, String method) throws Exception {    // 获取回执内容    Map requestParams = request.getParameterMap();    // 过滤回执内容    Map&lt;String, String&gt; params = Maps.newHashMap();    for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) {        String name = (String) iter.next();        String[] values = (String[]) requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        if (method.equals("notify")) {            params.put(name, valueStr);        } else {            params.put(name, new String(valueStr.getBytes("ISO-8859-1"), "utf-8"));        }    }    return params;}  用户通过支付宝扫描二维码完成支付后，在新打开的支付宝窗口会执行return_url进行跳转          由于跳转时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该跳转地址一个访问许可，否则会被安全框架屏蔽      public String aliReturn(HttpServletResponse response, HttpServletRequest request) throws Exception {    orderPayService.aliReturn(response, request);           // 跳转地址会通过输出流的方式关闭新窗口，所以无需返回任何内容    return null;}  接收跳转通知时，同样需要验签，以确保内容的安全性  为防止网络等不可预测原因导致异步回执没能成功接收，所以在接收跳转通知并验签通过以及状态判断成功后，同样需要对订单状态进行更新  如果用户完成支付后立即关闭页面，会导致同步跳转通知无法执行，所以不能完全依赖该通知确认订单状态  如果用户在支付页面扫码生成预下单订单，但并未直接付款，而是前往支付宝订单页重新付款，即使网页端支付页面未关闭，也无法执行该同步跳转通知  通过同步跳转通知更新订单状态，只是一种辅助措施，主要手段还是通过接受异步回执来处理订单状态  由于支付宝的扫码页面是在新窗口打开，在支付完成后并没有存在的必要，即可以通过输出流的方式关闭该窗口public void aliReturn(HttpServletResponse response, HttpServletRequest request) throws IOException {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 交易状态    String tradeStatus = request.getParameter("trade_status");    // 验签    if (AlipayNotify.verify(getNotifyData(request))) {        if (tradeStatus.equals("TRADE_FINISHED") || tradeStatus.equals("TRADE_SUCCESS")) {            // 更新订单信息            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());            // 页面跳转            response.setContentType("text/html;charset=gb2312");     // 通过输出流关闭窗口            PrintWriter writer = response.getWriter();            writer.println("&lt;html&gt;&lt;head&gt;&lt;title&gt; CLOSE &lt;/title&gt;&lt;/head&gt;");            writer.println("&lt;body&gt;");            writer.println("&lt;script type=\"text/javascript\"&gt;window.close();&lt;/script&gt;");            writer.println("&lt;/body&gt;&lt;/html&gt;");        }    }}  轮询订单状态，实现支付完成后页面自动跳转          由于支付回执是异步的，所以即使捕获到异步回执也无法实现支付页面的自动跳转      所以需要在支付页面打开时设置一个ajax轮询订单状态，一旦订单状态更新，则进行页面跳转      // 页面关闭$(“.modal-header button.close:last”).click(function () {    // 停止轮询    clearInterval(checkTimer);});// 轮询订单状态checkTimer = setInterval(function () {    // 窗口是否打开    if ($(“.order-pay-panel”).length &lt;= 0) {        clearInterval(checkTimer);    }    // 获取订单状态    $.ts.doAction(“/api/order/review/check/“, {        orderId: orderId    }, function () {        // 订单已支付        if (!this.data) {            $.ts.closeWindow();            g_index.loadMainContentWithState(“/order/manage”);        $.ts.toastr.success(“订单已支付成功！”);        }    }, “”, “”, “”);}, 3000);]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Form表单提交时打开新窗口]]></title>
      <url>/html/iframe/2017/02/13/Form%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%97%B6%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3/</url>
      <content type="text"><![CDATA[  关键在于添加target=“_blank”属性，会使得表单提交时在新窗口打开页面实现方式&lt;form target="_blank" method="get" action="#"&gt;&lt;/form&gt;]]></content>
      <categories>
        
          <category> html </category>
        
          <category> iframe </category>
        
      </categories>
      <tags>
        
          <tag> html </tag>
        
          <tag> iframe </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SecureCRT中文乱码]]></title>
      <url>/software/secure/2017/02/11/SecureCRT%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      <content type="text"><![CDATA[  解决SecureCRT显示内容出现中文乱码的问题解决方式  进入 Global Options 界面  点击 Edit Default Setting ，进入 Session Options - Default 界面  选择 Appearance 菜单，将 Character encoding 设置为 UTF-8  点击 OK ，并全局应用]]></content>
      <categories>
        
          <category> software </category>
        
          <category> secure </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> secure </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java微信扫码支付]]></title>
      <url>/java/pay/2017/02/11/Java%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/</url>
      <content type="text"><![CDATA[  以下内容是基于模式二开发在开发之前需要先到微信支付官网注册账号，并获取到以下信息appid:wx1137939101111111公众账号idmch_id:1438111111 商户号key:4Inn0va1eSxOnl1neqsxwuhan1111111密钥send_url:https://api.mch.weixin.qq.com/pay/unifiedorder统一下单APInotify_url:http://127.0.0.1:8080/sop/order/notify/wechat支付成功回调地址官网  微信支付官网  扫码支付开发者文档模式  需要在公众平台后台设置支付回调URL ，用于接收用户扫码后微信支付系统回调的productid和openid  直接调用统一下单API 即可，相对于模式一更为简洁定义接口对象  根据 统一下单接口API 定义四个对象，用于发送和接收数据UnifiedOrderRequest.java 统一下单请求参数-必填项public class UnifiedOrderRequest {    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 随机字符串，32位以内    private String nonce_str;    // 签名，遵循签名算法    private String sign;    // 商品描述，浏览器打开的网站主页title名称-商品概述    private String body;    // 商户订单号，32位以内，不重复    private String out_trade_no;    // 标价金额，单位分    private Integer total_fee;    // 终端ip，填写调用端的ip    private String spbill_create_ip;    // 通知地址，接收支付结果的会掉地址，必须外网可访问    private String notify_url;    // 交易类型，JSAPI--公众号支付、NATIVE--原生扫码支付、APP--app支付    private String trade_type;}UnifiedOrderRequestExt.java 统一下单请求参数-非必填项public class UnifiedOrderRequestExt extends UnifiedOrderRequest {    // 设备号，网页端填写WEB    private String device_info;    // 签名类型，默认MD5    private String sign_type;    // 商品详情，JSON格式    private String detail;    // 附加数据，可作为自定义参数使用    private String attach;    // 标价币种，默认CNY    private String fee_type;    // 交易起始时间，格式为yyyyMMddHHmmss    private String time_start;    // 交易结束时间，最短失效时间必须间隔5分钟    private String time_expire;    // 商品id，trade_type=NATIVE时，必填    private String product_id;    // 指定支付方式，no_credit可限制使用信用卡    private String limit_pay;    // 用户标识,trade_type=JSAPI时，必填    private String openid;}UnifiedOrderResponse.java 统一下单返回参数-必填项public class UnifiedOrderResponse {    // 返回状态码，通信标识，SUCCESS/FAIL    private String return_code;    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 随机字符串    private String nonce_str;    // 签名    private String sign;    // 业务结果，交易标识，SUCCESS/FAIL    private String result_code;    // 交易类型，JSAPI，NATIVE，APP    private String trade_type;    // 预支付交易会话标识，有效值2小时    private String prepay_id;}UnifiedOrderResponseExt.java 统一下单返回参数-非必填项public class UnifiedOrderResponseExt extends UnifiedOrderResponse {    // 返回信息，非空则表示返回了错误信息    private String return_msg;    // 设备号    private String device_info;    // 错误代码    private String err_code;    // 错误代码描述    private String err_code_des;    // 二维码连接，trade_type=NATIVE时返回    private String code_url;}定义一个标签用于显示二维码  调用统一下单API成功后，会返回一系列XML数据，其中code_url表示返回的预支付交易链接，可将其生成二维码图片&lt;div class="order-pay-panel order-wechat-panel"&gt;    &lt;div class="modal-header"&gt;        &lt;button type="button" class="close" data-dismiss="modal" aria-hidden="true"&gt;×&lt;/button&gt;        &lt;h4 class="modal-title"&gt;            &lt;i class="icon-th-large"&gt;&lt;/i&gt; 微信支付        &lt;/h4&gt;    &lt;/div&gt;    &lt;div class="modal-body"&gt;        &lt;div class="wechat-qrcode-panel margin-bottom-10"&gt;            &lt;img src="${ctx}/api/order/pay/wechat/qrcode?orderId=${order.hexId}"&gt;        &lt;/div&gt;        &lt;div class="wechat-description-panel"&gt;            &lt;p class="text-muted"&gt;使用微信扫描二维码完成支付&lt;/p&gt;            &lt;p class="text-danger"&gt;￥${order.price}&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;根据统一下单API的要求生成订单  将系统内部订单号传入请求参数的out_trade_no中，用于后续操作的唯一标识符  请求参数中的sign是验证参数合法性的唯一标识，需要根据 微信支付签名算法 来生成  使用XStream将对象转换为XML，由于微信的请求参数中大量使用下划线，但下划线在XStream中是关键字，因此需要把下划线转换为双下划线，避免报错private String generateOrderInfo(Long orderId) throws Exception {    // 获取订单信息    OrderDTO order = orderManageService.getOrder(orderId);    // 生成订单    UnifiedOrderRequestExt ext = new UnifiedOrderRequestExt();    ext.setAppid(SOPConstants.WECHAT_PAY_APP_ID);    ext.setMch_id(SOPConstants.WECHAT_PAY_MCH_ID);    ext.setBody("轻实训-" + order.getName());    ext.setOut_trade_no(order.getCode());    ext.setTotal_fee(order.getPrice() * 100);    ext.setSpbill_create_ip(super.getClientIP());    ext.setNotify_url(SOPConstants.WECHAT_PAY_NOTIFY_URL);    ext.setTrade_type("NATIVE");    ext.setProduct_id(order.getHexId());  // 生成32位随机数    ext.setNonce_str(makeNonceStr());  // 签名，按照指定签名算法生成    ext.setSign(makeSign(ext));    // 格式转换为XML    XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));    xStream.alias("xml", UnifiedOrderRequestExt.class);    return xStream.toXML(ext);}  生成32位随机数，方式为当前时间加随机数private String makeNonceStr() {    StringBuffer str = new StringBuffer(DateUtil.getSysDateString("yyyyMMddHHmmssS"));    str.append((new Random().nextInt(900) + 100));    return str.toString();}  拼接签名数据private String makeSign(UnifiedOrderRequestExt ext) throws Exception {    // 根据规则创建可排序的map集合    SortedMap&lt;String, String&gt; signMaps = Maps.newTreeMap();    signMaps.put("appid", ext.getAppid());    signMaps.put("body", ext.getBody());    signMaps.put("mch_id", ext.getMch_id());    signMaps.put("nonce_str", ext.getNonce_str());    signMaps.put("notify_url", ext.getNotify_url());    signMaps.put("out_trade_no", ext.getOut_trade_no());    signMaps.put("spbill_create_ip", ext.getSpbill_create_ip());    signMaps.put("trade_type", ext.getTrade_type());    signMaps.put("total_fee", ext.getTotal_fee().toString());    signMaps.put("product_id", ext.getProduct_id());    // 生成签名    return generateSign(signMaps);}  按照签名算法生成签名private String generateSign(SortedMap&lt;String, String&gt; signMaps) throws Exception {    StringBuffer sb = new StringBuffer();    // 字典序    for (Map.Entry signMap : signMaps.entrySet()) {        String key = (String) signMap.getKey();        String value = (String) signMap.getValue();        // 为空不参与签名、参数名区分大小写        if (null != value &amp;&amp; !"".equals(value) &amp;&amp; !"sign".equals(key) &amp;&amp; !"key".equals(key)) {            sb.append(key + "=" + value + "&amp;");        }    }    // 拼接key    sb.append("key=" + SOPConstants.WECHAT_PAY_KEY);    // MD5加密    return encoderByMd5(sb.toString()).toUpperCase();}调用统一下单API  将生成的订单发送给微信，同时接收微信的返回参数，读取其中的code_url  如果发送的订单信息不符合要求，则会在返回参数中告知问题  订单合法，返回参数中return_code=SUCCESS return_msg=OK result_code=SUCCESS  订单不合法，返回参数中return_code=FAIL return_msg=具体错误原因private String sendHttpRequest(String orderInfo) throws IOException {    // 建立连接    HttpURLConnection conn = (HttpURLConnection) new URL(SOPConstants.WECHAT_PAY_SEND_URL).openConnection();    conn.setRequestMethod("POST");    conn.setDoOutput(true);    // 发送数据    BufferedOutputStream bos = new BufferedOutputStream(conn.getOutputStream());    bos.write(orderInfo.getBytes());    bos.flush();    bos.close();    // 获取数据    BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));    // 接收数据    String line;    StringBuffer str = new StringBuffer();    while ((line = reader.readLine()) != null) {        str.append(line);    }    // XML数据转换为对象    XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));    xStream.alias("xml", UnifiedOrderResponseExt.class);    UnifiedOrderResponseExt ext = (UnifiedOrderResponseExt) xStream.fromXML(str.toString());    // 判断数据有效性    if (null != ext &amp;&amp; "SUCCESS".equals(ext.getReturn_code()) &amp;&amp; "SUCCESS".equals(ext.getResult_code())) {        return ext.getCode_url();    }    return null;}根据返回的code_url生成二维码图片  二维码的生成采用的是Google的 GitHub - zxing/zxing at zxing-3.0.0@RequestMapping(value = “/wechat/qrcode”, method = RequestMethod.GET)public void wechatQRCode(HttpServletResponse response, @RequestParam("orderId") String orderId) {    try {        // 初始化数据        int width = 240;        int height = 240;        String format = "png";  // 获取二维码链接        String codeUrl = orderPayService.getQRCodeUrl(IdEncoder.decodeId(orderId));        Hashtable htable = new Hashtable();        htable.put(EncodeHintType.CHARACTER_SET, "UTF-8");        // 生成图片        BitMatrix matrix = new MultiFormatWriter().encode(codeUrl, BarcodeFormat.QR_CODE, width, height, htable);        OutputStream out = response.getOutputStream();        // 输出图片        MatrixToImageWriter.writeToStream(matrix, format, out);        out.flush();        out.close();    } catch (Exception e) {        logger.error(e.getMessage(), e);    }}  需要准备的包信息&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;core&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;javase&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;接收回调  用户通过微信扫描二维码并支付成功后，微信会根据之前订单中的notify_url回调地址进行回执  此处提供给微信的回调地址必须是外网可访问的，否则无法正常接收回执信息  由于回执时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该回执地址一个访问许可，否则会被安全框架屏蔽  发送回执是异步进行，由于网络等不确定因素，微信不保证回执一定成功  微信会通过一定的策略定期重启发送通知，通知频率为15/15/30/180/1800/1800/1800/1800/3600，单位：秒  虽然是异步回执，但并不需要采用ajax异步接收的方式来接收数据@RequestMapping(value = "/wechat")public String wechatNotify(HttpServletResponse response, HttpServletRequest request) throws Exception {    orderPayService.notify(response, request);  // 此处的返回值无效，需要在支付页面通过轮询获取支付结果，微信支付本身无法实现自动跳转    return "/redirect:/login";}处理回执内容  数据是通过IO流发送，所以也需要通过IO流接收  微信发送回执用户接收后，需要通过IO流的方式告知微信接收成功，否则微信认为回执失败  接收到回执信息后，最关键是验证签名来确保信息的有效性和安全性，验签的方式和发送订单签名的方式一致  验签成功，且回执信息中result_code=SUCCESS，则表示回执信息有效  从回执信息中可获取到out_trade_no，这是之前发送的用户订单唯一标识符，通过该信息可以继续处理用户订单  所有流程处理完毕后，必须以XML格式编写回执信息，并通过IO流的方式告知微信回执接收成功public void notify(HttpServletResponse response, HttpServletRequest request) throws Exception {    // 读取回执数据    HashMap&lt;String, String&gt; notifyMaps = readNotify(request);    // 回执数据验证    if (notifyMaps == null || notifyMaps.isEmpty()) {        logger.error("未收到回执数据！");        throw new TSharkException("未收到回执数据！");    }    // 挑选数据    SortedMap&lt;String, String&gt; notifySorts = sortNotify(notifyMaps);    // 重新签名    String sign = generateSign(notifySorts);    // 获取回执签名    String notifySign = notifySorts.get("sign").toUpperCase();    // 验证签名    if (!sign.equals(notifySign)) {        logger.error("签名验证失败！");        throw new TSharkException("签名验证失败！");    }    String resXml;    // 验证回执    if ("SUCCESS".equals(notifySorts.get("result_code"))) {        // 更新订单信息        updateOrderInfo(notifySorts.get("out_trade_no"));        // 微信回执        resXml = "&lt;xml&gt;" +                "&lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;" +                "&lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;" +                "&lt;/xml&gt; ";    } else {        resXml = "&lt;xml&gt;" +                "&lt;return_code&gt;&lt;![CDATA[FAIL]]&gt;&lt;/return_code&gt;" +                "&lt;return_msg&gt;&lt;![CDATA[报文为空]]&gt;&lt;/return_msg&gt;" +                "&lt;/xml&gt; ";    }    BufferedOutputStream out = new BufferedOutputStream(response.getOutputStream());    out.write(resXml.getBytes());    out.flush();    out.close();}  从IO流中读取回执信息private HashMap&lt;String, String&gt; readNotify(HttpServletRequest request) throws Exception {    // 读取参数    InputStream inputStream = request.getInputStream();    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, "UTF-8"));    // 接收数据    String line;    StringBuffer str = new StringBuffer();    while ((line = reader.readLine()) != null) {        str.append(line);    }    reader.close();    inputStream.close();    // XML转换Map    return fromXml(str.toString());}  读取的回执信息时XML格式，需要通过jDom的SAXBuilder解析为Mapprivate HashMap&lt;String, String&gt; fromXml(String xml) throws Exception {    xml = xml.replaceFirst("encoding=\".*\"", "encoding=\"UTF-8\"");    if (null == xml || "".equals(xml)) {        return null;    }    HashMap&lt;String, String&gt; m = Maps.newHashMap();    InputStream in = new ByteArrayInputStream(xml.getBytes("UTF-8"));    SAXBuilder builder = new SAXBuilder();    Document doc = builder.build(in);    Element root = doc.getRootElement();    List list = root.getChildren();    Iterator it = list.iterator();    while (it.hasNext()) {        Element e = (Element) it.next();        String k = e.getName();        String v = "";        List children = e.getChildren();        if (children.isEmpty()) {            v = e.getTextNormalize();        } else {            v = getXmlChildren(children);        }        m.put(k, v);    }    //关闭流    in.close();    return m;}private String getXmlChildren(List children) {    StringBuffer sb = new StringBuffer();    if (!children.isEmpty()) {        Iterator it = children.iterator();        while (it.hasNext()) {            Element e = (Element) it.next();            String name = e.getName();            String value = e.getTextNormalize();            List list = e.getChildren();            sb.append("&lt;" + name + "&gt;");            if (!list.isEmpty()) {                sb.append(getXmlChildren(list));            }            sb.append(value);            sb.append("&lt;/" + name + "&gt;");        }    }    return sb.toString();}轮询订单状态，实现支付完成后页面自动跳转  由于支付回执是异步的，所以即使捕获到异步回执也无法实现支付页面的自动跳转  所以需要在支付页面打开时设置一个ajax轮询订单状态，一旦订单状态更新，则进行页面跳转// 页面关闭$(".modal-header button.close:last").click(function () {    // 停止轮询    clearInterval(checkTimer);});// 轮询订单状态checkTimer = setInterval(function () {    // 窗口是否打开    if ($(".order-pay-panel").length &lt;= 0) {        clearInterval(checkTimer);    }    // 获取订单状态    $.ts.doAction("/api/order/review/check/", {        orderId: orderId    }, function () {        // 订单已支付        if (!this.data) {            $.ts.closeWindow();            g_index.loadMainContentWithState("/order/manage");      $.ts.toastr.success("订单已支付成功！");        }    }, "", "", "");}, 3000);]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> wechatpay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java MD5加密]]></title>
      <url>/java/2017/02/09/Java-MD5%E5%8A%A0%E5%AF%86/</url>
      <content type="text"><![CDATA[  md5加密简要算法生成 16 位加密串/** * 利用MD5进行加密 * * @param str 待加密的字符串 * @return 加密后的字符串 */private String EncoderByMd5(String str) throws Exception {	// 生成一个MD5加密计算摘要	MessageDigest md = MessageDigest.getInstance("MD5");	// 计算md5函数	md.update(str.getBytes());	// digest()最后确定返回md5 hash值，返回值为8为字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符	// BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值	return new BigInteger(1, md.digest()).toString(16);}生成 32 位加密串private String md5(String input) {    MessageDigest md = null;    try {        md = MessageDigest.getInstance("MD5");        md.update(input.getBytes());        String md5 = new BigInteger(1, md.digest()).toString(16);        return fillMD5(md5);    } catch (NoSuchAlgorithmException e) {        logger.error("字串加密失败！", e);    }    return null;}/** * 加密串补齐32位 */private String fillMD5(String md5) {    return md5.length() == 32 ? md5 : fillMD5("0" + md5);}]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> md5 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis新增返回id]]></title>
      <url>/java/mybatis/2017/02/08/MyBatis%E6%96%B0%E5%A2%9E%E8%BF%94%E5%9B%9Eid/</url>
      <content type="text"><![CDATA[  新增一条数据到数据库，并返回该数据的id&lt;insert id="saveSendMessage" keyColumn="id" keyProperty="id" useGeneratedKeys="true" parameterType="SendMessageDTO"&gt;	...&lt;/insert&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS文字不能被选中]]></title>
      <url>/css/2017/01/26/CSS%E6%96%87%E5%AD%97%E4%B8%8D%E8%83%BD%E8%A2%AB%E9%80%89%E4%B8%AD/</url>
      <content type="text"><![CDATA[  确保文本文字不能被光标选中解决-moz-user-select: none;-webkit-user-select: none;user-select: none;]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>/validate/2017/01/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="text"><![CDATA[  正则表达式的一些基础语法介绍  正则表达式是一种字符串查找以及替换的操作方式。被广泛用于：          检查文本中是否含有指定的特征词      找出文中匹配特征词的位置      从文本中提取信息，比如：字符串的子串      修改文本      语法  字符：a b c d 1 2 3 4 etc.  字符类： . [abc] [a-z] \d \w \s          . 任何字符      \d 数字      \w 字母[0-9A-Za-z_]      \s 空格、制表符、回车、换行符      否定字符类： [^abc] \D \W \S        重复：{4} {3,16} {1,} ? * +          ? 零次或一次      * 大于零次      + 表示一次或一次以上      如果不加上 ? ，所有的重复都是最长匹配        分组：(Septem|Octo|Novem|Decem)ber  词，行以及文本的分隔：\b ^ $ \A \z  转义字符： \1 \2 \3 etc. (在匹配表达式和替换表达式中都可用)  元字符：. \ [ ] { } ? * + | ( ) ^ $  在字符类中使用元字符：[ ] \ - ^  使用反斜杠可以忽略元字符：\]]></content>
      <categories>
        
          <category> validate </category>
        
      </categories>
      <tags>
        
          <tag> validate </tag>
        
          <tag> regular </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[对象反射赋值]]></title>
      <url>/java/relfect/2017/01/20/%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%B0%84%E8%B5%8B%E5%80%BC/</url>
      <content type="text"><![CDATA[  在不确定对象字段及内容的前提下，为对象赋值的解决方案通常是反射赋值实现方式// 获取当前会员对象Class&lt;MemberDTO&gt; member = (Class&lt;MemberDTO&gt;) super.getMember().getClass();// 获取所有字段Field[] fileds = member.getDeclaredFields();// 遍历字段找到与当前修改字段相符合的字段for (Field field : fileds) {	// ** 获取私有字段的操作权限	field.setAccessible(true);	if (field.getName().equals(name)) {		// 找到字段对应 set 方法		PropertyDescriptor pd = new PropertyDescriptor(field.getName(), member);		Method method = pd.getWriteMethod();		// 传入当前对象，并赋值		method.invoke(super.getMember(), value);		break;	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> relfect </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> relfect </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery操作audio和video]]></title>
      <url>/jquery/2017/01/20/jQuery%E6%93%8D%E4%BD%9Caudio%E5%92%8Cvideo/</url>
      <content type="text"><![CDATA[  获取audio需要使用[0]，因为js操作获得的是audio对象，jQuery选择器获得的是jQuery对象，通过[0]取到的才是对应的节点对象所以不能直接使用jQuery对象去操作，需要通过[0]转换成js对应的节点对象实现方式var audio = $("#audio")[0];audio.pause();audio.play();]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
          <tag> video </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iframe设置session-timeout]]></title>
      <url>/html/iframe/2017/01/20/iframe%E8%AE%BE%E7%BD%AEsession-timeout/</url>
      <content type="text"><![CDATA[  在 iframe 中继承父容器的 session 信息在iframe需要加载的页面中加入&lt;%	response.setHeader("P3P", "CP=CAO PSA OUR");%&gt;在需要加载的首页加入if (top != self) {	if (top.location != self.location) {		top.location = self.location;	}}]]></content>
      <categories>
        
          <category> html </category>
        
          <category> iframe </category>
        
      </categories>
      <tags>
        
          <tag> html </tag>
        
          <tag> iframe </tag>
        
          <tag> session </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java实现颜色随机]]></title>
      <url>/java/2017/01/20/Java%E5%AE%9E%E7%8E%B0%E9%A2%9C%E8%89%B2%E9%9A%8F%E6%9C%BA/</url>
      <content type="text"><![CDATA[  通过随机拼接rgb编码的方式，获取随机的颜色码实现方式String r, g, b;// 定义随机数	Random random = new Random();	// 获取编码r = Integer.toHexString(random.nextInt(256)).toUpperCase();g = Integer.toHexString(random.nextInt(256)).toUpperCase();b = Integer.toHexString(random.nextInt(256)).toUpperCase();	// 编码有效性控制r = r.length() == 1 ? "0" + r : r;g = g.length() == 1 ? "0" + g : g;b = b.length() == 1 ? "0" + b : b;	// 拼接return r + g + b;]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> color </tag>
        
          <tag> random </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java实现不重复随机数]]></title>
      <url>/java/2017/01/20/Java%E5%AE%9E%E7%8E%B0%E4%B8%8D%E9%87%8D%E5%A4%8D%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      <content type="text"><![CDATA[  随机指定范围内生成N个不重复的数具体实现/** * @param min 指定范围最小值 * @param max 指定范围最大值 * @param n 随机数个数*/private int[] randomCommon(int min, int max, int n){	// 有效性判断	if (n &gt; (max - min + 1) || max &lt; min) {		return null;	}	// 按随机个数声明存放数组	int[] result = new int[n];	// 统计生成个数	int count = 0;	// 生成个数小于n之前，一直生成	while(count &lt; n) {		// 在指定范围内生成随机数		int num = (int) (Math.random() * (max - min)) + min;		// 重复标记		boolean flag = true;		// 将生成的随机数与数组中已生成的数作比较		for (int j = 0; j &lt; n; j++) {			// 重复则标记			if(num == result[j]){				flag = false;				break;			}		}		// 不重复则加入数组		if(flag) {			result[count] = num;			// 生成个数累加			count++;		}	}	return result;}]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> random </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript 跳出循环]]></title>
      <url>/javascript/2017/01/20/Javascript-%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF/</url>
      <content type="text"><![CDATA[  对于不同的循环方式，javascript需要采用不同的方式跳出for循环依然使用continue和breakfor (var i = 0; i &lt; length; i++) {	if (i === 1) {		break;	} else {		continue;	}}each循环则使用return true和return false$.each(arr, function (index, value) {	if (index == 1) {		return false;	} else {		return true;	}});]]></content>
      <categories>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> for </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript replace()实现全局替换]]></title>
      <url>/javascript/2017/01/20/Javascript-replace()%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E6%9B%BF%E6%8D%A2/</url>
      <content type="text"><![CDATA[  第一个参数需要用到正则表达式，/g 表示全局替换，否则只能替换第一个匹配项实现方式skill.replace(/a/g, "A");]]></content>
      <categories>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript JSON 转换]]></title>
      <url>/javascript/json/2017/01/20/Javascript-JSON-%E8%BD%AC%E6%8D%A2/</url>
      <content type="text"><![CDATA[  javascript的JSON格式相互转换JSON 转字符串JSON.stringify(strJson);字符串转 JSON$.parseJSON(jsonStr);]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> json </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> json </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Ace 代码编辑器]]></title>
      <url>/jquery/2017/01/18/Ace-%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      <content type="text"><![CDATA[  代码风格美化编辑器官网Ace - The High Performance Code Editor for the WebAPI  设置主题 editor.setTheme("ace/theme/twilight");  设置程序员语言模式 editor.getSession().setMode("ace/mode/javascript");  设置制表符大小 editor.getSession().setTabSize(4);  设置软标签 editor.getSession().setUseSoftTabs(true);  设置代码自动换行 editor.getSession().setUseWrapMode(true);  设置当前行高亮 editor.setHighlightActiveLine(false);  设置边距线显示 editor.setShowPrintMargin(false);  设置只读 editor.setReadOnly(true);  重新设置编辑器尺寸 editor.resize();方法  赋值 editor.setValue("the new text here");  取值 editor.getValue();  获取选择内容 editor.session.getTextRange(editor.getSelectionRange());  在光标处插入 editor.insert("Something cool");  获取光标所在行或列 editor.selection.getCursor();  跳转到指定行 editor.gotoLine(10);  获取总行数 editor.session.getLength();事件  监听内容改变editor.getSession().on("change", function(e) {});  监听内容选择editor.getSession().selection.on("changeSelection", function(e) {});  监听光标移动editor.getSession().selection.on("changeCursor", function(e) {	});]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[HashMap和TreeMap]]></title>
      <url>/java/2017/01/17/HashMap%E5%92%8CTreeMap/</url>
      <content type="text"><![CDATA[介绍  Map是key-value的集合接口，其实现类包括：          HashMap - 值没有顺序      TreeMap - key值默认升序      LinkedHashMap - 值没有顺序      key排序Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(	new Comparator&lt;String&gt;() {		public int compare(String obj1, String obj2) {			// 降序排序			return obj2.compareTo(obj1);		}	});value排序// 这里将map.entrySet()转换成listList&lt;Map.Entry&lt;String,String&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet());	// 然后通过比较器来实现排序	Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,String&gt;&gt;() {		// 升序排序		public int compare(Entry&lt;String, String&gt; o1, Entry&lt;String, String&gt; o2) {			return o1.getValue().compareTo(o2.getValue());		}            	});]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> map </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mongoose.js + MongoDB]]></title>
      <url>/database/mongodb/2017/01/16/Mongoose.js+MongoDB/</url>
      <content type="text"><![CDATA[  MongoDB是一个跨平台的、面向文档的NoSql (非关系型)类型数据库官网MongoDB Download Center | MongoDB安装  下载名为mongodb-osx-ssl-x86_64-3.4.1.tgz的文件  解压文件到指定目录  在根目录创建目录，用于放置数据库数据 ~需要给予用户权限~sudo mkdir -p /data/dbsudo chown -R ThkcDo /data  启动数据库cd /[customPath]/mongodb/bin./mongod操作  在数据库服务开启的前提下，输入 ./mongo 可进入数据库操作界面]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mongodb </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mongodb </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[判断String是否为数字]]></title>
      <url>/java/2017/01/12/%E5%88%A4%E6%96%ADString%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E5%AD%97/</url>
      <content type="text"><![CDATA[  解决思路是通过正则表达式匹配字符串内容是否全部为数字实现方式// 数字0-9出现零到多次Pattern pattern = Pattern.compile("[0-9]*");Matcher isNum = pattern.matcher(str);if (isNum.matches()) {	// 数字} else {	// 非数字}]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> string </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript数组去重]]></title>
      <url>/javascript/array/2017/01/09/Javascript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      <content type="text"><![CDATA[  Set是ES2015引入的数据类型，意为集合其不允许重复元素出现的特性，对于NaN、undefined、null都适用实现方式function unique(arr) {	var set = new Set(arr);		return Array.from(set);}var arr = [1,1,'1','1',0,0,'0','0',undefined,undefined,null,null,NaN,NaN,{},{},[],[],/a/,/a/];console.log(unique(arr));]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> array </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> array </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS图片限制宽高]]></title>
      <url>/css/2017/01/09/CSS%E5%9B%BE%E7%89%87%E9%99%90%E5%88%B6%E5%AE%BD%E9%AB%98/</url>
      <content type="text"><![CDATA[  用父元素包裹图片，然后限制超出隐藏，可以保证图片不变形并且只看到图片上部分编写 HTML&lt;p class="img-container"&gt;	&lt;img src="#"&gt;&lt;/p&gt;编写 CSSp.img-container {	width: 100%;	height: 0;	padding-bottom: 60%;	overflow: hidden;}p.img-container img {	width: 100%;}]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Zip4j解压文件]]></title>
      <url>/java/2017/01/04/Zip4j%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6/</url>
      <content type="text"><![CDATA[  使用 zip4j 可以快速对文件进行解压缩处理官网zip4j特性  支持Zip文件的创建、添加、解压、更新、移除  可读写有密码保护的Zip文件  支持AES 128/256算法加密  支持标准Zip算法加密  支持Zip64格式  支持分块Zip文件的创建和解压  支持Unicode编码的文件名  支持进度监控添加Maven依赖&lt;dependency&gt;    &lt;groupId&gt;net.lingala.zip4j&lt;/groupId&gt;    &lt;artifactId&gt;zip4j&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;解压实现// 获取Zip文件ZipFile zipFile = new ZipFile(file);// 指定文件名编码zipFile.setFileNameCharset("GBK");// 验证文件有效性if (!zipFile.isValidZipFile()) {    responseData.setError("压缩文件已损坏！");    return;}// 解压目录File fileDir = new File(newFile);// 目录不存在则创建if (fileDir.isDirectory() &amp;&amp; !fileDir.exists()) {    fileDir.mkdir();}// 解压zipFile.extractAll(newFile);]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> zip </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[web.xml组件加载顺序]]></title>
      <url>/java/springmvc/tomcat/2016/12/29/web.xml%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
      <content type="text"><![CDATA[  context-param &gt; listener &gt; filter &gt; servlet 其中同类则按编写顺序执行常用组件解析&lt;web-app xmlns="" version=""&gt;	&lt;!-- 应用名称 --&gt;	&lt;display-name&gt;Bear&lt;/display-name&gt;	&lt;!-- 应用描述 --&gt;	&lt;description&gt;&lt;/description&gt;	&lt;!-- 应用范围内的初始化参数 --&gt;	&lt;context-param&gt;		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;		&lt;!-- 加载多个spring配置文件 --&gt;		&lt;param-value&gt;classpath*:/applicationContext.xml&lt;/param-value&gt;	&lt;/context-param&gt;	&lt;!-- 加载事件监听器，在建立、修改、删除会话或servlet环境时得到通知 --&gt;	&lt;listener&gt;		&lt;!-- 定义Spring监听器 --&gt;		&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;	&lt;/listener&gt;	&lt;!-- 加载过滤器，将一个名字与一个实现了javax.servlet.Filter接口的类关联 --&gt;	&lt;filter&gt;		&lt;!-- 过滤器名称 --&gt;		&lt;filter-name&gt;&lt;/filter-name&gt;		&lt;!-- 过滤器路径 --&gt;		&lt;filter-class&gt;&lt;/filter-class&gt;		&lt;!-- 初始化参数 --&gt;		&lt;init-param&gt;			&lt;!-- 参数名称 --&gt;			&lt;param-name&gt;&lt;/param-name&gt;			&lt;!-- 参数值 --&gt;			&lt;param-value&gt;&lt;/param-value&gt;		&lt;/init-param&gt;	&lt;/filter&gt;	&lt;!-- 如果命名了过滤器，则需要将其与一个或多个servlet或jsp页面关联 --&gt;	&lt;filter-mapping&gt;		&lt;!-- 过滤器名称 --&gt;		&lt;filter-name&gt;&lt;/filter-name&gt;		&lt;!-- 应用范围，所有 --&gt;		&lt;url-pattern&gt;/*&lt;/ulr-pattern&gt;	&lt;/filter-mapping&gt;	&lt;!-- 加载servlet，在向servlet或jsp页面指定初始化参数或URL时，必须先命名servlet或jsp页面 --&gt;	&lt;servlet&gt;		&lt;!-- servlet名称 --&gt;		&lt;servlet-name&gt;springServlet&lt;/servlet-name&gt;		&lt;!-- servlet路径 --&gt;		&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;		&lt;!-- 初始化参数 --&gt;		&lt;init-param&gt;			&lt;!-- 参数名称 --&gt;			&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;			&lt;!-- 参数值 --&gt;			&lt;param-value&gt;classpath*:spring-mvc.xml&lt;/param-value&gt;		&lt;/init-param&gt;		&lt;!-- 加载优先级 --&gt;		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;	&lt;/servlet&gt;	&lt;!-- 为指定的servlet提供缺省URL --&gt;	&lt;servlet-mapping&gt;		&lt;!-- servlet名称 --&gt;		&lt;servlet-name&gt;springServlet&lt;/servlet-name&gt;		&lt;!-- 应用范围 --&gt;		&lt;url-pattern&gt;/*&lt;/url-pattern&gt;	&lt;/servlet-mapping&gt;	&lt;!-- 会话配置 --&gt;	&lt;session-config&gt;		&lt;!-- 定义会话超时时间，会员未访问时间达到改配置，则会被服务器抛弃以节省内存 --&gt;		&lt;session-timeout&gt;30&lt;/session-timeout&gt;	&lt;/session-config&gt;	&lt;!-- 为特殊文件分配特定mime类型 --&gt;	&lt;mime-mapping&gt;&lt;/mime-mapping&gt;	&lt;!-- 应用首页入口文件列表 --&gt;	&lt;welcome-file-list&gt;&lt;/welcome-file-list&gt;	&lt;!-- 在返回特定http状态码或特定类型的异常抛出时，显示的页面 --&gt;	&lt;error-page&gt;		&lt;!-- 状态码 --&gt;		&lt;error-code&gt;404&lt;/error-code&gt;		&lt;!-- 显示页面 --&gt;		&lt;location&gt;404.jsp&lt;/location&gt;	&lt;/error-page&gt;	&lt;!-- 为标记库描述文件指定别名，可更改TLD文件的位置 ——&gt;	&lt;taglib&gt;&lt;/taglib&gt;	&lt;!-- 声明与资源相关的管理对象 --&gt; 	&lt;resource-env-ref&gt;&lt;/resource-env-ref&gt;	&lt;!-- 声明资源工厂使用的外部资源 --&gt;	&lt;resource-ref&gt;&lt;/resource-ref&gt;	&lt;!-- 指定待保护的URL，与location-config联合使用 --&gt;	&lt;security-constraint&gt;&lt;/security-constraint&gt;	&lt;!-- 指定服务器如何给试图访问受保护页面的用户授权，与security-constraint联合使用 --&gt;	&lt;login-config&gt;&lt;/login-config&gt;	&lt;!-- 安全角色列表 --&gt;	&lt;security-role&gt;&lt;/security-role&gt;	&lt;!-- 声明应用环境项 --&gt;	&lt;env-entry&gt;&lt;/env-entry&gt;&lt;/web-app&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> tomcat </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> tomcat </tag>
        
          <tag> server </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery.on()用法]]></title>
      <url>/jquery/2016/12/29/jQuery.on()%E7%94%A8%E6%B3%95/</url>
      <content type="text"><![CDATA[  on() 是 jQuery 新的为 DOM 元素绑定事件的方法绑定单事件单元素$messagePanel.find(".message-item").on("click", function () {	console.log("click");});绑定单事件多元素$messagePanel.on("click", ".message-item, .message-comment-item", function () {	console.log("click");});绑定多事件多元素$messagePanel.on({	click: function () {		consloe.log("click");	},	mouseenter: function () {		console.log("mouseenter");	}}, ".message-item, .message-comment-item");]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS绘制三角形]]></title>
      <url>/css/2016/12/29/CSS%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
      <content type="text"><![CDATA[  CSS 绘制各种三角形⬆️向上.triangle {	width: 0;	height: 0;	border-left: 50px solid transparent;	border-right: 50px solid transparent;	border-bottom: 100px solid red;}➡️向右.triangle {	width: 0;	height: 0;	border-top: 50px solid transparent;	border-bottom: 50px solid transparent;	border-left: 100px solid red;}⬇️向下.triangle {	width: 0;	height: 0;	border-left: 50px solid transparent;	border-right: 50px solid transparent;	border-top: 100px solid red;}⬅️向左.triangle {	width: 0;	height: 0;	border-top: 50px solid transparent;	border-bottom: 50px solid transparent;	border-right: 100px solid red;}↗️向右上.triangle {	width: 0;	height: 0;	border-top: 100px solid red;	border-left: 100px solid transparent;}↖️向左上.triangle {	width: 0;	height: 0;	border-top: 100px solid red;	border-right: 100px solid transparent;}↘️向右下.triangle {	width: 0;	height: 0;	border-bottom: 100px solid red;	border-left: 100px solid transparent;}  ↙️向左下    .triangle { width: 0; height: 0; border-bottom: 100px solid red; border-right: 100px solid transparent;}      ]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery限制元素无法被选中]]></title>
      <url>/jquery/2016/12/28/jQuery%E9%99%90%E5%88%B6%E5%85%83%E7%B4%A0%E6%97%A0%E6%B3%95%E8%A2%AB%E9%80%89%E4%B8%AD/</url>
      <content type="text"><![CDATA[  效果为指定内容无法被鼠标选中问题对于网页中的某些元素，不希望其可被选中解决$("#element").attr("unselectable", "on");$("#element").css("user-select", "none");$("#element").on("selectstart", fasle);]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery通过IP获取地理位置]]></title>
      <url>/jquery/2016/12/28/jQuery%E9%80%9A%E8%BF%87IP%E8%8E%B7%E5%8F%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  jQuery 可以通过 IP 获取地理位置实现方式var ip = "119.75.218.70";// 地理位置获取apivar api = "http://freegeoip.net/json/" + ip + "?callback=?";$.getJSON(api, function (e) {		console.log("city: " + e.city);		console.log("country: " + e.country_name);});]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery改变行内样式]]></title>
      <url>/jquery/2016/12/28/jQuery%E6%94%B9%E5%8F%98%E8%A1%8C%E5%86%85%E6%A0%B7%E5%BC%8F/</url>
      <content type="text"><![CDATA[  通过 jQuery 修改 DOM 元素行内样式问题  通过 jQuery.css() 方法，触发元素行内样式的更改。  最佳方式不是在样式内容后加 ~!important~方式一// 单个样式$("#element").css("color", "red").attr("contentEditable", true);// 多个样式$("#element").css({	"display": "block",	"color": "red"}).attr("contentEditable", true);方式二$("#element").css("cssText", "background-color: red !important");]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery在元素创建之前绑定事件]]></title>
      <url>/jquery/2016/12/28/jQuery%E5%9C%A8%E5%85%83%E7%B4%A0%E5%88%9B%E5%BB%BA%E4%B9%8B%E5%89%8D%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6/</url>
      <content type="text"><![CDATA[  jQuery可以实现在元素创建之前就监听该元素，这对于动态创建元素后绑定事件非常有用问题  对于存在动态添加的元素，则需要动态绑定事件，而为了不导致因为给新元素绑定事件，导致旧元素出现重复绑定的情况。  一般的解决办法是先解绑再绑定function showTip() {	alert(1););// 第一次绑定$("#element").find("li").click(showTip);// 由于新增了相同元素，则需要为旧元素解绑事件$("element").find("li").unbind("click");// 再重新为当前所有元素绑定$("#element").find("li").click(showTip);解决  jQuery 拥有先进的事件处理机制，因为 jQuery.on() 方法可以传递一个元素的子元素选择器作为参数，则可以监听目前还不存在的事件$("#element").on("click", "li", function () {	alert(1);});]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery使用Ajax提交表单]]></title>
      <url>/jquery/ajax/2016/12/28/jQuery%E4%BD%BF%E7%94%A8Ajax%E6%8F%90%E4%BA%A4%E8%A1%A8%E5%8D%95/</url>
      <content type="text"><![CDATA[  一般表单数据需要使用表单提交，但其实也可以通过 ajax 将表单数据提交到后台。解决&lt;form action="#"&gt;	&lt;input type="text" name="name" value="tom"/&gt;	&lt;input type="text" name="gender" value="male"/&gt;&lt;/form&gt;// 将表单数据序列化后将得到name=tom&amp;gender=male格式的数据，可直接用于ajax提交$("form").serialize();]]></content>
      <categories>
        
          <category> jquery </category>
        
          <category> ajax </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
          <tag> ajax </tag>
        
          <tag> form </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery为元素添加多个样式]]></title>
      <url>/jquery/2016/12/28/jQuery%E4%B8%BA%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA%E6%A0%B7%E5%BC%8F/</url>
      <content type="text"><![CDATA[  jQuery 可以为一个 DOM 元素同时添加多个样式问题  虽然 jQuery.css() 方法可以更改元素样式，但其实 JS 操作 DOM 非常慢。  所以在为元素添加多个样式时，更好的方法是创建一个 style 元素并添加到 document 中。解决var style = $("&lt;style&gt;");style.text("#element {color: red}");style.appendTo("#element");]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery exist 自定义方法]]></title>
      <url>/jquery/2016/12/28/jQuery-exist/</url>
      <content type="text"><![CDATA[  一般通过 $(“#element”).length === 1 判断元素是否存在，但这样显得过于麻烦解决  可集成 length 方法，扩展成为 exist 方法    jQuery.fn.exists = function() { return this.length &gt; 0;}      ]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS文本样式]]></title>
      <url>/css/2016/12/27/CSS%E6%96%87%E6%9C%AC%E6%A0%B7%E5%BC%8F/</url>
      <content type="text"><![CDATA[  一些简单的文本样式，持续更新文字缩进  text-indent: 20px字符间距  letter-spacing: 10px;文本竖向排列  writing-mode: vertical-rl;文本自动换行  word-wrap: break-word;图片相对于文本的对齐方式  vertical-align: middle;]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Sublime 快捷键]]></title>
      <url>/software/sublime/2016/12/26/Sublime-%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="text"><![CDATA[  Sublime一些常用的快捷键介绍软件功能  Ctrl+G          打开行号输入框，可快速跳转指定行        Command+T          打开输入框，可输入文件路径、名称并前往        Command+[1,2,3,4…]          选择对应索引的Tab页面        Command+K+B          打开/关闭侧边栏        Command+Shift+P          打开命令提示框，可快捷输入页面语法类型并更改        Command+Option+[1,2,3,4]          将窗口分为1，2，3，4列        Command+Option+5          将窗口分为4个网格      内容编辑  Ctrl+D          选中光标所在标签中所有内容        Ctrl+Space          打开输入提示        Ctrl+Shift+K          删除光标所在行        Command+D          选中光标所在单词，并高亮当前页中所有相同单词，~可重复按下选中这些相同单词并编辑~        Command+J          合并多个选中行为一行        Command+L          选中光标所在行        Command+Enter          在光标所在行的下一行插入新的一行        Command+K+U          光标所在单词全部大写        Command+K+L          光标所在单词全部小写        Command+Shift+D          复制光标所在行        Command+Shift+Enter          在光标所在行的上一行插入新的一行        Option+Shift+F          格式化代码      ]]></content>
      <categories>
        
          <category> software </category>
        
          <category> sublime </category>
        
      </categories>
      <tags>
        
          <tag> software </tag>
        
          <tag> sublime </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[jQuery获取指定子元素]]></title>
      <url>/jquery/2016/12/24/jQuery%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E5%AD%90%E5%85%83%E7%B4%A0/</url>
      <content type="text"><![CDATA[  可通过 jQuery 获取 DOM 元素指定子元素问题  需要根据className获取指定索引元素解决currentImgPanel.find(".photo-tagger-tag").eq(0);]]></content>
      <categories>
        
          <category> jquery </category>
        
      </categories>
      <tags>
        
          <tag> jquery </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS改变大小过度动画]]></title>
      <url>/css/2016/12/15/CSS%E6%94%B9%E5%8F%98%E5%A4%A7%E5%B0%8F%E8%BF%87%E5%BA%A6%E5%8A%A8%E7%94%BB/</url>
      <content type="text"><![CDATA[  div在改变宽高时需要一段动画形式展现解决.timeline-entry {	width: 100px;	height: 200px;}.timeline-entry.active {	width: 200px;	height: 300px;	// 动画延迟时间	transition-delay: 100ms;	// 应用过度动画的属性	transition-property: width, height;	// 动画持续时间	transition-duration: 500ms;}]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS居中]]></title>
      <url>/css/2016/12/15/CSS%E5%B1%85%E4%B8%AD/</url>
      <content type="text"><![CDATA[  列举 CSS 的一些居中方案水平居中父容器样式#blogManagePanel &gt; div.col-md-12 {	width: 100%;	height: 100%;}div样式#blogManagePanel .timeline-icon.bg-more {		margin: 0 auto;		// 使用相对定位可以让div不限定在父容器可视内容中		position: relative;		left: 50%;}垂直居中父容器样式#blogManagePanel &gt; div.col-md-12 {	width: 100%;	height: 100%;}div样式#blogManagePanel .timeline-icon.bg-more {	margin: 0 auto;	position: absolute;	top: 50%;}完全居中父容器样式#blogManagePanel &gt; div.col-md-12 {	width: 100%;	height: 100%;}div样式#blogManagePanel .timeline-icon.bg-more {	margin: auto;	position: absolute;	top: 0; 	left: 0; 	bottom: 0; 	right: 0;}]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mac系统技巧]]></title>
      <url>/mac/2016/12/14/Mac%E7%B3%BB%E7%BB%9F%E6%8A%80%E5%B7%A7/</url>
      <content type="text"><![CDATA[  罗列一些系统技巧，持续更新配置NFS目录sudo mount -t nfs -o resvport,nolock 192.168.7.11:/var/www/html /Users/ThkcDo/Documents/innovaee/projects/nfs制作文件夹软链接  tomcat配置文件需要加上 allowLinking=”true” 用于允许软链接ln -s sourceDir targetDir显示隐藏文件defaults write com.apple.finder AppleShowAllFiles -bool truekillall Finder查看CPU信息sysctl machdep.cpu.brand_string查看当前WIFI密码security find-generic-password -ga "innovaee-11-HUAWEI_5G" | grep "password:"]]></content>
      <categories>
        
          <category> mac </category>
        
      </categories>
      <tags>
        
          <tag> mac </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS获取每行最后一个元素]]></title>
      <url>/css/2016/12/14/CSS%E8%8E%B7%E5%8F%96%E6%AF%8F%E8%A1%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0/</url>
      <content type="text"><![CDATA[  div中每一行的最后一个元素需要指定单独样式显示效果解决// :not表示排除指定元素// :nth-child表示指定第几个元素// 3n表示每行第三个元素.resource-list-item:not(:nth-child(3n)) {	margin-right: 15px;}]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS横向滚动]]></title>
      <url>/css/2016/12/14/CSS%E6%A8%AA%E5%90%91%E6%BB%9A%E5%8A%A8/</url>
      <content type="text"><![CDATA[  div中的元素需要横向滚动显示效果解决.revelent-list-panel {	// 指定宽度	width: 768px;	height: 94px;	// 显示横线滚动条	overflow-x: scroll;	// 隐藏纵向滚动条	overflow-y: hidden;	// 内容不换行	white-space: nowrap;}]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CSS文本换行加省略号]]></title>
      <url>/css/2016/12/14/CSS%E6%96%87%E6%9C%AC%E6%8D%A2%E8%A1%8C%E5%8A%A0%E7%9C%81%E7%95%A5%E5%8F%B7/</url>
      <content type="text"><![CDATA[  文本换行的后需要对超出的内容加省略号，text-overflow: ellipsis 无法实现此需求解决overflow: hidden;// 只有webkit内核浏览器支持display: -webkit-box;// 需要指定换行数-webkit-line-clamp: 5;-webkit-box-orient: vertical;]]></content>
      <categories>
        
          <category> css </category>
        
      </categories>
      <tags>
        
          <tag> css </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iframe高度控制]]></title>
      <url>/html/iframe/2016/12/13/iframe%E9%AB%98%E5%BA%A6%E6%8E%A7%E5%88%B6/</url>
      <content type="text"><![CDATA[  iframe在ios的safari中无法通过height:100%控制高度在iframe中加上scrolling=”no”强制没有滚动条&lt;iframe id="courseContentFrame" name="courseContentFrame" src="JavaScript:;" scrolling="no"&gt;&lt;/iframe&gt;在iframe动态加载内容后，通过js强制指定高度var height = $courseLearningPanel.find(".course-content-panel").height();$courseContentFrame.attr("height", height);$courseContentFrame.css("min-height", height + "px !important");$courseContentFrame.css("max-height", height + "611px !important");]]></content>
      <categories>
        
          <category> html </category>
        
          <category> iframe </category>
        
      </categories>
      <tags>
        
          <tag> html </tag>
        
          <tag> iframe </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
