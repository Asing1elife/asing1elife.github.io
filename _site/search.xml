<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[SpringBoot集成ActiveMQ抛出java.lang.NoClassDefFoundError异常]]></title>
      <url>/java/springboot/springmvc/maven/error/2018/05/08/SpringBoot%E9%9B%86%E6%88%90ActiveMQ%E6%8A%9B%E5%87%BANoClassDefFoundError/</url>
      <content type="text"><![CDATA[  SpringBoot 在集成 JMS 及 ActiveMQ 时抛出 java.lang.NoClassDefFoundError: javax/jms/JMSContext 异常出现问题的原因  spring 5.0 以上版本不会自动导入 JMS 2.0 的依赖  但是 activemq-core 5.7  版本需要 JMS 2.0 的依赖解决办法  手动加入 JMS 2.0 依赖&lt;dependency&gt;    &lt;groupId&gt;javax.jms&lt;/groupId&gt;    &lt;artifactId&gt;javax.jms-api&lt;/artifactId&gt;    &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;  在 activemq-core 5.7 中移除低版本的默认引入&lt;dependency&gt;    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;    &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;    &lt;version&gt;5.7.0&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;            &lt;artifactId&gt;geronimo-jms_1.1_spec&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> springmvc </category>
        
          <category> maven </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> springmvc </tag>
        
          <tag> maven </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot&IDEA热部署]]></title>
      <url>/java/springboot/software/2018/04/18/SpringBoot&IDEA%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      <content type="text"><![CDATA[  SpringBoot 自身有提供插件可实现代码热部署IDEA 相关配置  开启项目自动构建代码相关配置  pom 中加入以下依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;  扩展 spring-boot-maven-plugin 的插件配置项&lt;build&gt;    &lt;finalName&gt;mop&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;!-- 如果没有该项配置devtools不会起作用，即应用不会restart --&gt;                &lt;fork&gt;true&lt;/fork&gt;                &lt;!-- 支持静态文件热部署 --&gt;                &lt;addResources&gt;true&lt;/addResources&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> software </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> intellij </tag>
        
          <tag> idea </tag>
        
          <tag> software </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot集成Swagger]]></title>
      <url>/java/springboot/swagger/2018/04/17/SpringBoot%E9%9B%86%E6%88%90Swagger/</url>
      <content type="text"><![CDATA[  Swagger 是一款目前世界最流行的API管理工具官网  Swagger  Swagger Annotation集成步骤  在项目 pom 中引入以下依赖&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;  在项目中配置 Swagger@Configuration@EnableSwagger2public class SwaggerConfig {    @Bean    public Docket api() {        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()).select().apis(RequestHandlerSelectors.any()).paths(or(regex("/api/.*"))).build();    }    private ApiInfo apiInfo() {        return new ApiInfoBuilder().title("轻实训-移动端 API").version("1.0").build();    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> swagger </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> swagger </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot抛出ContextPath must start with '/' and not end with '/'异常]]></title>
      <url>/java/springboot/error/2018/04/17/SpringBoot%E6%8A%9B%E5%87%BAContextPath-must-start-with-'-'-and-not-end-with-'-'/</url>
      <content type="text"><![CDATA[  该异常属于项目配置的根路径出错解决问题的办法  在 application.yml 中将 server.servlet.context-path 设置的路径前加一个 /server:  servlet:    context-path: /api]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot启动抛出Unregistering JMX-exposed beans on shutdown异常]]></title>
      <url>/java/springboot/error/2018/04/16/SpringBoot%E5%90%AF%E5%8A%A8%E6%8A%9B%E5%87%BAUnregistering-JMX-exposed-beans-on-shutdown/</url>
      <content type="text"><![CDATA[  在配置 SpringBoot 项目时可能会抛出 Unregistering JMX-exposed beans on shutdown异常抛出错误的原因  是因为以下依赖的 scope 为 provided 导致的&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;解决的办法  将 provided 改为 compile 即可&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java支付宝订单查询]]></title>
      <url>/java/pay/2018/04/01/Java-%E6%94%AF%E4%BB%98%E5%AE%9D%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  电脑网站支付成功后可通过支付宝接口主动查询订单结果前置条件  该方法基于 Java 支付宝扫码支付 (新) 实现调用查询接口进行订单查询public class AliQueryServiceImpl extends AliCoreServiceImpl {    public Boolean getPayResult(Long orderId) {        AlipayTradeQueryRequest queryRequest = new AlipayTradeQueryRequest();        queryRequest.setBizModel(generateOrderInfo(orderId));        AlipayTradeQueryResponse response = null;        try {            response = alipayClient.execute(queryRequest);        } catch (AlipayApiException e) {            logger.error("支付宝查询订单" + orderId + "失败！", e);        }        if (response == null) {            logger.error("支付宝未获取订单" + orderId + "详情！");            return false;        }        if (response.isSuccess()) {            if (response.getTradeStatus().equals(TRADE_STATUS_SUCCESS) || response.getTradeStatus().equals(TRADE_STATUS_FINISHED)) {                // 更新订单状态                updateOrderInfo(response.getOutTradeNo(), OrderPay.aliPay.getCode());                return true;            }            logger.error("支付宝订单" + orderId + "交易失败，交易状态：" + response.getTradeStatus());            return false;        } else {            logger.error("支付宝订单" + orderId + "查询失败！");            return false;        }    }    private AlipayTradeQueryModel generateOrderInfo(Long orderId) {        OrderDTO order = orderManageService.getOrder(orderId);        AlipayTradeQueryModel model = new AlipayTradeQueryModel();        model.setOutTradeNo(order.getCode());        return model;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java支付宝扫码支付[新]]]></title>
      <url>/java/pay/2018/03/31/Java-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98-%E6%96%B0/</url>
      <content type="text"><![CDATA[  支付宝老版本的 Web 端扫码支付产品为即时到账，更新到新版后现在的产品为电脑网站支付官网电脑网站支付快速接入准备数据  电脑网站支付 应用需要在开发者页面端进行申请和签约  应用签约成功之后需要获取以下信息          app_id: 签约成功的应用唯一标识      app_private_key: 通过 RSA 密钥生成的应用私钥，由开发者自己通过签名软件生成[支付宝提供]      alipay_public_key: 通过应用私钥和公钥生成的支付宝公钥，由支付宝自动生成      下载 Java 版 SDK  前往 电脑网站支付 SDK 获取 下载 Java 的 SDK  该 SDK 目前不支持 Maven 方式引入，只能通过本地引入  正常开发模式只需要引入 alipay-sdk-java-3.0.0.jar 即可获取支付宝客户端  支付宝客户端是调用所有接口的前置条件，所以应该放置在顶层父类做一次初始化  SOPConstants.ALI_PAY_SEND_URL 是该支付方式的统一请求接口，值为 https://openapi.alipay.com/gateway.dopublic class AliCoreServiceImpl extends OrderCoreServiceImpl {    // 参数返回格式    private static final String ALI_PAY_FORMAT = "json";    // 编码集，支持 GBK/UTF-8    protected static final String ALI_PAY_CHARSET = "utf-8";    // 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2/RSA ，推荐使用 RSA2    protected static final String ALI_PAY_SIGN_TYPE = "RSA2";    // 订单支付成功状态    protected static final String TRADE_STATUS_SUCCESS = "TRADE_SUCCESS";    // 订单支付结束状态    protected static final String TRADE_STATUS_FINISHED = "TRADE_FINISHED";    // 支付宝客户端    protected static AlipayClient alipayClient;    static {        // 初始化支付宝客户端        alipayClient = new DefaultAlipayClient(                SOPConstants.ALI_PAY_SEND_URL,                SOPConstants.ALI_PAY_APP_ID,                SOPConstants.ALI_PAY_PRIVATE_KEY,                ALI_PAY_FORMAT,                ALI_PAY_CHARSET,                SOPConstants.ALI_PAY_PUBLIC_KEY,                ALI_PAY_SIGN_TYPE);    }}发起支付宝付款页面请求  新版的扫码支付对请求参数和响应参数都做了封装，只需要传入对应参数值即可  SOPConstants.ALI_PAY_RETURN_URL 是支付宝付款成功需要的同步回执地址  SOPConstants.ALI_PAY_NOTIFY_URL 是支付宝付款成功需要的异步回执地址  以上两个地址都需要能够外网访问  该请求方式是通过拼接请求使用 iframe 获取支付宝的付款二维码          通过客户端发起请求时不使用一般的 pageExecute() 而使用 sdkExecute()      sdkExecute() 获取的是请求之后的参数值，所以还需要拼接请求地址      SOPConstants.ALI_PAY_SEND_URL 是支付请求地址      public class AliPayServiceImpl extends AliCoreServiceImpl {    public String aliPay(Long orderId) {        // 创建统一下单请求        AlipayTradePagePayRequest payRequest = new AlipayTradePagePayRequest();        payRequest.setReturnUrl(SOPConstants.ALI_PAY_RETURN_URL);        payRequest.setNotifyUrl(SOPConstants.ALI_PAY_NOTIFY_URL);        // 将订单详情传入业务请求参数中        payRequest.setBizModel(generateOrderInfo(orderId));        String body = null;        try {            body = alipayClient.sdkExecute(payRequest).getBody();        } catch (AlipayApiException e) {            logger.error("订单" + orderId + "获取支付宝付款界面失败！");        }        if (body == null) {            logger.error("订单" + orderId + "未成功获取支付宝付款界面！");        }        return SOPConstants.ALI_PAY_SEND_URL + "?" + body;    }    private AlipayTradePagePayModel generateOrderInfo(Long orderId) {        // 获取订单信息        OrderDTO order = orderManageService.getOrder(orderId);        AlipayTradePagePayModel model = new AlipayTradePagePayModel();        model.setOutTradeNo(order.getCode());        model.setProductCode("FAST_INSTANT_TRADE_PAY");        model.setTotalAmount(String.valueOf(order.getPrice()));        model.setSubject("实训在线-" + order.getName());        model.setBody("实训在线-" + order.getName());        // 二维码获取方式为模式4，最简洁模式，只有二维码        model.setQrPayMode("4");        model.setQrcodeWidth(240L);        return model;    }}  控制层调用请求接口获取完整请求地址@RequestMapping("/ali/{orderId}")public String ali(Model model, @PathVariable String orderId) {    model.addAttribute("order", orderManageService.getOrder(IdEncoder.decodeId(orderId)));    model.addAttribute("orderType", OrderPay.aliPay.getCode());    model.addAttribute("aliPayUrl", aliPayService.aliPay(IdEncoder.decodeId(orderId)));    return "/order/pay/ali";}  上述方法中拼接完整的二维码请求地址可以直接放置到 iframe 的 src 属性中          如果页面没有成功获取，可根据报错信息前往 验签失败错误排查 进行解决      &lt;iframe id="aliPayFrame" src="${aliPayUrl}" frameborder="0"&gt;&lt;/iframe&gt;接收同步回执  该地址需要与之前初始化客户端时提交给支付宝的同步回执地址保持一致  回执地址不能有任何多余参数@RequestMapping("/ali/return")public String aliReturn(HttpServletRequest request) {    aliNotifyService.aliReturn(request);    return null;}  新版的同步回执中不会携带订单的状态信息，所以只能用做一般的信息接收，不能做为交易成功的依据          同步回执需要验签，但验签的方法支付宝已提供，即 AlipaySignature.rsaCheckV2()      public void aliReturn(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    Boolean result = false;    try {        // 回执验签        result = AlipaySignature.rsaCheckV2(parameterToMap(request, false), SOPConstants.ALI_PAY_PUBLIC_KEY, ALI_PAY_CHARSET, ALI_PAY_SIGN_TYPE);    } catch (AlipayApiException e) {        logger.error("支付宝订单" + orderCode + "同步回执验签失败！", e);    }    if (result) {        logger.info("支付宝订单" + orderCode + "同步回执接收成功！");    } else {        logger.error("支付宝订单" + orderCode + "同步回执无效！");    }}  对同步回执中的响应参数验签之前，需要先将参数转化为 map 形式private Map&lt;String, String&gt; parameterToMap(HttpServletRequest request, Boolean isNotify) {    // 获取回执内容    Map requestParams = request.getParameterMap();    // 过滤回执内容    Map&lt;String, String&gt; params = Maps.newHashMap();    for (Object o : requestParams.keySet()) {        String name = (String) o;        String[] values = (String[]) requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        if (isNotify) {            params.put(name, valueStr);        } else {            try {                params.put(name, new String(valueStr.getBytes("ISO-8859-1"), "utf-8"));            } catch (UnsupportedEncodingException e) {                logger.error("支付宝订单同步回执转码失败！", e);            }        }    }    return params;}接收异步回执  该地址需要与之前初始化客户端时提交给支付宝的异步回执地址保持一致  回执地址不能携带任何参数@RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic String aliNotify(HttpServletRequest request) {    return aliNotifyService.aliNotify(request);}  异步回执作为支付成功的依据，支付宝成功通知到本地后，需要明确告知支付宝交易已成功          交易成功后返回 success 即可      当订单支付成功后订单可以展现两种状态，TRADE_SUCCESS 或 TRADE_FINISHED      public String aliNotify(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 订单状态    String orderStatus = request.getParameter("trade_status");    boolean result = false;    try {        result = AlipaySignature.rsaCheckV2(parameterToMap(request, true), SOPConstants.ALI_PAY_PUBLIC_KEY, ALI_PAY_CHARSET, ALI_PAY_SIGN_TYPE);    } catch (AlipayApiException e) {        logger.error("支付宝订单" + orderCode + "异步回执验签失败，订单状态为：" + orderStatus + "！", e);    }    // 验签成功    if (result) {        // 订单已支付        if (orderStatus.equals(TRADE_STATUS_SUCCESS) || orderStatus.equals(TRADE_STATUS_FINISHED)) {            // 更新订单状态            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());            return "success";        } else {            logger.error("支付宝订单" + orderCode + "未支付，订单状态为：" + orderStatus + "！");            return "fail";        }    } else {        logger.error("支付宝订单" + orderCode + "异步回执接收失败，订单状态为：" + orderStatus + "！");        return "fail";    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java微信订单查询]]></title>
      <url>/java/pay/2018/03/31/Java-%E5%BE%AE%E4%BF%A1%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  Java 通过统一下单 API 进行订单支付后，除等待微信通过 notify_url 进行回调通知外，还可以主动查询订单状态前置条件可参考 Java 微信扫码支付 如果实现微信支付官网【微信支付】扫码支付开发者文档定义请求参数对象  订单查询请求参数（必填）public class QueryOrderRequest {    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 商户订单号，32位以内，不重复    private String out_trade_no;    // 随机字符串，32位以内    private String nonce_str;    // 签名，遵循签名算法    private String sign;}  查询订单请求参数（非必填）public class QueryOrderRequestExt extends QueryOrderRequest {    // 签名类型，默认MD5    private String sign_type;}定义接收参数对象  查询订单接收参数（必填）public class QueryOrderResponse {    // 返回状态码，通信标识，SUCCESS/FAIL    private String return_code;    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 随机字符串    private String nonce_str;    // 签名    private String sign;    // 业务结果，交易标识，SUCCESS/FAIL    private String result_code;    // 用户标识    private String openid;    // 交易类型，JSAPI，NATIVE，APP    private String trade_type;    // 交易状态，SUCCESS-成功 USERPAYING-支付中    private String trade_state;    // 付款银行    private String bank_type;    // 标价金额，单位分    private int total_fee;    // 现金支付金额    private int cash_fee;    // 微信支付订单号    private String transaction_id;    // 商户订单号    private String out_trade_no;    // 支付完成时间    private String time_end;    // 交易状态描述    private String trade_state_desc;}  查询订单接收参数（非必填）public class QueryOrderResponseExt extends QueryOrderResponse {    // 返回信息，非空则表示返回了错误信息    private String return_msg;    // 错误代码    private String err_code;    // 错误代码描述    private String err_code_des;    // 设备号    private String device_info;    // 是否关注公众号    private String is_subscribe;    // 应结订单金额    private String settlement_total_fee;    // 标价币种    private String fee_type;    // 现金支付币种    private String cash_fee_type;    // 附加数据    private String attach;}生成订单信息  SOPConstants.WECHAT_PAY_APP_ID 是公众账号 id  SOPConstants.WECHAT_PAY_MCH_ID 是商户id  WechatUtil.makeNonceStr() 是生成的随机字符串  WechatUtil.makeSign(BeanMap.create(ext)) 是根据请求参数制作签名  WechatUtil.truncateDataToXML(QueryOrderRequestExt.class, ext) 是将数据转换为 XML 形式private String generateOrderInfo(Long orderId) {    OrderDTO order = orderManageService.getOrder(orderId);    QueryOrderRequestExt ext = new QueryOrderRequestExt();    ext.setAppid(SOPConstants.WECHAT_PAY_APP_ID);    ext.setMch_id(SOPConstants.WECHAT_PAY_MCH_ID);    ext.setOut_trade_no(order.getCode());    ext.setNonce_str(WechatUtil.makeNonceStr());    ext.setSign(WechatUtil.makeSign(BeanMap.create(ext)));    return WechatUtil.truncateDataToXML(QueryOrderRequestExt.class, ext);}向微信发起订单查询请求  SOPConstants.WECHAT_PAY_QUERY_URL 是微信订单查询的请求 URL  WechatConnection.connect() 是向微信发起请求的通用方法  只有 ext.getResult_code() ext.getResult_code()  ext.getTrade_state() 的值都是 SUCCESS 才能确定订单支付成功public Boolean getPayResult(Long orderId) {    String orderInfo = generateOrderInfo(orderId);    QueryOrderResponseExt ext = null;    try {        ext = (QueryOrderResponseExt) WechatConnection.connect(SOPConstants.WECHAT_PAY_QUERY_URL, orderInfo, QueryOrderResponseExt.class);    } catch (IOException e) {        logger.error("微信查询订单" + orderId + "失败！", e);    }    if (ext == null) {        return false;    }    if (WechatConnection.SUCCESS_CODE.equals(ext.getResult_code())) {        if (WechatConnection.SUCCESS_CODE.equals(ext.getResult_code()) &amp;&amp; WechatConnection.SUCCESS_CODE.equals(ext.getTrade_state())) {            // 更新订单状态            orderPayService.updateOrderInfo(ext.getOut_trade_no(), OrderPay.wchatPay.getCode());            return true;        } else {            logger.error("订单" + orderId + "交易失败，交易状态：" + ext.getTrade_state());            return false;        }    } else {        logger.error("订单" + orderId + "查询失败！");        return false;    }}微信支付相关操作工具类  该工具类目前提供了数据转换、签名生成、随机数生成的通用方法public class WechatUtil {    private static Logger logger = LoggerFactory.getLogger(WechatUtil.class);    /**     * 数据转换为xml格式     *     * @param object     * @param obj     * @return     */    public static String truncateDataToXML(Class&lt;?&gt; object, Object obj) {        XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));        xStream.alias("xml", object);        return xStream.toXML(obj);    }    /**     * 数据转换为对象     *     * @param object     * @param str     * @return     */    public static Object truncateDataFromXML(Class&lt;?&gt; object, String str) {        XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));        xStream.alias("xml", object);        return xStream.fromXML(str);    }    /**     * 生成随机字符串     *     * @return     */    public static String makeNonceStr() {        StringBuffer str = new StringBuffer(DateUtil.getSysDateString("yyyyMMddHHmmssS"));        str.append((new Random().nextInt(900) + 100));        return str.toString();    }    /**     * 拼接签名数据     *     * @return     */    public static String makeSign(BeanMap beanMap) {        SortedMap&lt;String, String&gt; signMaps = Maps.newTreeMap();        for (Object key : beanMap.keySet()) {            Object value = beanMap.get(key);            // 排除空数据            if (value == null) {                continue;            }            signMaps.put(key + "", String.valueOf(value));        }        // 生成签名        return generateSign(signMaps);    }    /**     * 生成签名     *     * @param signMaps     * @return     * @throws Exception     */    public static String generateSign(SortedMap&lt;String, String&gt; signMaps) {        StringBuffer sb = new StringBuffer();        // 字典序        for (Map.Entry signMap : signMaps.entrySet()) {            String key = (String) signMap.getKey();            String value = (String) signMap.getValue();            // 为空不参与签名、参数名区分大小写            if (null != value &amp;&amp; !"".equals(value) &amp;&amp; !"sign".equals(key) &amp;&amp; !"key".equals(key)) {                sb.append(key).append("=").append(value).append("&amp;");            }        }        // 拼接key        sb.append("key=").append(SOPConstants.WECHAT_PAY_KEY);        // MD5加密        return Objects.requireNonNull(encoderByMd5(sb.toString())).toUpperCase();    }    /**     * 利用MD5进行加密     *     * @param str 待加密的字符串     * @return 加密后的字符串     */    private static String encoderByMd5(String str) {        // 生成一个MD5加密计算摘要        MessageDigest md = null;        try {            md = MessageDigest.getInstance("MD5");        } catch (NoSuchAlgorithmException e) {            logger.error("MD5加密失败！", e);        }        if (md == null) {            return null;        }        // 计算md5函数        md.update(str.getBytes());        // digest()最后确定返回md5 hash值，返回值为8为字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符        // BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值        return new BigInteger(1, md.digest()).toString(16);    }}微信支付请求建立类public class WechatConnection {    // 成功标志    public static final String SUCCESS_CODE = "SUCCESS";    /**     * 建立微信连接，并返回结果     *     * @param url     * @param info     * @param object     * @return     * @throws IOException     */    public static Object connect(String url, String info, Class&lt;?&gt; object) throws IOException {        // 建立连接        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();        conn.setConnectTimeout(8000);        conn.setRequestMethod("POST");        conn.setDoOutput(true);        // 发送数据        BufferedOutputStream bos = new BufferedOutputStream(conn.getOutputStream());        bos.write(info.getBytes());        bos.flush();        bos.close();        // 获取数据        BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));        // 接收数据        String line;        StringBuffer str = new StringBuffer();        while ((line = reader.readLine()) != null) {            str.append(line);        }        return WechatUtil.truncateDataFromXML(object, str.toString());    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> wechatpay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot从数据库加载配置信息]]></title>
      <url>/java/springboot/hibernate/2017/12/31/SpringBoot%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
      <content type="text"><![CDATA[  Spring Boot 通过@Value注解可实现获取配置文件中的数据，而配置文件中的数据可以通过修改MutablePropertySources从数据库注入该示例基于Hibernate实现实体类  根据Hibernate的配置，实体类对应数据库中的表即可@Entity@Table(name = "sys_config")@Inheritance(strategy = InheritanceType.SINGLE_TABLE)public class Config implements Serializable {    @Id    private Long id;    @Column    private String code;    @Column    private String value;    @Column    private String name;    @Column    private String description;  ...}服务类  服务类用于从数据库中获取列表信息@Servicepublic class SystemConfigService extends SimpleHibernateService&lt;Config, Long&gt; {   ...}配置类  该配置类会在系统启动时自动加载  根据内部逻辑会将从数据库取出的列表信息注入到MutablePropertySources属性集合中  动态注入的属性集合无需有对应的 .properties 文件存在@Configurationpublic class SystemConfig {    @Autowired    private ConfigurableEnvironment environment;    @Autowired    private SystemConfigService service;    @PostConstruct    public void initDatabasePropertySourceUsage() {        // 获取系统属性集合        MutablePropertySources propertySources = environment.getPropertySources();        try {            // 从数据库获取自定义变量列表            Map&lt;String, String&gt; collect = service.getAll().stream().collect(Collectors.toMap(Config::getCode, Config::getValue));            // 将转换后的列表加入属性中            Properties properties = new Properties();            properties.putAll(collect);            // 将属性转换为属性集合，并指定名称            PropertiesPropertySource constants = new PropertiesPropertySource("system-config", properties);            // 定义寻找属性的正则，该正则为系统默认属性集合的前缀            Pattern p = Pattern.compile("^applicationConfig.*");            // 接收系统默认属性集合的名称            String name = null;            // 标识是否找到系统默认属性集合            boolean flag = false;            // 遍历属性集合            for (PropertySource&lt;?&gt; source : propertySources) {                // 正则匹配                if (p.matcher(source.getName()).matches()) {                    // 接收名称                    name = source.getName();                    // 变更标识                    flag = true;                    break;                }            }            if (flag) {                // 找到则将自定义属性添加到该属性之前                propertySources.addBefore(name, constants);            } else {                // 没找到默认添加到第一位                propertySources.addFirst(constants);            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }}工具类  由于Spring Boot不支持静态变量的自动注入，所以需要使用一个非静态的setter方法将通过@Value注解获取到的属性信息赋值给对应静态变量  @DependsOn({"systemConfig"}) 的意思是说 Constants 依赖于 SystemConfig ，所以需要确保 SystemConfig 在 Constants 之前加载@Configuration@DependsOn({"systemConfig"})public class Constants {    // 资源服务器地址    public static String RESOURCE_SERVER_URL;    @Value("${resource.server.url}")    public void setResourceServerUrl(String resourceServerUrl) {        RESOURCE_SERVER_URL = resourceServerUrl;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot&Vue表单文件上传]]></title>
      <url>/java/springboot/vue/2017/12/31/SpringBoot&Vue%E8%A1%A8%E5%8D%95%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      <content type="text"><![CDATA[  Spring Boot + Vue 的文件上传本身没有什么难点，但如果涉及到是一个表单对象中存在文件，则会比较繁琐后端实体类  Spring Boot中对于文件的接收类型和Spring MVC保持一致，使用MultipartFile  与Spring MVC不同的是Spring Boot进行文件上传操作不需要添加配置信息，Spring Boot自身已经默认开启了文件上传功能...public class Work {  ...    @Transient    private MultipartFile referenceFile;  ...}后端接收请求的接口  SpringBoot与Vue进行集成，使用axios进行异步请求发送，对于接收对象类型的数据一般使用@RequestBody的注解将对象解析为JSON格式  但是MultipartFile类型的文件无法转换为JSON格式，所以此处需要使用@ModelAttribute的注解接收对象信息...@RestController@RequestMapping("/${contextPath}/works")public class WorkController extends SimpleController&lt;Work, WorkService&gt; {  ...    @ApiOperation("保存作业")    @PostMapping("")    public ResponseData saveRule(@ModelAttribute Work work) {  return workService.save(work);    }  ...}前端对文件数据的处理  使用默认的文件输入框进行文件上传会影响美观，所以通常将输入框隐藏后通过点击按钮进行调用  由于文件格式的input属性是只读的，所以无法使用v-model对其数据的更改进行实时获取  所以需要通过@change对其数据的更改进行监听，并赋值给表单的对应属性&lt;template&gt;  &lt;in-form ref="inForm" :form="work" :rules="rules" :is-file="true"&gt;    ...    &lt;el-button type="success" v-else @click="uploadReferenceFile"&gt;    上传答案 &lt;span v-text="work.reference"&gt;&lt;/span&gt;    &lt;input type="file" class="upload-file" ref="referenceFile" @change="setReferenceFile"&gt;    &lt;/el-button&gt;    ...  &lt;/in-form&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;...  export default {    ...    methods: {...      // 上传参考答案      uploadReferenceFile () {        this.$refs.referenceFile.click()      },      // 设置参考答案      setReferenceFile (item) {        let currentFile = item.target.files[0]        this.work.reference = currentFile.name        this.work.referenceFile = currentFile      }...  }&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt;  .upload-file    display none&lt;/style&gt;前端发起请求的方式  文件格式的数据无法通过JSON格式进行传递，所以需要使用FormData对表单数据进行转换  但FormData只能接受String和File格式的数据，对应Object格式的数据无法处理  如果涉及到Object格式的数据则需要前后端配合进行数据转换  通常情况下对象中关联的对象只涉及到其中的某一个值，所以前端在处理时可以单独将该值进行传递  后端在接收到该值后，可以在其Setter方法中将数据赋予对应的对象即可export function save ({url, data}, isFile) {  // 带文件的上传功能  if (isFile) {    let formData = new FormData()        // 遍历传入的数据    for (let key in data) {      // 获取当前值      let currentData = data[key]        // 对于空值进行过滤      if (currentData === '') {        continue      }            // 将对象中的键值对传入formData中      formData.append(key, currentData)    }        data = formData  }    return fetch({    url: url,    method: config.POST,    data  })}限制文件大小  只需要在::application.properties::中添加如下配置即可spring.http.multipart.max-file-size=10MBspring.http.multipart.max-request-size=10MB]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> vue </tag>
        
          <tag> form </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Maven针对SpringBoot的多项目依赖配置]]></title>
      <url>/java/maven/springboot/2017/12/16/Maven%E9%92%88%E5%AF%B9Spring-Boot%E7%9A%84%E5%A4%9A%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  在Spring Boot中对于多项目依赖配置，可通过Maven实现创建一个父级的pom文件  在该pom中指定其 &lt;groupId/&gt;、&lt;artifactId/&gt; 、&lt;version/&gt;  &lt;packaging/&gt; 必须是pom  &lt;parent/&gt; 需要引入 spring-boot-starter-parent 表示继承Spring Boot的父级配置  &lt;modules/&gt; 中依次引入后续需要相互依赖的项目  &lt;dependencyManagement/&gt; 中对上述引入的项目进行完成依赖配置&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;        &lt;groupId&gt;com.innovaee.hts.parent&lt;/groupId&gt;    &lt;artifactId&gt;innovaee-hts-parent&lt;/artifactId&gt;    &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;name&gt;innovaee-hts-parent&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;1.5.8.RELEASE&lt;/version&gt;    &lt;/parent&gt;    &lt;modules&gt;        &lt;module&gt;hts-admin-backend&lt;/module&gt;  ...    &lt;/modules&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.innovaee.hts&lt;/groupId&gt;                &lt;artifactId&gt;hts-admin-backend&lt;/artifactId&gt;                &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;            &lt;/dependency&gt;  ...        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;&lt;/project&gt;在各个子项目的pom中对依赖关系进行配置  父级不再指向Spring Boot的父级，而是上述自定义父级&lt;parent&gt;    &lt;groupId&gt;com.innovaee.hts.parent&lt;/groupId&gt;    &lt;artifactId&gt;innovaee-hts-parent&lt;/artifactId&gt;    &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt;  从父级中获取需要的依赖配置&lt;dependency&gt;    &lt;groupId&gt;org.tshark.core&lt;/groupId&gt;    &lt;artifactId&gt;tshark-core&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  ...&lt;/dependency&gt;在需要被打包成jar包的项目中引入Spring Boot的编译插件&lt;build&gt;    &lt;finalName&gt;hts-admin&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;在父级pom所在的目录中执行打包命令对项目进行打包mvn clean package -Dmaven.test.skip=true]]></content>
      <categories>
        
          <category> java </category>
        
          <category> maven </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> maven </tag>
        
          <tag> springboot </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java支付宝扫码支付[旧]]]></title>
      <url>/java/pay/2017/02/14/Java%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98-%E6%97%A7/</url>
      <content type="text"><![CDATA[  在实际开发过程中，首先采用当面付模式进行开发，但没有成功，个人认为当面付更适合线下模式之后改用即时到账模式才成功接入支付宝扫码支付功能以下内容是基于即时到账模式开发要使用支付宝即时到账接口，首先需要签约即时到账产品， 申请地址审核进度通常需要1个工作日，但实际几小时即可之后需要获取和设置如下关键信息pid:2088621150311111          合作伙伴身份IDkey:zrqyf6dfli7dvji4mmi4sw1111111111      MD5密钥notify_url:http://127.0.0.1:8080/sop/order/notify/ali    异步通知回调地址return_url:http://127.0.0.1:8080/sop/order/notify/ali/return  同步通知回调地址官网支付宝-开放平台模式  当面付 ，消费者扫描商户二维码完成支付。并不适用于Web网页端扫码支付  即时到账 ，用户在线向开发者的支付宝账号支付资金。Web网页端扫码支付首选开发步骤  下载支付宝提供的即时到账 DEMO          按下图所示将alipay下所有文件复制到项目开发目录，支付宝已将接口的调用、请求、验签等操作完成，我们只需要包装好数据后调用即可        打开AlipayConfig.java，将其中关键信息替换成之前准备好的内容          除了下述四个信息，其他内容均不需要修改      ** partner**即pid，key即md5密钥，都可以在 mapi网关产品密钥 获取      notify_url是支付宝异步通知链接，由支付宝主动调用，一旦用户完成支付，即调用该地址      不可添加自定义参数      必须保证外网可正常访问      使用POST方式发送/接收数据      没有时间限制      如果是https，则必须安装ssl证书，并且需要正规的证书机构签发，自签名的无法识别      return_url，是支付宝同步跳转通知，用户完成支付后，在支付页面完成跳转      不可添加自定义参数      必须保证外网可正常访问，但可在本机测试      使用GET方式发送/接收数据      一分钟超时      // 合作身份者ID，签约账号，以2088开头由16位纯数字组成的字符串，查看地址：https://b.alipay.com/order/pidAndKey.htmpublic static String partner = SOPConstants.ALI_PAY_PARTNER_ID; // MD5密钥，安全检验码，由数字和字母组成的32位字符串，查看地址：https://b.alipay.com/order/pidAndKey.htmpublic static String key = SOPConstants.ALI_PAY_MD5_KEY;// 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问public static String notify_url = SOPConstants.ALI_PAY_NOTIFY_URL;// 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问public static String return_url = SOPConstants.ALI_PAY_RETURN_URL;  在订单支付页面创建一个空的div，用于接收调用即时到账接口返回的表单数据$.ts.doAction("/api/order/pay/ali", {    orderId: orderId}, function () {    // 提交表单内容    $orderSubmitPanel.find("#returnAli").append(this.data);   // 打开订单状态轮询页面，确保支付完成后，支付页面能自动跳转    $.ts.openModalWindow("/api/order/pay/ali/tip/" + orderId, 350, 300);}, "", "", "");@RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic ResponseData ali(HttpServletRequest request, @RequestParam("orderId") final String orderId) {    SimpleActionHandler actionHandler = new SimpleActionHandler(request) {        @Override        protected void doHandle(ResponseData responseData) throws Exception {            responseData.setData(orderPayService.aliPay(IdEncoder.decodeId(orderId)));        }    };    return actionHandler.handle();}  按照 请求参数说明 包装请求参数，并建立请求          建立请求的操作支付宝已在AlipaySubmit.java中实现，只需要调用其中buildRequest()方法并传入参数即可      public String aliPay(Long orderId) {    // 获取订单信息    OrderDTO order = orderManageService.getOrder(orderId);    // 包装请求参数    Map&lt;String, String&gt; params = Maps.newHashMap();    // 调用接口    params.put("service", AlipayConfig.service);    // 签约账号id    params.put("partner", AlipayConfig.partner);    // 收款支付账号，默认与签约账号相同    params.put("seller_id", AlipayConfig.seller_id);    // 编码格式，支付GBK和UTF-8    params.put("_input_charset", AlipayConfig.input_charset);    // 支付类型    params.put("payment_type", AlipayConfig.payment_type);    // 异步通知回调地址    params.put("notify_url", AlipayConfig.notify_url);    // 同步通知跳转地址    params.put("return_url", AlipayConfig.return_url);    // 防钓鱼时间戳    params.put("anti_phishing_key", AlipayConfig.anti_phishing_key);    // 客户端IP    params.put("exter_invoke_ip", super.getClientIP());    // 订单号    params.put("out_trade_no", order.getCode());    // 标题    params.put("subject", "轻实训-" + order.getName());    // 金额    params.put("total_fee", String.valueOf(order.getPrice()));    // 建立请求    return AlipaySubmit.buildRequest(params, "get", "确认");}  由于调用即时到账接口返回的表单数据会自动提交，而接收表单数据的div是在订单提交页面，因此按照表单提交默认方式，会导致订单提交页面被替换成支付宝扫码页面  所以需要修改AlipaySubmit.java中的buildRequest()方法，在其拼接的表单中加入target=“_blank”，让表单提交时在新页面打开public static String buildRequest(Map&lt;String, String&gt; sParaTemp, String strMethod, String strButtonName) {    //待请求参数数组    Map&lt;String, String&gt; sPara = buildRequestPara(sParaTemp);    List&lt;String&gt; keys = new ArrayList&lt;String&gt;(sPara.keySet());    StringBuffer sbHtml = new StringBuffer();    sbHtml.append("&lt;form id=\"alipaysubmit\" name=\"alipaysubmit\" action=\"" + ALIPAY_GATEWAY_NEW                  + "_input_charset=" + AlipayConfig.input_charset + "\" method=\"" + strMethod                  + "\" target=\"_blank\"&gt;");    for (int i = 0; i &lt; keys.size(); i++) {        String name = (String) keys.get(i);        String value = (String) sPara.get(name);        sbHtml.append("&lt;input type=\"hidden\" name=\"" + name + "\" value=\"" + value + "\"/&gt;");    }    //submit按钮控件请不要含有name属性    sbHtml.append("&lt;input type=\"submit\" value=\"" + strButtonName + "\" style=\"display:none;\"&gt;&lt;/form&gt;");    sbHtml.append("&lt;script&gt;document.forms['alipaysubmit'].submit();&lt;/script&gt;");    return sbHtml.toString();}  用户通过支付宝扫描二维码完成支付后，支付宝会主动调用notify_url进行回执          由于回执时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该回执地址一个访问许可，否则会被安全框架屏蔽      @RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic String aliNotify(HttpServletRequest request) {    return orderPayService.aliNotify(request);}  接收并处理支付回执后，必须通知支付宝回执接收成功，否则支付宝会认为回执发送失败，并发送数次通知  支付宝发送异步通知后，如果没有获取到成功回执（返回success），则会按一定规律重发（4m,10m,10m,1h,2h,6h,15h）  接收支付宝的回执信息时，必须进行验签，改操作支付宝已实现，我们只需要调用AlipayNotify.java中的verify()方法即可  验签成功后需要判断操作状态，从回执参数中获取trade_status，参数值为TRADE_SUCCESS即为支付成功  还有一个订单状态是TRADE_FINISHED，该状态表示订单已完成，即超过三个月的退款期限，一旦订单到达这个状态，支付宝会再次调用notify_url进行回执，若业务系统没有退款流程，则无需处理该状态public String aliNotify(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 交易状态    String tradeStatus = request.getParameter("trade_status");    // 验签    if (AlipayNotify.verify(getNotifyData(request))) {        // 交易成功        if (tradeStatus.equals("TRADE_SUCCESS")) {            // 更新订单信息            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());        }        return "success";    } else {        return "fail";    }}  处理回执内容，用于验签private Map&lt;String, String&gt; getNotifyData(HttpServletRequest request, String method) throws Exception {    // 获取回执内容    Map requestParams = request.getParameterMap();    // 过滤回执内容    Map&lt;String, String&gt; params = Maps.newHashMap();    for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) {        String name = (String) iter.next();        String[] values = (String[]) requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        if (method.equals("notify")) {            params.put(name, valueStr);        } else {            params.put(name, new String(valueStr.getBytes("ISO-8859-1"), "utf-8"));        }    }    return params;}  用户通过支付宝扫描二维码完成支付后，在新打开的支付宝窗口会执行return_url进行跳转          由于跳转时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该跳转地址一个访问许可，否则会被安全框架屏蔽      public String aliReturn(HttpServletResponse response, HttpServletRequest request) throws Exception {    orderPayService.aliReturn(response, request);           // 跳转地址会通过输出流的方式关闭新窗口，所以无需返回任何内容    return null;}  接收跳转通知时，同样需要验签，以确保内容的安全性  为防止网络等不可预测原因导致异步回执没能成功接收，所以在接收跳转通知并验签通过以及状态判断成功后，同样需要对订单状态进行更新  如果用户完成支付后立即关闭页面，会导致同步跳转通知无法执行，所以不能完全依赖该通知确认订单状态  如果用户在支付页面扫码生成预下单订单，但并未直接付款，而是前往支付宝订单页重新付款，即使网页端支付页面未关闭，也无法执行该同步跳转通知  通过同步跳转通知更新订单状态，只是一种辅助措施，主要手段还是通过接受异步回执来处理订单状态  由于支付宝的扫码页面是在新窗口打开，在支付完成后并没有存在的必要，即可以通过输出流的方式关闭该窗口public void aliReturn(HttpServletResponse response, HttpServletRequest request) throws IOException {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 交易状态    String tradeStatus = request.getParameter("trade_status");    // 验签    if (AlipayNotify.verify(getNotifyData(request))) {        if (tradeStatus.equals("TRADE_FINISHED") || tradeStatus.equals("TRADE_SUCCESS")) {            // 更新订单信息            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());            // 页面跳转            response.setContentType("text/html;charset=gb2312");     // 通过输出流关闭窗口            PrintWriter writer = response.getWriter();            writer.println("&lt;html&gt;&lt;head&gt;&lt;title&gt; CLOSE &lt;/title&gt;&lt;/head&gt;");            writer.println("&lt;body&gt;");            writer.println("&lt;script type=\"text/javascript\"&gt;window.close();&lt;/script&gt;");            writer.println("&lt;/body&gt;&lt;/html&gt;");        }    }}  轮询订单状态，实现支付完成后页面自动跳转          由于支付回执是异步的，所以即使捕获到异步回执也无法实现支付页面的自动跳转      所以需要在支付页面打开时设置一个ajax轮询订单状态，一旦订单状态更新，则进行页面跳转      // 页面关闭$(“.modal-header button.close:last”).click(function () {    // 停止轮询    clearInterval(checkTimer);});// 轮询订单状态checkTimer = setInterval(function () {    // 窗口是否打开    if ($(“.order-pay-panel”).length &lt;= 0) {        clearInterval(checkTimer);    }    // 获取订单状态    $.ts.doAction(“/api/order/review/check/“, {        orderId: orderId    }, function () {        // 订单已支付        if (!this.data) {            $.ts.closeWindow();            g_index.loadMainContentWithState(“/order/manage”);        $.ts.toastr.success(“订单已支付成功！”);        }    }, “”, “”, “”);}, 3000);]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java微信扫码支付]]></title>
      <url>/java/pay/2017/02/11/Java%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/</url>
      <content type="text"><![CDATA[  以下内容是基于模式二开发在开发之前需要先到微信支付官网注册账号，并获取到以下信息appid:wx1137939101111111公众账号idmch_id:1438111111 商户号key:4Inn0va1eSxOnl1neqsxwuhan1111111密钥send_url:https://api.mch.weixin.qq.com/pay/unifiedorder统一下单APInotify_url:http://127.0.0.1:8080/sop/order/notify/wechat支付成功回调地址官网  微信支付官网  扫码支付开发者文档模式  需要在公众平台后台设置支付回调URL ，用于接收用户扫码后微信支付系统回调的productid和openid  直接调用统一下单API 即可，相对于模式一更为简洁定义接口对象  根据 统一下单接口API 定义四个对象，用于发送和接收数据UnifiedOrderRequest.java 统一下单请求参数-必填项public class UnifiedOrderRequest {    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 随机字符串，32位以内    private String nonce_str;    // 签名，遵循签名算法    private String sign;    // 商品描述，浏览器打开的网站主页title名称-商品概述    private String body;    // 商户订单号，32位以内，不重复    private String out_trade_no;    // 标价金额，单位分    private Integer total_fee;    // 终端ip，填写调用端的ip    private String spbill_create_ip;    // 通知地址，接收支付结果的会掉地址，必须外网可访问    private String notify_url;    // 交易类型，JSAPI--公众号支付、NATIVE--原生扫码支付、APP--app支付    private String trade_type;}UnifiedOrderRequestExt.java 统一下单请求参数-非必填项public class UnifiedOrderRequestExt extends UnifiedOrderRequest {    // 设备号，网页端填写WEB    private String device_info;    // 签名类型，默认MD5    private String sign_type;    // 商品详情，JSON格式    private String detail;    // 附加数据，可作为自定义参数使用    private String attach;    // 标价币种，默认CNY    private String fee_type;    // 交易起始时间，格式为yyyyMMddHHmmss    private String time_start;    // 交易结束时间，最短失效时间必须间隔5分钟    private String time_expire;    // 商品id，trade_type=NATIVE时，必填    private String product_id;    // 指定支付方式，no_credit可限制使用信用卡    private String limit_pay;    // 用户标识,trade_type=JSAPI时，必填    private String openid;}UnifiedOrderResponse.java 统一下单返回参数-必填项public class UnifiedOrderResponse {    // 返回状态码，通信标识，SUCCESS/FAIL    private String return_code;    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 随机字符串    private String nonce_str;    // 签名    private String sign;    // 业务结果，交易标识，SUCCESS/FAIL    private String result_code;    // 交易类型，JSAPI，NATIVE，APP    private String trade_type;    // 预支付交易会话标识，有效值2小时    private String prepay_id;}UnifiedOrderResponseExt.java 统一下单返回参数-非必填项public class UnifiedOrderResponseExt extends UnifiedOrderResponse {    // 返回信息，非空则表示返回了错误信息    private String return_msg;    // 设备号    private String device_info;    // 错误代码    private String err_code;    // 错误代码描述    private String err_code_des;    // 二维码连接，trade_type=NATIVE时返回    private String code_url;}定义一个标签用于显示二维码  调用统一下单API成功后，会返回一系列XML数据，其中code_url表示返回的预支付交易链接，可将其生成二维码图片&lt;div class="order-pay-panel order-wechat-panel"&gt;    &lt;div class="modal-header"&gt;        &lt;button type="button" class="close" data-dismiss="modal" aria-hidden="true"&gt;×&lt;/button&gt;        &lt;h4 class="modal-title"&gt;            &lt;i class="icon-th-large"&gt;&lt;/i&gt; 微信支付        &lt;/h4&gt;    &lt;/div&gt;    &lt;div class="modal-body"&gt;        &lt;div class="wechat-qrcode-panel margin-bottom-10"&gt;            &lt;img src="${ctx}/api/order/pay/wechat/qrcode?orderId=${order.hexId}"&gt;        &lt;/div&gt;        &lt;div class="wechat-description-panel"&gt;            &lt;p class="text-muted"&gt;使用微信扫描二维码完成支付&lt;/p&gt;            &lt;p class="text-danger"&gt;￥${order.price}&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;根据统一下单API的要求生成订单  将系统内部订单号传入请求参数的out_trade_no中，用于后续操作的唯一标识符  请求参数中的sign是验证参数合法性的唯一标识，需要根据 微信支付签名算法 来生成  使用XStream将对象转换为XML，由于微信的请求参数中大量使用下划线，但下划线在XStream中是关键字，因此需要把下划线转换为双下划线，避免报错private String generateOrderInfo(Long orderId) throws Exception {    // 获取订单信息    OrderDTO order = orderManageService.getOrder(orderId);    // 生成订单    UnifiedOrderRequestExt ext = new UnifiedOrderRequestExt();    ext.setAppid(SOPConstants.WECHAT_PAY_APP_ID);    ext.setMch_id(SOPConstants.WECHAT_PAY_MCH_ID);    ext.setBody("轻实训-" + order.getName());    ext.setOut_trade_no(order.getCode());    ext.setTotal_fee(order.getPrice() * 100);    ext.setSpbill_create_ip(super.getClientIP());    ext.setNotify_url(SOPConstants.WECHAT_PAY_NOTIFY_URL);    ext.setTrade_type("NATIVE");    ext.setProduct_id(order.getHexId());  // 生成32位随机数    ext.setNonce_str(makeNonceStr());  // 签名，按照指定签名算法生成    ext.setSign(makeSign(ext));    // 格式转换为XML    XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));    xStream.alias("xml", UnifiedOrderRequestExt.class);    return xStream.toXML(ext);}  生成32位随机数，方式为当前时间加随机数private String makeNonceStr() {    StringBuffer str = new StringBuffer(DateUtil.getSysDateString("yyyyMMddHHmmssS"));    str.append((new Random().nextInt(900) + 100));    return str.toString();}  拼接签名数据private String makeSign(UnifiedOrderRequestExt ext) throws Exception {    // 根据规则创建可排序的map集合    SortedMap&lt;String, String&gt; signMaps = Maps.newTreeMap();    signMaps.put("appid", ext.getAppid());    signMaps.put("body", ext.getBody());    signMaps.put("mch_id", ext.getMch_id());    signMaps.put("nonce_str", ext.getNonce_str());    signMaps.put("notify_url", ext.getNotify_url());    signMaps.put("out_trade_no", ext.getOut_trade_no());    signMaps.put("spbill_create_ip", ext.getSpbill_create_ip());    signMaps.put("trade_type", ext.getTrade_type());    signMaps.put("total_fee", ext.getTotal_fee().toString());    signMaps.put("product_id", ext.getProduct_id());    // 生成签名    return generateSign(signMaps);}  按照签名算法生成签名private String generateSign(SortedMap&lt;String, String&gt; signMaps) throws Exception {    StringBuffer sb = new StringBuffer();    // 字典序    for (Map.Entry signMap : signMaps.entrySet()) {        String key = (String) signMap.getKey();        String value = (String) signMap.getValue();        // 为空不参与签名、参数名区分大小写        if (null != value &amp;&amp; !"".equals(value) &amp;&amp; !"sign".equals(key) &amp;&amp; !"key".equals(key)) {            sb.append(key + "=" + value + "&amp;");        }    }    // 拼接key    sb.append("key=" + SOPConstants.WECHAT_PAY_KEY);    // MD5加密    return encoderByMd5(sb.toString()).toUpperCase();}调用统一下单API  将生成的订单发送给微信，同时接收微信的返回参数，读取其中的code_url  如果发送的订单信息不符合要求，则会在返回参数中告知问题  订单合法，返回参数中return_code=SUCCESS return_msg=OK result_code=SUCCESS  订单不合法，返回参数中return_code=FAIL return_msg=具体错误原因private String sendHttpRequest(String orderInfo) throws IOException {    // 建立连接    HttpURLConnection conn = (HttpURLConnection) new URL(SOPConstants.WECHAT_PAY_SEND_URL).openConnection();    conn.setRequestMethod("POST");    conn.setDoOutput(true);    // 发送数据    BufferedOutputStream bos = new BufferedOutputStream(conn.getOutputStream());    bos.write(orderInfo.getBytes());    bos.flush();    bos.close();    // 获取数据    BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));    // 接收数据    String line;    StringBuffer str = new StringBuffer();    while ((line = reader.readLine()) != null) {        str.append(line);    }    // XML数据转换为对象    XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));    xStream.alias("xml", UnifiedOrderResponseExt.class);    UnifiedOrderResponseExt ext = (UnifiedOrderResponseExt) xStream.fromXML(str.toString());    // 判断数据有效性    if (null != ext &amp;&amp; "SUCCESS".equals(ext.getReturn_code()) &amp;&amp; "SUCCESS".equals(ext.getResult_code())) {        return ext.getCode_url();    }    return null;}根据返回的code_url生成二维码图片  二维码的生成采用的是Google的 GitHub - zxing/zxing at zxing-3.0.0@RequestMapping(value = “/wechat/qrcode”, method = RequestMethod.GET)public void wechatQRCode(HttpServletResponse response, @RequestParam("orderId") String orderId) {    try {        // 初始化数据        int width = 240;        int height = 240;        String format = "png";  // 获取二维码链接        String codeUrl = orderPayService.getQRCodeUrl(IdEncoder.decodeId(orderId));        Hashtable htable = new Hashtable();        htable.put(EncodeHintType.CHARACTER_SET, "UTF-8");        // 生成图片        BitMatrix matrix = new MultiFormatWriter().encode(codeUrl, BarcodeFormat.QR_CODE, width, height, htable);        OutputStream out = response.getOutputStream();        // 输出图片        MatrixToImageWriter.writeToStream(matrix, format, out);        out.flush();        out.close();    } catch (Exception e) {        logger.error(e.getMessage(), e);    }}  需要准备的包信息&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;core&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;javase&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;接收回调  用户通过微信扫描二维码并支付成功后，微信会根据之前订单中的notify_url回调地址进行回执  此处提供给微信的回调地址必须是外网可访问的，否则无法正常接收回执信息  由于回执时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该回执地址一个访问许可，否则会被安全框架屏蔽  发送回执是异步进行，由于网络等不确定因素，微信不保证回执一定成功  微信会通过一定的策略定期重启发送通知，通知频率为15/15/30/180/1800/1800/1800/1800/3600，单位：秒  虽然是异步回执，但并不需要采用ajax异步接收的方式来接收数据@RequestMapping(value = "/wechat")public String wechatNotify(HttpServletResponse response, HttpServletRequest request) throws Exception {    orderPayService.notify(response, request);  // 此处的返回值无效，需要在支付页面通过轮询获取支付结果，微信支付本身无法实现自动跳转    return "/redirect:/login";}处理回执内容  数据是通过IO流发送，所以也需要通过IO流接收  微信发送回执用户接收后，需要通过IO流的方式告知微信接收成功，否则微信认为回执失败  接收到回执信息后，最关键是验证签名来确保信息的有效性和安全性，验签的方式和发送订单签名的方式一致  验签成功，且回执信息中result_code=SUCCESS，则表示回执信息有效  从回执信息中可获取到out_trade_no，这是之前发送的用户订单唯一标识符，通过该信息可以继续处理用户订单  所有流程处理完毕后，必须以XML格式编写回执信息，并通过IO流的方式告知微信回执接收成功public void notify(HttpServletResponse response, HttpServletRequest request) throws Exception {    // 读取回执数据    HashMap&lt;String, String&gt; notifyMaps = readNotify(request);    // 回执数据验证    if (notifyMaps == null || notifyMaps.isEmpty()) {        logger.error("未收到回执数据！");        throw new TSharkException("未收到回执数据！");    }    // 挑选数据    SortedMap&lt;String, String&gt; notifySorts = sortNotify(notifyMaps);    // 重新签名    String sign = generateSign(notifySorts);    // 获取回执签名    String notifySign = notifySorts.get("sign").toUpperCase();    // 验证签名    if (!sign.equals(notifySign)) {        logger.error("签名验证失败！");        throw new TSharkException("签名验证失败！");    }    String resXml;    // 验证回执    if ("SUCCESS".equals(notifySorts.get("result_code"))) {        // 更新订单信息        updateOrderInfo(notifySorts.get("out_trade_no"));        // 微信回执        resXml = "&lt;xml&gt;" +                "&lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;" +                "&lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;" +                "&lt;/xml&gt; ";    } else {        resXml = "&lt;xml&gt;" +                "&lt;return_code&gt;&lt;![CDATA[FAIL]]&gt;&lt;/return_code&gt;" +                "&lt;return_msg&gt;&lt;![CDATA[报文为空]]&gt;&lt;/return_msg&gt;" +                "&lt;/xml&gt; ";    }    BufferedOutputStream out = new BufferedOutputStream(response.getOutputStream());    out.write(resXml.getBytes());    out.flush();    out.close();}  从IO流中读取回执信息private HashMap&lt;String, String&gt; readNotify(HttpServletRequest request) throws Exception {    // 读取参数    InputStream inputStream = request.getInputStream();    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, "UTF-8"));    // 接收数据    String line;    StringBuffer str = new StringBuffer();    while ((line = reader.readLine()) != null) {        str.append(line);    }    reader.close();    inputStream.close();    // XML转换Map    return fromXml(str.toString());}  读取的回执信息时XML格式，需要通过jDom的SAXBuilder解析为Mapprivate HashMap&lt;String, String&gt; fromXml(String xml) throws Exception {    xml = xml.replaceFirst("encoding=\".*\"", "encoding=\"UTF-8\"");    if (null == xml || "".equals(xml)) {        return null;    }    HashMap&lt;String, String&gt; m = Maps.newHashMap();    InputStream in = new ByteArrayInputStream(xml.getBytes("UTF-8"));    SAXBuilder builder = new SAXBuilder();    Document doc = builder.build(in);    Element root = doc.getRootElement();    List list = root.getChildren();    Iterator it = list.iterator();    while (it.hasNext()) {        Element e = (Element) it.next();        String k = e.getName();        String v = "";        List children = e.getChildren();        if (children.isEmpty()) {            v = e.getTextNormalize();        } else {            v = getXmlChildren(children);        }        m.put(k, v);    }    //关闭流    in.close();    return m;}private String getXmlChildren(List children) {    StringBuffer sb = new StringBuffer();    if (!children.isEmpty()) {        Iterator it = children.iterator();        while (it.hasNext()) {            Element e = (Element) it.next();            String name = e.getName();            String value = e.getTextNormalize();            List list = e.getChildren();            sb.append("&lt;" + name + "&gt;");            if (!list.isEmpty()) {                sb.append(getXmlChildren(list));            }            sb.append(value);            sb.append("&lt;/" + name + "&gt;");        }    }    return sb.toString();}轮询订单状态，实现支付完成后页面自动跳转  由于支付回执是异步的，所以即使捕获到异步回执也无法实现支付页面的自动跳转  所以需要在支付页面打开时设置一个ajax轮询订单状态，一旦订单状态更新，则进行页面跳转// 页面关闭$(".modal-header button.close:last").click(function () {    // 停止轮询    clearInterval(checkTimer);});// 轮询订单状态checkTimer = setInterval(function () {    // 窗口是否打开    if ($(".order-pay-panel").length &lt;= 0) {        clearInterval(checkTimer);    }    // 获取订单状态    $.ts.doAction("/api/order/review/check/", {        orderId: orderId    }, function () {        // 订单已支付        if (!this.data) {            $.ts.closeWindow();            g_index.loadMainContentWithState("/order/manage");      $.ts.toastr.success("订单已支付成功！");        }    }, "", "", "");}, 3000);]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> wechatpay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
