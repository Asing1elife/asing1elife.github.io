<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[Java 支付宝扫码支付[新]]]></title>
      <url>/java/2018/03/31/Java-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98-%E6%96%B0/</url>
      <content type="text"><![CDATA[  支付宝老版本的 Web 端扫码支付产品为即时到账，更新到新版后现在的产品为电脑网站支付官网电脑网站支付快速接入准备数据  电脑网站支付 应用需要在开发者页面端进行申请和签约  应用签约成功之后需要获取以下信息          app_id: 签约成功的应用唯一标识      app_private_key: 通过 RSA 密钥生成的应用私钥，由开发者自己通过签名软件生成[支付宝提供]      alipay_public_key: 通过应用私钥和公钥生成的支付宝公钥，由支付宝自动生成      下载 Java 版 SDK  前往 电脑网站支付 SDK 获取 下载 Java 的 SDK  该 SDK 目前不支持 Maven 方式引入，只能通过本地引入  正常开发模式只需要引入 alipay-sdk-java-3.0.0.jar 即可获取支付宝客户端  支付宝客户端是调用所有接口的前置条件，所以应该放置在顶层父类做一次初始化  SOPConstants.ALI_PAY_SEND_URL 是该支付方式的统一请求接口，值为 https://openapi.alipay.com/gateway.dopublic class AliCoreServiceImpl extends OrderCoreServiceImpl {    // 参数返回格式    private static final String ALI_PAY_FORMAT = "json";    // 编码集，支持 GBK/UTF-8    protected static final String ALI_PAY_CHARSET = "utf-8";    // 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2/RSA ，推荐使用 RSA2    protected static final String ALI_PAY_SIGN_TYPE = "RSA2";    // 订单支付成功状态    protected static final String TRADE_STATUS_SUCCESS = "TRADE_SUCCESS";    // 订单支付结束状态    protected static final String TRADE_STATUS_FINISHED = "TRADE_FINISHED";    // 支付宝客户端    protected static AlipayClient alipayClient;    static {        // 初始化支付宝客户端        alipayClient = new DefaultAlipayClient(                SOPConstants.ALI_PAY_SEND_URL,                SOPConstants.ALI_PAY_APP_ID,                SOPConstants.ALI_PAY_PRIVATE_KEY,                ALI_PAY_FORMAT,                ALI_PAY_CHARSET,                SOPConstants.ALI_PAY_PUBLIC_KEY,                ALI_PAY_SIGN_TYPE);    }}发起支付宝付款页面请求  新版的扫码支付对请求参数和响应参数都做了封装，只需要传入对应参数值即可  SOPConstants.ALI_PAY_RETURN_URL 是支付宝付款成功需要的同步回执地址  SOPConstants.ALI_PAY_NOTIFY_URL 是支付宝付款成功需要的异步回执地址  以上两个地址都需要能够外网访问  该请求方式是通过拼接请求使用 iframe 获取支付宝的付款二维码          通过客户端发起请求时不使用一般的 pageExecute() 而使用 sdkExecute()      sdkExecute() 获取的是请求之后的参数值，所以还需要拼接请求地址      SOPConstants.ALI_PAY_SEND_URL 是支付请求地址      public class AliPayServiceImpl extends AliCoreServiceImpl {    public String aliPay(Long orderId) {        // 创建统一下单请求        AlipayTradePagePayRequest payRequest = new AlipayTradePagePayRequest();        payRequest.setReturnUrl(SOPConstants.ALI_PAY_RETURN_URL);        payRequest.setNotifyUrl(SOPConstants.ALI_PAY_NOTIFY_URL);        // 将订单详情传入业务请求参数中        payRequest.setBizModel(generateOrderInfo(orderId));        String body = null;        try {            body = alipayClient.sdkExecute(payRequest).getBody();        } catch (AlipayApiException e) {            logger.error("订单" + orderId + "获取支付宝付款界面失败！");        }        if (body == null) {            logger.error("订单" + orderId + "未成功获取支付宝付款界面！");        }        return SOPConstants.ALI_PAY_SEND_URL + "?" + body;    }    private AlipayTradePagePayModel generateOrderInfo(Long orderId) {        // 获取订单信息        OrderDTO order = orderManageService.getOrder(orderId);        AlipayTradePagePayModel model = new AlipayTradePagePayModel();        model.setOutTradeNo(order.getCode());        model.setProductCode("FAST_INSTANT_TRADE_PAY");        model.setTotalAmount(String.valueOf(order.getPrice()));        model.setSubject("实训在线-" + order.getName());        model.setBody("实训在线-" + order.getName());        // 二维码获取方式为模式4，最简洁模式，只有二维码        model.setQrPayMode("4");        model.setQrcodeWidth(240L);        return model;    }}  控制层调用请求接口获取完整请求地址@RequestMapping("/ali/{orderId}")public String ali(Model model, @PathVariable String orderId) {    model.addAttribute("order", orderManageService.getOrder(IdEncoder.decodeId(orderId)));    model.addAttribute("orderType", OrderPay.aliPay.getCode());    model.addAttribute("aliPayUrl", aliPayService.aliPay(IdEncoder.decodeId(orderId)));    return "/order/pay/ali";}  上述方法中拼接完整的二维码请求地址可以直接放置到 iframe 的 src 属性中          如果页面没有成功获取，可根据报错信息前往 验签失败错误排查 进行解决      &lt;iframe id="aliPayFrame" src="${aliPayUrl}" frameborder="0"&gt;&lt;/iframe&gt;接收同步回执  该地址需要与之前初始化客户端时提交给支付宝的同步回执地址保持一致  回执地址不能有任何多余参数@RequestMapping("/ali/return")public String aliReturn(HttpServletRequest request) {    aliNotifyService.aliReturn(request);    return null;}  新版的同步回执中不会携带订单的状态信息，所以只能用做一般的信息接收，不能做为交易成功的依据          同步回执需要验签，但验签的方法支付宝已提供，即 AlipaySignature.rsaCheckV2()      public void aliReturn(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    Boolean result = false;    try {        // 回执验签        result = AlipaySignature.rsaCheckV2(parameterToMap(request, false), SOPConstants.ALI_PAY_PUBLIC_KEY, ALI_PAY_CHARSET, ALI_PAY_SIGN_TYPE);    } catch (AlipayApiException e) {        logger.error("支付宝订单" + orderCode + "同步回执验签失败！", e);    }    if (result) {        logger.info("支付宝订单" + orderCode + "同步回执接收成功！");    } else {        logger.error("支付宝订单" + orderCode + "同步回执无效！");    }}  对同步回执中的响应参数验签之前，需要先将参数转化为 map 形式private Map&lt;String, String&gt; parameterToMap(HttpServletRequest request, Boolean isNotify) {    // 获取回执内容    Map requestParams = request.getParameterMap();    // 过滤回执内容    Map&lt;String, String&gt; params = Maps.newHashMap();    for (Object o : requestParams.keySet()) {        String name = (String) o;        String[] values = (String[]) requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        if (isNotify) {            params.put(name, valueStr);        } else {            try {                params.put(name, new String(valueStr.getBytes("ISO-8859-1"), "utf-8"));            } catch (UnsupportedEncodingException e) {                logger.error("支付宝订单同步回执转码失败！", e);            }        }    }    return params;}接收异步回执  该地址需要与之前初始化客户端时提交给支付宝的异步回执地址保持一致  回执地址不能携带任何参数@RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic String aliNotify(HttpServletRequest request) {    return aliNotifyService.aliNotify(request);}  异步回执作为支付成功的依据，支付宝成功通知到本地后，需要明确告知支付宝交易已成功          交易成功后返回 success 即可      当订单支付成功后订单可以展现两种状态，TRADE_SUCCESS 或 TRADE_FINISHED      public String aliNotify(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 订单状态    String orderStatus = request.getParameter("trade_status");    boolean result = false;    try {        result = AlipaySignature.rsaCheckV2(parameterToMap(request, true), SOPConstants.ALI_PAY_PUBLIC_KEY, ALI_PAY_CHARSET, ALI_PAY_SIGN_TYPE);    } catch (AlipayApiException e) {        logger.error("支付宝订单" + orderCode + "异步回执验签失败，订单状态为：" + orderStatus + "！", e);    }    // 验签成功    if (result) {        // 订单已支付        if (orderStatus.equals(TRADE_STATUS_SUCCESS) || orderStatus.equals(TRADE_STATUS_FINISHED)) {            // 更新订单状态            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());            return "success";        } else {            logger.error("支付宝订单" + orderCode + "未支付，订单状态为：" + orderStatus + "！");            return "fail";        }    } else {        logger.error("支付宝订单" + orderCode + "异步回执接收失败，订单状态为：" + orderStatus + "！");        return "fail";    }}]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 支付宝扫码支付[旧]]]></title>
      <url>/java/2018/02/14/Java-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98-%E6%97%A7/</url>
      <content type="text"><![CDATA[  在实际开发过程中，首先采用当面付模式进行开发，但没有成功，个人认为当面付更适合线下模式之后改用即时到账模式才成功接入支付宝扫码支付功能以下内容是基于即时到账模式开发要使用支付宝即时到账接口，首先需要签约即时到账产品， 申请地址审核进度通常需要1个工作日，但实际几小时即可之后需要获取和设置如下关键信息pid:2088621150311111          合作伙伴身份IDkey:zrqyf6dfli7dvji4mmi4sw1111111111      MD5密钥notify_url:http://127.0.0.1:8080/sop/order/notify/ali    异步通知回调地址return_url:http://127.0.0.1:8080/sop/order/notify/ali/return  同步通知回调地址官网支付宝-开放平台模式  当面付 ，消费者扫描商户二维码完成支付。并不适用于Web网页端扫码支付  即时到账 ，用户在线向开发者的支付宝账号支付资金。Web网页端扫码支付首选开发步骤  下载支付宝提供的即时到账 DEMO          按下图所示将alipay下所有文件复制到项目开发目录，支付宝已将接口的调用、请求、验签等操作完成，我们只需要包装好数据后调用即可        打开AlipayConfig.java，将其中关键信息替换成之前准备好的内容          除了下述四个信息，其他内容均不需要修改      ** partner**即pid，key即md5密钥，都可以在 mapi网关产品密钥 获取      notify_url是支付宝异步通知链接，由支付宝主动调用，一旦用户完成支付，即调用该地址      不可添加自定义参数      必须保证外网可正常访问      使用POST方式发送/接收数据      没有时间限制      如果是https，则必须安装ssl证书，并且需要正规的证书机构签发，自签名的无法识别      return_url，是支付宝同步跳转通知，用户完成支付后，在支付页面完成跳转      不可添加自定义参数      必须保证外网可正常访问，但可在本机测试      使用GET方式发送/接收数据      一分钟超时      // 合作身份者ID，签约账号，以2088开头由16位纯数字组成的字符串，查看地址：https://b.alipay.com/order/pidAndKey.htmpublic static String partner = SOPConstants.ALI_PAY_PARTNER_ID; // MD5密钥，安全检验码，由数字和字母组成的32位字符串，查看地址：https://b.alipay.com/order/pidAndKey.htmpublic static String key = SOPConstants.ALI_PAY_MD5_KEY;// 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问public static String notify_url = SOPConstants.ALI_PAY_NOTIFY_URL;// 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问public static String return_url = SOPConstants.ALI_PAY_RETURN_URL;  在订单支付页面创建一个空的div，用于接收调用即时到账接口返回的表单数据$.ts.doAction("/api/order/pay/ali", {    orderId: orderId}, function () {    // 提交表单内容    $orderSubmitPanel.find("#returnAli").append(this.data);   // 打开订单状态轮询页面，确保支付完成后，支付页面能自动跳转    $.ts.openModalWindow("/api/order/pay/ali/tip/" + orderId, 350, 300);}, "", "", "");@RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic ResponseData ali(HttpServletRequest request, @RequestParam("orderId") final String orderId) {    SimpleActionHandler actionHandler = new SimpleActionHandler(request) {        @Override        protected void doHandle(ResponseData responseData) throws Exception {            responseData.setData(orderPayService.aliPay(IdEncoder.decodeId(orderId)));        }    };    return actionHandler.handle();}  按照 请求参数说明 包装请求参数，并建立请求          建立请求的操作支付宝已在AlipaySubmit.java中实现，只需要调用其中buildRequest()方法并传入参数即可      public String aliPay(Long orderId) {    // 获取订单信息    OrderDTO order = orderManageService.getOrder(orderId);    // 包装请求参数    Map&lt;String, String&gt; params = Maps.newHashMap();    // 调用接口    params.put("service", AlipayConfig.service);    // 签约账号id    params.put("partner", AlipayConfig.partner);    // 收款支付账号，默认与签约账号相同    params.put("seller_id", AlipayConfig.seller_id);    // 编码格式，支付GBK和UTF-8    params.put("_input_charset", AlipayConfig.input_charset);    // 支付类型    params.put("payment_type", AlipayConfig.payment_type);    // 异步通知回调地址    params.put("notify_url", AlipayConfig.notify_url);    // 同步通知跳转地址    params.put("return_url", AlipayConfig.return_url);    // 防钓鱼时间戳    params.put("anti_phishing_key", AlipayConfig.anti_phishing_key);    // 客户端IP    params.put("exter_invoke_ip", super.getClientIP());    // 订单号    params.put("out_trade_no", order.getCode());    // 标题    params.put("subject", "轻实训-" + order.getName());    // 金额    params.put("total_fee", String.valueOf(order.getPrice()));    // 建立请求    return AlipaySubmit.buildRequest(params, "get", "确认");}  由于调用即时到账接口返回的表单数据会自动提交，而接收表单数据的div是在订单提交页面，因此按照表单提交默认方式，会导致订单提交页面被替换成支付宝扫码页面  所以需要修改AlipaySubmit.java中的buildRequest()方法，在其拼接的表单中加入target=“_blank”，让表单提交时在新页面打开public static String buildRequest(Map&lt;String, String&gt; sParaTemp, String strMethod, String strButtonName) {    //待请求参数数组    Map&lt;String, String&gt; sPara = buildRequestPara(sParaTemp);    List&lt;String&gt; keys = new ArrayList&lt;String&gt;(sPara.keySet());    StringBuffer sbHtml = new StringBuffer();    sbHtml.append("&lt;form id=\"alipaysubmit\" name=\"alipaysubmit\" action=\"" + ALIPAY_GATEWAY_NEW                  + "_input_charset=" + AlipayConfig.input_charset + "\" method=\"" + strMethod                  + "\" target=\"_blank\"&gt;");    for (int i = 0; i &lt; keys.size(); i++) {        String name = (String) keys.get(i);        String value = (String) sPara.get(name);        sbHtml.append("&lt;input type=\"hidden\" name=\"" + name + "\" value=\"" + value + "\"/&gt;");    }    //submit按钮控件请不要含有name属性    sbHtml.append("&lt;input type=\"submit\" value=\"" + strButtonName + "\" style=\"display:none;\"&gt;&lt;/form&gt;");    sbHtml.append("&lt;script&gt;document.forms['alipaysubmit'].submit();&lt;/script&gt;");    return sbHtml.toString();}  用户通过支付宝扫描二维码完成支付后，支付宝会主动调用notify_url进行回执          由于回执时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该回执地址一个访问许可，否则会被安全框架屏蔽      @RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic String aliNotify(HttpServletRequest request) {    return orderPayService.aliNotify(request);}  接收并处理支付回执后，必须通知支付宝回执接收成功，否则支付宝会认为回执发送失败，并发送数次通知  支付宝发送异步通知后，如果没有获取到成功回执（返回success），则会按一定规律重发（4m,10m,10m,1h,2h,6h,15h）  接收支付宝的回执信息时，必须进行验签，改操作支付宝已实现，我们只需要调用AlipayNotify.java中的verify()方法即可  验签成功后需要判断操作状态，从回执参数中获取trade_status，参数值为TRADE_SUCCESS即为支付成功  还有一个订单状态是TRADE_FINISHED，该状态表示订单已完成，即超过三个月的退款期限，一旦订单到达这个状态，支付宝会再次调用notify_url进行回执，若业务系统没有退款流程，则无需处理该状态public String aliNotify(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 交易状态    String tradeStatus = request.getParameter("trade_status");    // 验签    if (AlipayNotify.verify(getNotifyData(request))) {        // 交易成功        if (tradeStatus.equals("TRADE_SUCCESS")) {            // 更新订单信息            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());        }        return "success";    } else {        return "fail";    }}  处理回执内容，用于验签private Map&lt;String, String&gt; getNotifyData(HttpServletRequest request, String method) throws Exception {    // 获取回执内容    Map requestParams = request.getParameterMap();    // 过滤回执内容    Map&lt;String, String&gt; params = Maps.newHashMap();    for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) {        String name = (String) iter.next();        String[] values = (String[]) requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        if (method.equals("notify")) {            params.put(name, valueStr);        } else {            params.put(name, new String(valueStr.getBytes("ISO-8859-1"), "utf-8"));        }    }    return params;}  用户通过支付宝扫描二维码完成支付后，在新打开的支付宝窗口会执行return_url进行跳转          由于跳转时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该跳转地址一个访问许可，否则会被安全框架屏蔽      public String aliReturn(HttpServletResponse response, HttpServletRequest request) throws Exception {    orderPayService.aliReturn(response, request);           // 跳转地址会通过输出流的方式关闭新窗口，所以无需返回任何内容    return null;}  接收跳转通知时，同样需要验签，以确保内容的安全性  为防止网络等不可预测原因导致异步回执没能成功接收，所以在接收跳转通知并验签通过以及状态判断成功后，同样需要对订单状态进行更新  如果用户完成支付后立即关闭页面，会导致同步跳转通知无法执行，所以不能完全依赖该通知确认订单状态  如果用户在支付页面扫码生成预下单订单，但并未直接付款，而是前往支付宝订单页重新付款，即使网页端支付页面未关闭，也无法执行该同步跳转通知  通过同步跳转通知更新订单状态，只是一种辅助措施，主要手段还是通过接受异步回执来处理订单状态  由于支付宝的扫码页面是在新窗口打开，在支付完成后并没有存在的必要，即可以通过输出流的方式关闭该窗口public void aliReturn(HttpServletResponse response, HttpServletRequest request) throws IOException {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 交易状态    String tradeStatus = request.getParameter("trade_status");    // 验签    if (AlipayNotify.verify(getNotifyData(request))) {        if (tradeStatus.equals("TRADE_FINISHED") || tradeStatus.equals("TRADE_SUCCESS")) {            // 更新订单信息            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());            // 页面跳转            response.setContentType("text/html;charset=gb2312");     // 通过输出流关闭窗口            PrintWriter writer = response.getWriter();            writer.println("&lt;html&gt;&lt;head&gt;&lt;title&gt; CLOSE &lt;/title&gt;&lt;/head&gt;");            writer.println("&lt;body&gt;");            writer.println("&lt;script type=\"text/javascript\"&gt;window.close();&lt;/script&gt;");            writer.println("&lt;/body&gt;&lt;/html&gt;");        }    }}  轮询订单状态，实现支付完成后页面自动跳转          由于支付回执是异步的，所以即使捕获到异步回执也无法实现支付页面的自动跳转      所以需要在支付页面打开时设置一个ajax轮询订单状态，一旦订单状态更新，则进行页面跳转      // 页面关闭$(“.modal-header button.close:last”).click(function () {    // 停止轮询    clearInterval(checkTimer);});// 轮询订单状态checkTimer = setInterval(function () {    // 窗口是否打开    if ($(“.order-pay-panel”).length &lt;= 0) {        clearInterval(checkTimer);    }    // 获取订单状态    $.ts.doAction(“/api/order/review/check/“, {        orderId: orderId    }, function () {        // 订单已支付        if (!this.data) {            $.ts.closeWindow();            g_index.loadMainContentWithState(“/order/manage”);        $.ts.toastr.success(“订单已支付成功！”);        }    }, “”, “”, “”);}, 3000);]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
