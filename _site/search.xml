<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[vuex 在非组件中调用 mutations 方法]]></title>
      <url>/vue/vuex/2018/08/14/vuex-%E5%9C%A8%E9%9D%9E%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%B0%83%E7%94%A8-mutations-%E6%96%B9%E6%B3%95/</url>
      <content type="text"><![CDATA[  一般情况下调用 mutations.js 中的方法都是在组件中，如果想在非组件中调用，则需要使用如下方式在组件中调用import {mapMutations} from 'vuex'import {SET_IS_LOGIN} from 'store/mutation-types'export default {	methods: {		...mapMutations({			set_is_login: SET_IS_LOGIN		}),		init() {			this.set_is_login(true)		}	}}在非组件中调用import store from 'store'import {SET_IS_LOGIN} from 'store/mutation-types'function init() {	store.commit(SET_IS_LOGIN, true)}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> vuex </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> vuex </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[vuex 在非组件中调用 actions 方法]]></title>
      <url>/vue/vuex/2018/08/14/vuex-%E5%9C%A8%E9%9D%9E%E7%BB%84%E4%BB%B6%E4%B8%AD%E8%B0%83%E7%94%A8-actions-%E6%96%B9%E6%B3%95/</url>
      <content type="text"><![CDATA[  一般情况下调用 actions.js 中的方法都是在组件中，如果想在非组件中调用，则需要如下方式在组件中import {mapActions} from 'vuex'export default {	methods: {		...mapActions([			'setUserInfo'		])	},	init() {		let user = {}				this.setUserInfo(user)	}}在非组件中import store from 'store'function init() {	let user = {}	store.dispatch('setUserInfo', user)}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> vuex </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> vuex </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JS 判断对象是否为空]]></title>
      <url>/javascript/es6/2018/08/14/JS-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA/</url>
      <content type="text"><![CDATA[  ES6 新增了 Object.keys() 可将对象自身可枚举属性转换为数组实现方式let obj = {}let objArr = Object.keys(obj)console.log(objArr.length) // 0]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> es6 </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> es6 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[v-for 遍历 Map]]></title>
      <url>/vue/2018/08/11/v-for-%E9%81%8D%E5%8E%86-Map/</url>
      <content type="text"><![CDATA[  通常情况下都是使用 v-for 遍历 List 或 Array ，但 v-for 对于 Map 遍历也是支持的遍历方式  下列代码展现的是一种比较复杂的情况，在 Map 的 value 中存放的是一个 List```javascript					```]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> for </tag>
        
          <tag> map </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[简单封装浏览器 cookie 工具类]]></title>
      <url>/vue/2018/08/10/%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E6%B5%8F%E8%A7%88%E5%99%A8-cookie-%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      <content type="text"><![CDATA[  目前主流浏览器一般都支持 cookie ，以下对 cookie 的操作进行简单封装，以方便使用主体封装类import { storagePrefix } from 'assets/scripts/config/config'import { verify, uri } from 'assets/scripts/tools'/** * cookies操作类 */export default new class Cookie {  /**   * 构造函数   */  constructor() {    this.defaults = {}    this.expiresMultiplier = 60 * 60 * 24    this.prefix = storagePrefix  }  /**   * 根据key获取cookie的值   * @param {string} key 键   * @returns {object} 值   */  get(key) {    if (!key) {      throw new Error('没有找到key。')    }    if (typeof key === 'object') {      throw new Error('key不能是一个对象。')    }    let cookies = this.all()    let value = cookies[this.prefix + key]    try {      value = JSON.parse(value)    } catch (e) {      value = {}    }    return value  }  /**   * 设置cookies   * @param key 键   * @param value 值   * @param options 选项   * @returns {Cookie}   */  set(key, value, options) {    options = verify.isObject(options) ? options : {expires: options}    let expires = options.expires !== undefined ? options.expires : (this.defaults.expires || '')    let expiresType = typeof (expires)    if (expiresType === 'string' &amp;&amp; expires !== '') {      expires = new Date(expires)    } else if (expiresType === 'number') {      expires = new Date(+new Date() + 1000 * this.expiresMultiplier * expires)    }    if (expires !== '' &amp;&amp; 'toGMTString' in expires) {      expires = ';expires=' + expires.toGMTString()    }    let path = options.path || this.defaults.path    path = path ? ';path=' + path : ''    let domain = options.domain || this.defaults.domain    domain = domain ? ';domain=' + domain : ''    let secure = options.secure || this.defaults.secure ? ';secure' : ''    if (options.secure === false) secure = ''    document.cookie = uri.encode(this.prefix + key) + '=' + uri.encode(JSON.stringify(value)) + expires + path + domain + secure    return this  }  /**   * 删除cookie   * @param {string||array} keys 删除cookie的key   * @returns {Cookie}   */  remove(keys) {    keys = verify.isArray(keys) ? keys : [keys]    for (let i = 0, l = keys.length; i &lt; l; i++) {      this.set(keys[i], '', -1)    }    return this  }  /**   * 获取所有的cookie   * @returns {object} cookie对象   */  all() {    let cookie = document.cookie    if (cookie === '') return {}    let cookieArr = cookie.split('; ')    let result = {}    for (let i = 0, l = cookieArr.length; i &lt; l; i++) {      let item = cookieArr[i].split('=')      let key = uri.decode(item.shift())      let value = uri.decode(item.join(''))      result[key] = value    }    return result  }}verify 工具类export default new class Verify {  // 验证url是否正确，true/false  isUrl (url) {    return (/(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-.,@?^=%&amp;:/~+#]*[\w\-@?^=%&amp;/~+#])?/i).test(url)  }    // 验证手机号码是否正确， true/false  isTel (tel) {    return (/^1[3|4|5|8][0-9]\d{4,8}$/).test(tel)  }    // 判断是否是object对象  isObject (value) {    return !!value &amp;&amp; Object.prototype.toString.call(value) === '[object Object]'  }    // 判断是否是数组  isArray (value) {    return Object.prototype.toString.call(value) === '[object Array]'  }}uri 工具类export default new class Uri {  decode (value) {    return decodeURIComponent(value)  }    encode (value) {    return encodeURIComponent(value)  }}config 基础配置// 本地存储的前缀export const storagePrefix = 'tshark_quick_storage_']]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> cookie </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot+Shiro前后端分离项目通过JWT实现自动登录]]></title>
      <url>/java/springboot/shiro/vue/2018/08/09/SpringBoot+Shiro%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E9%80%9A%E8%BF%87JWT%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%95/</url>
      <content type="text"><![CDATA[  虽然 Shiro 本身可以支持扩展 RememberMe 功能，但仅限于传统项目因为 Shiro 的用户信息是基于 Session 进行管理，在前后端分离的项目中无法实现 Session 状态的前后统一所以本文通过 JWT 对 Shiro 原生的 Session 控制进行替换，从而实现用户信息的前后传递及判断涉及资料  一个已经实现的例子  JWT官网  JWT源码导入项目所需的依赖  对于 SpringBoot 和 Shiro 的依赖此处不重复介绍  以下是 JWT 的依赖包，就一个即可&lt;dependency&gt;  &lt;groupId&gt;com.auth0&lt;/groupId&gt;  &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;  &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;创建 JWTToken 替换 Shiro 原生 Token  Shiro 原生的 Token 中存在用户名和密码以及其他信息 [验证码，记住我]  在 JWT 的 Token 中因为已将用户名和密码通过加密处理整合到一个加密串中，所以只需要一个 token 字段即可public class JWTToken implements AuthenticationToken {    // 密钥    private String token;    public JWTToken(String token) {        this.token = token;    }    @Override    public Object getPrincipal() {        return token;    }    @Override    public Object getCredentials() {        return token;    }}创建 JWTUtil 整合 JWT 相关操作  在这个工具类中可以实现对用户名和密码的加密处理，校验 token 是否正确，获取用户名等操作  Algorithm algorithm = Algorithm.HMAC256(password) 是对密码进行加密后再与用户名混淆在一起  在签名时可以通过 .withExpiresAt(date) 指定 token 的过期时间public class JWTUtil {    // 过期时间30天    private static final long EXPIRE_TIME = 24 * 60 * 30 * 1000;    /**     * 校验token是否正确     *     * @param token    密钥     * @param username 登录名     * @param password 密码     * @return     */    public static boolean verify(String token, String username, String password) {        try {            Algorithm algorithm = Algorithm.HMAC256(password);            JWTVerifier verifier = JWT.require(algorithm).withClaim("username", username).build();            DecodedJWT jwt = verifier.verify(token);            return true;        } catch (Exception e) {            return false;        }    }    /**     * 获取登录名     *     * @param token     * @return     */    public static String getUsername(String token) {        try {            DecodedJWT jwt = JWT.decode(token);            return jwt.getClaim("username").asString();        } catch (JWTDecodeException e) {            return null;        }    }    /**     * 生成签名     *     * @param username     * @param password     * @return     */    public static String sign(String username, String password) {        try {            // 指定过期时间            Date date = new Date(System.currentTimeMillis() + EXPIRE_TIME);            Algorithm algorithm = Algorithm.HMAC256(password);            return JWT.create()                    .withClaim("username", username)                    .withExpiresAt(date)                    .sign(algorithm);        } catch (UnsupportedEncodingException e) {            return null;        }    }}创建 JWTFilter 实现前端请求统一拦截及处理  executeLogin() 方法中的 getSubject(request, response).login(token) 就是触发 Shiro Realm 自身的登录控制，具体内容需要手动实现  executeLogin() 始终返回 true 的原因是因为具体的是否登录成功的判断，需要在 Realm 中手动实现，此处不做统一判断  LOGIN_SIGN 是前端放置在 headers 头文件中的登录标识，如果用户发起的请求是需要登录才能正常返回的，那么头文件中就必须存在该标识并携带有效值public class JWTFilter extends BasicHttpAuthenticationFilter {    // 登录标识    private static String LOGIN_SIGN = "Authorization";    /**     * 检测用户是否登录     * 检测header里面是否包含Authorization字段即可     *     * @param request     * @param response     * @return     */    @Override    protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) {        HttpServletRequest req = (HttpServletRequest) request;        String authorization = req.getHeader(LOGIN_SIGN);        return authorization != null;    }    @Override    protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception {        HttpServletRequest req = (HttpServletRequest) request;        String header = req.getHeader(LOGIN_SIGN);        JWTToken token = new JWTToken(header);        getSubject(request, response).login(token);        return true;    }    @Override    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {        if (isLoginAttempt(request, response)) {            try {                executeLogin(request, response);            } catch (Exception e) {                throw new TSharkException("登录权限不足！", e);            }        }        return true;    }    /**     * 对跨域提供支持     *     * @param request     * @param response     * @return     * @throws Exception     */    @Override    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {        HttpServletRequest httpServletRequest = (HttpServletRequest) request;        HttpServletResponse httpServletResponse = (HttpServletResponse) response;        httpServletResponse.setHeader("Access-control-Allow-Origin", httpServletRequest.getHeader("Origin"));        httpServletResponse.setHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS,PUT,DELETE");        httpServletResponse.setHeader("Access-Control-Allow-Headers", httpServletRequest.getHeader("Access-Control-Request-Headers"));        // 跨域时会首先发送一个option请求，这里我们给option请求直接返回正常状态        if (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) {            httpServletResponse.setStatus(HttpStatus.OK.value());            return false;        }        return super.preHandle(request, response);    }}自定义 ShiroDatabaseRealm 实现 Shiro Realm 的登录控制  重写 Realm 的 supports()  方法是通过 JWT 进行登录判断的关键          因为前文中创建了 JWTToken 用于替换 Shiro 原生 token      所以必须在此方法中显式的进行替换，否则在进行判断时会一直失败        登录的合法验证通常包括 token 是否有效 、用户名是否存在 、密码是否正确          通过 JWTUtil 对前端传入的 token 进行处理获取到用户名      然后使用用户名前往数据库获取到用户密码      再将用户面传入 JWTUtil 进行验证即可      public class ShiroDatabaseRealm extends AuthorizingRealm {    private Logger logger = LoggerFactory.getLogger(this.getClass());    @Autowired    private ShiroAuthService shiroAuthService;    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {        logger.info("doGetAuthorizationInfo+" + principals.toString());        String username = JWTUtil.getUsername(principals.toString());        MemberDTO member = shiroAuthService.getPrincipal(username);        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();        List&lt;String&gt; userPermissions = shiroAuthService.getPermissions(member.getId());        // 基于Permission的权限信息        info.addStringPermissions(userPermissions);        return info;    }    /**     * 使用JWT替代原生Token     *     * @param token     * @return     */    @Override    public boolean supports(AuthenticationToken token) {        return token instanceof JWTToken;    }    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) throws AuthenticationException {        String token = (String) authcToken.getCredentials();        String username = JWTUtil.getUsername(token);        MemberDTO member = shiroAuthService.getPrincipal(username);        // 用户不会空        if (member != null) {            // 判断是否禁用            if (member.getStatus().equals(MemberStatus.disableStatus)) {                throw new DisabledAccountException("901");            }            // 密码验证            if (!JWTUtil.verify(token, username, member.getLoginPassword())) {                throw new UnknownAccountException("900");            }            return new SimpleAuthenticationInfo(token, token, "realm");        } else {            throw new UnknownAccountException("900");        }    }}在 ShiroConfiguration 中将所有的请求指向 JWT  指定手工实现的 ShiroDatabaseRealm 用于传入 DefaultWebSecurityManager  在 securityManager 中关闭默认的 Session 控制          因为在前后分离项目中前端是无法获取到后端 Session 的，即无法实现用户登录状态的同步        在 shiroFilterFactoryBean() 中传入自定义的 TokenFilter          并将所有的请求指向该过滤器 filterRuleMap.put("/**", "jwt")      @Configuration@ConditionalOnWebApplicationpublic class ShiroConfiguration {    @Bean    public ShiroDatabaseRealm shiroDatabaseRealm() {        return new ShiroDatabaseRealm();    }    @Bean("securityManager")    public DefaultWebSecurityManager securityManager(ShiroDatabaseRealm shiroDatabaseRealm) {        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();        securityManager.setRealm(shiroDatabaseRealm);        // 关闭自带session        DefaultSessionStorageEvaluator evaluator = new DefaultSessionStorageEvaluator();        evaluator.setSessionStorageEnabled(false);        DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO();        subjectDAO.setSessionStorageEvaluator(evaluator);        securityManager.setSubjectDAO(subjectDAO);        return securityManager;    }    @Bean("shiroFilter")    public ShiroFilterFactoryBean shiroFilterFactoryBean(DefaultWebSecurityManager securityManager) {        ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();        Map&lt;String, Filter&gt; filterMap = new HashMap&lt;&gt;();        filterMap.put("jwt", new JWTFilter());        factoryBean.setFilters(filterMap);        factoryBean.setSecurityManager(securityManager);        Map&lt;String, String&gt; filterRuleMap = new HashMap&lt;&gt;();        filterRuleMap.put("/**", "jwt");        factoryBean.setFilterChainDefinitionMap(filterRuleMap);        return factoryBean;    }    @Bean    @DependsOn("lifecycleBeanPostProcessor")    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);        return defaultAdvisorAutoProxyCreator;    }    @Bean    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {        return new LifecycleBeanPostProcessor();    }    @Bean    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(DefaultWebSecurityManager securityManager) {        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();        advisor.setSecurityManager(securityManager);        return advisor;    }}执行登录操作时对用户信息进行基础验证并签名返回  ResponseData 是前后分离项目中用于统一后端返回数据的类，必不可少          一般包含状态值和返回的具体内容      @RestController@RequestMapping("")@Api("用户登录")public class LoginController extends AbstractBaseController {    @Autowired    private LoginServiceImpl loginService;    @PostMapping("/login")    @ApiOperation("登录")    public ResponseData login(@RequestParam String username, @RequestParam String password) {        return new SimpleActionHandler(request) {            @Override            public void doAction(ResponseData responseData) throws Exception {                responseData.setData(loginService.jwtLogin(username, password));            }        }.handle();    }}  进行登录操作处理时需要判断数据有效性，即 数据是否为空，密码是否正确  一般为了用户隐私和安全起见，数据库中存入的密码都是经过 不可逆混淆 处理的          所以此处在通过 JWTUtil 签名之前，需要将用户传入的密码进行相同混淆，再将混淆后的两个密码进行对比      如果密码正确，通过相同规则混淆后的密码也会相同      @Servicepublic class LoginServiceImpl extends AbstractBaseService {    @Autowired    private MemberServiceImpl memberService;    /**     * 用户登录     *     * @param username     * @param password     * @return     */    public String jwtLogin(String username, String password) {        Assert.notNull(username, "用户名不能为空");        Assert.notNull(password, "密码不能为空");        // 获取用户密码混淆值        MemberDTO member = memberService.getMemberSalt(username);        // 加密当前用户输入密码        byte[] bytePassword = DigestUtil.sha1(password.getBytes(), EncodeUtils.hexDecode(member.getSalt()), Constants.PASSWORD_HASH_INTERATIONS);        String encodePassword = EncodeUtils.hexEncode(bytePassword);        if (!encodePassword.equals(member.getLoginPassword())) {            throw new TSharkException("900");        }        return JWTUtil.sign(username, encodePassword);    }}在前端的请求发起基类中对头文件进行统一传递  由于本项目用的 SPA 模式，除了欢迎页不需要登录，其余页面都需要登录后才能访问          因此在基类中对头文件进行统一处理，默认所有请求都会传递用户登录状态      个别不需要传递登录状态的，再进行单独处理        在头文件中指定 Authorization 自定义信息，对应的 token 值是用户登录后存入到 vuex 中的数组import axios from 'axios'import router from 'router'import store from 'store'import qs from 'qs'import { SET_USER_INFO } from 'store/mutation-types'import * as config from 'assets/scripts/config/config'axios.defaults.withCredentials = trueconst setUserInfo = function (user) {  store.commit(SET_USER_INFO, user)}const getUserInfo = function () {  return store.state.userInfo.token}export default function fetch(options) {  return new Promise((resolve, reject) =&gt; {    const instance = axios.create({      baseURL: `${config.serverBaseUrl}mop`,      timeout: 10000,      withCredentials: true,      credentials: 'include'    })    // 针对头文件是否为空，会做一些权限控制    if (options.headers === undefined) {      // 没有指定头文件的使用默认头文件，需要传入用户信息      options.headers = {        'Content-Type': 'application/x-www-form-urlencoded',        'Authorization': getUserInfo()      }    }    // 表单提交格式需要进行参数转换    if (options.headers['Content-Type'].indexOf('x-www-form') !== -1) {      // 参数格式转换      options.data = qs.stringify(options.data)    }    instance(options).then((response) =&gt; {      let result = response.data      // 无数据      if (!result) {        return false      }      // 未授权      if (result.status === config.UNAUTHORIZED_CODE || result.data === config.UNAUTHORIZED_CODE) {        // 清空用户信息        setUserInfo(null)        // 跳转至登录界面        router.replace({name: 'portal'})        return false      }      resolve(result)      return false    }).catch((error) =&gt; {      reject(error)      // 清空用户信息      setUserInfo(null)      router.replace({name: 'portal'})    })  })}单独处理不需要头文件的请求  由于 fetch.js 中对头文件存在 undefined 的判断，所以外部如果传入头文件，则可以替换默认的头文件配置import fetch from 'assets/scripts/fetch/fetch'import * as config from 'assets/scripts/config/config'let baseUrl = '/api/portals'/** * 轮播列表 */export function covers() {  const url = `${baseUrl}/covers`  return fetch({    url: url,    method: config.GET,    headers: config.VISITOR_HEADER  })}  实际开发中通常会存在一个 config.js 文件，用于存储一系列通用配置信息// 游客头文件export const VISITOR_HEADER = {  'Content-Type': 'application/x-www-form-urlencoded'}用户登录成功后将后端返回的 token 值存入 cookie  登录操作实际应该对用户名和密码进行有效性判断，以及登录失败后的错误提示，此处都省略，重点突出将 token 值存入 vuex 的步骤&lt;template&gt;  &lt;div ref="portal" class="container portal-panel"&gt;	  ...    &lt;mt-field placeholder="请输入手机号或邮箱" v-model.trim="user.username" :state="state.username"                         @keyup.enter.native="sendLogin"&gt;&lt;/mt-field&gt;    &lt;mt-field placeholder="请输入密码" type="password" v-model.trim="user.password" :state="state.password"                        @keyup.enter.native="sendLogin"&gt;&lt;/mt-field&gt;    &lt;mt-button type="primary" @click.native="sendCaptcha"&gt;&lt;/mt-button&gt;	  ...  &lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;  import { mapMutations } from 'vuex'  import { SET_USER_INFO } from 'store/mutation-types'  export default {    name: 'portal',    data() {      return {        countDown: 0,        timer: null,        user: {          username: '',          password: ''        }      }    },    methods: {      ...mapMutations({        set_user_info: SET_USER_INFO      }),      // 用户登录      sendLogin() {        ...        this.$fetch.login.login({          username: this.user.username,          password: this.user.password        }).then((res) =&gt; {			...          this.$toast.success('登录成功')          this.set_user_info({            token: res.data,            isLogin: true          })			...        })      }		...  }&lt;/script&gt;&lt;style lang="stylus" rel="stylesheet/stylus"&gt;  ...&lt;/style&gt;vuex 处理 token 值  在 mutations.js 中，当存入用户信息时          一份存入 session ，供日常使用      一份存入 cookie ，有效期 30 天，供自动登录使用，具体的 cookie 存值方式，请参见 简单封装浏览器 cookie 工具类        同时需要确保，当用户手动退出后执行用户信息清除时，需要同时清除 cookie/** vuex所有的mutation */// 引入mutations-typesimport * as types from './mutation-types'import { sessionStorage, cookieStorage } from 'assets/scripts/storage'// 定义mutation，其内部是一些修改方法const mutations = {  // 第一个参数是状态值  // 第二个参数为提交状态修改是传入的对象参数  [types.SET_USER_INFO](state, userInfo) {    state.userInfo = userInfo || {}    if (userInfo === null) {      sessionStorage.remove('userInfo')      cookieStorage.remove('userInfo')    } else {      sessionStorage.set('userInfo', userInfo)      cookieStorage.set('userInfo', userInfo, 30)    }  }	...}// 暴露给外部export default mutations在请求首页时判断是否可以自动登录  在 router.js 的最后添加 router.beforeEach() ，可以在链接跳转之前执行一些预判操作  如果 cookie 中存在用户登录信息，则将信息取出重新放入 vuex ，并在后续操作中直接跳转至登录后的首屏页面/** * 全局路由配置 * 路由开始之前的操作 */router.beforeEach((to, from, next) =&gt; {  // 获取当前请求的名称  // let toName = to.name  // 获取当前请求的路径  let toPath = to.path  // 请求首页时判断用户是否存在本地登录信息  if (toPath.indexOf('portal') === 1) {    // 获取用户信息    let userInfo = cookieStorage.get('userInfo')    // 存在用户信息    if (userInfo !== undefined &amp;&amp; userInfo.token !== undefined) {      // 将用户信息重新进行状态管理      store.commit(SET_USER_INFO, userInfo)    }  }  // 获取用户登录标识  let isLogin = store.state.userInfo.isLogin  // 用户未登录，且请求的不是首页或首页子页面  if (!isLogin &amp;&amp; toPath.indexOf('portal') !== 1) {    // 跳转到登录页面    next({      name: 'portal'    })  } else {    // 用户已登录，且请求的是登录页面    if (isLogin &amp;&amp; toPath.indexOf('portal') === 1) {      // 跳转到首页      next({        path: serverBaseUrl      })    } else {      // 默认操作      next()    }  }})]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> shiro </category>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> shiro </tag>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC多环境配置]]></title>
      <url>/java/springmvc/2018/07/23/SpringMVC%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  SpringMVC 可以使用 Spring 本身提供的 profile 特性对多环境配置文件进行统一集成，自动切换存在的必要  日常开发中，一般都存在多个环境，开发、测试、生产  上述环境对应的数据库及配置文件都会存在不同，所以为项目集成多环境配置很有必要实现方式  集成方式有多种，网上介绍的大多是使用 &lt;beans profile="dev"&gt; 去区分不同的 *.properties 文件  还可以使用 @Profile 进行不同环境代码加载  本文介绍的是使用 &lt;beans profile="dev"&gt; 直接在同一个 xml 文件中区分不同环境需要的不同配置项XML配置  注意如果使用了多环境的配置的 xml 文件中存在其他公有属性，这些属性需要放在最前面，否则会报错&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:p="http://www.springframework.org/schema/p"       xsi:schemaLocation="http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans-4.0.xsd"&gt;  &lt;description&gt;spring-data-redis-cluster&lt;/description&gt;  &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;    &lt;property name="maxIdle" value="${redis.pool.maxIdle}"/&gt;    &lt;property name="maxTotal" value="${redis.pool.maxActive}"/&gt;    &lt;property name="maxWaitMillis" value="${redis.pool.maxWait}"/&gt;    &lt;property name="testOnBorrow" value="${redis.pool.testOnBorrow}"/&gt;  &lt;/bean&gt;  ...  &lt;beans profile="dev"&gt;    &lt;bean id="jedisPool" class="redis.clients.jedis.JedisPool"&gt;      &lt;constructor-arg index="0" ref="jedisPoolConfig"/&gt;      &lt;constructor-arg index="1" value="${redis.server.url}"/&gt;      &lt;constructor-arg index="2" value="${redis.server.port}" type="int"/&gt;      &lt;constructor-arg index="3" value="${redis.server.timeout}" type="int"/&gt;      &lt;constructor-arg index="4" value="${redis.server.password}"/&gt;    &lt;/bean&gt;    &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt;      &lt;property name="hostName" value="${redis.server.url}"/&gt;      &lt;property name="port" value="${redis.server.port}"/&gt;      &lt;property name="password" value="${redis.server.password}"/&gt;      &lt;property name="poolConfig" ref="jedisPoolConfig"/&gt;    &lt;/bean&gt;  &lt;/beans&gt;  &lt;beans profile="prod"&gt;    &lt;bean id="redisClusterConfiguration" class="org.springframework.data.redis.connection.RedisClusterConfiguration"&gt;      ...    &lt;/bean&gt;    &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt;      &lt;constructor-arg ref="redisClusterConfiguration"/&gt;      &lt;constructor-arg ref="jedisPoolConfig"/&gt;    &lt;/bean&gt;  &lt;/beans&gt;&lt;/beans&gt;开发环境启动方式  IDEA 需要在启动时添加脚本 -Dspring.profiles.active="dev" 以确保使用开发环境启动生产环境启动方式  Linux 环境需要前往 Tomcat 的 /bin 目录下，需要 ./catalina.sh 中的 JAVA_OPTS 内容如下  JAVA_OPTS="$JAVA_OPTS -Dspring.profiles.active=prod"]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> profile </tag>
        
          <tag> spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[高德地图 JS API]]></title>
      <url>/javascript/amap/2018/07/22/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE-JS-API/</url>
      <content type="text"><![CDATA[  高德地图对于开发者提供一套 JS API ，可用于将高德地图集成到网站中官网  开发者平台  代码在线调试  开发手册]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> amap </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> amap </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[连接 MySQL 抛出 Establishing SSL connection 警告]]></title>
      <url>/java/database/2018/07/11/%E8%BF%9E%E6%8E%A5-MySQL-%E6%8A%9B%E5%87%BA-Establishing-SSL-connection-%E8%AD%A6%E5%91%8A/</url>
      <content type="text"><![CDATA[  Java 连接 MySQL 时控制台出现多条 Establishing SSL connection without 警告解决办法  在连接数据库的 url 最后加上 useSSL=false 即可    jdbc:mysql://localhost:3306/hts_lb?characterEncoding=UTF-8&amp;tinyInt1isBit=false&amp;useSSL=false      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> database </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[移动端弹出遮罩层时防止底部页面滚动]]></title>
      <url>/vue/javascript/2018/07/10/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%B9%E5%87%BA%E9%81%AE%E7%BD%A9%E5%B1%82%E6%97%B6%E9%98%B2%E6%AD%A2%E5%BA%95%E9%83%A8%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/</url>
      <content type="text"><![CDATA[  如果底部页面内容过多出现滚动条，此时弹出遮罩层后，在遮罩层滑动页面也会导致底部页面响应滚动操作解决办法  监听遮罩层的打开和关闭          打开时设置底部页面的 position: fixed      关闭时恢复默认布局 position: static      watch: {  'popupVisible'(val) {    if (val) {      this.$refs.portal.style.position = 'fixed'    } else {      this.$refs.portal.style.position = 'static'    }  }}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
          <tag> dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 动态赋值 class]]></title>
      <url>/vue/2018/06/29/Vue-%E5%8A%A8%E6%80%81%E8%B5%8B%E5%80%BC-class/</url>
      <content type="text"><![CDATA[  Vue 在操作 DOM 元素的 class 属性时，有以下多种方法比较通用的是否赋值方式  通过以下 :class="{show: show}" 的方式可以决定该元素是否拥有名称为 show 的 class          data() 中的 show 属性为 true ，则赋予 show class ，否则不赋予      &lt;template&gt;	&lt;div class="watch-mooc-panel" :class="{show: show}"&gt;&lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;  export default {    name: 'mooc',    data() {      return {        show: false      }    }  }&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt;    .watch-mooc-panel      width 100%      height 100%      position absolute      transition background-color .3s      &amp;.show        background-color #000000&lt;/style&gt;使用三目运算符的方式  注意使用三木运算符添加的属性语法和上述方式存在明显区别&lt;template&gt;	&lt;div class="watch-mooc-panel" :class="show ? 'show' : 'hide'"&gt;&lt;/div&gt;&lt;/template&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mint-UI Infinite Scroll 无限滚动运用]]></title>
      <url>/vue/mintui/2018/06/25/Mint-UI-Infinite-Scroll-%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8%E8%BF%90%E7%94%A8/</url>
      <content type="text"><![CDATA[  Mint-UI 自带一个支持无限滚动的组件，以下是用法官网文档Infinite Scroll使用方法  v-infinite-scroll 指定加载内容的方法，在满足触发条件时，则会加载          注意如果内容加载的分页方法就一个，此处指定后，则不需要再通过 created() 调用分页方法，否则一开始会加载两次        infinite-scroll-distance 触发方法的阈值，底部距离的像素值&lt;div class="real-content" v-infinite-scroll="getMoocs" infinite-scroll-distance="10"&gt;  &lt;div class="hot-item" v-for="mooc in moocs" :key="mooc.hexId"&gt;    ...  &lt;/div&gt;&lt;/div&gt;注意点  值得注意的是该组件提供了一个 infinite-scroll-disabled 属性，文档中的说明是若为真，则无限滚动不会被触发          这很容易让人理解为当分页检测到没有下一页后，则不再触发无限滚动，但其实根本达不到这个效果      翻阅 官方 GitHub 上作者的解释 才知道这个属性其实为了防止分页内容在加载过程中重复加载，当内容加载完毕后，会被内部重置      所以要实现到达尾页后不再重复发起分页请求，需要通过以下方法      getMoocs() {	// 检测是否存在下一页  if (!this.page.hasNext) {    return false  }  this.$fetch.mooc.page(this.page).then((res) =&gt; {    this.page = new Page(res.data)    this.moocs = _.concat(this.moocs, res.data.list)  })}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> mintui </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> mintui </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot前后分离项目实现自定义登录拦截]]></title>
      <url>/java/springboot/shiro/2018/06/24/SpringBoot%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA/</url>
      <content type="text"><![CDATA[  通常的 shiro 登录拦截对于 /login 操作可设置为 authc 模式，但前后分离的项目直接设置会导致无法获取登录信息自定义登录拦截的实现  要实现自定义的登录拦截是继承 FormAuthenticationFilter 接口  对接口中的 onLoginSuccess 和 onLoginFailure 重写          从而根据登录成功和失败进行不同的操作记录      public class LoginFormAuthenticationFilter extends FormAuthenticationFilter {  // springBoot中存在与配置类的service类需要提供get/set方法手动收入，如果使用@Autowired会导致报错    private MemberLoginRecordServiceImpl memberLoginRecordService;    @Override    protected boolean onLoginSuccess(AuthenticationToken token, Subject subject, ServletRequest request, ServletResponse response) throws Exception {        // 处理会员登录成功操作        memberLoginRecordService.doAfterSuccessfullyLogin(request, subject);        return super.onLoginSuccess(token, subject, request, response);    }    @Override    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) {        return super.onLoginFailure(token, e, request, response);    }    public MemberLoginRecordServiceImpl getMemberLoginRecordService() {        return memberLoginRecordService;    }    public void setMemberLoginRecordService(MemberLoginRecordServiceImpl memberLoginRecordService) {        this.memberLoginRecordService = memberLoginRecordService;    }}将重写的拦截器注入到 shiro 配置中@Configuration@ConditionalOnWebApplicationpublic class ShiroConfiguration extends BaseShiroConfiguration {  ...  	// 手动注入自定义拦截器需要用到的service  	// 注入该service即可，service内部的其他类可实现自动注入    @Bean    public MemberLoginRecordServiceImpl memberLoginRecordService() {        return new MemberLoginRecordServiceImpl();    }    public ShiroFilterFactoryBean shiroFilterFactoryBean(DefaultWebSecurityManager securityManager) throws Exception {        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();        shiroFilterFactoryBean.setSecurityManager(securityManager);  		// 指定登录链接        shiroFilterFactoryBean.setLoginUrl("/login");        Map&lt;String, Filter&gt; filters = new LinkedHashMap&lt;String, Filter&gt;();          		// 配置自定义表单拦截器        LoginFormAuthenticationFilter authcFilter = new LoginFormAuthenticationFilter();        authcFilter.setRememberMeParam("rememberMe");  		// 注入上述引用的service类        authcFilter.setMemberLoginRecordService(memberLoginRecordService());  		// 选择指定拦截器的规则        filters.put("authc", authcFilter);        shiroFilterFactoryBean.setFilters(filters);  		// 配置不同接口规则        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;();  		// 登出操作由shiro管理        filterChainDefinitionMap.put("/logout", "anon");  		// 以下规则可直接访问        filterChainDefinitionMap.put("/api/portals/**", "anon");  		// 以下规则需要认证访问        filterChainDefinitionMap.put("/login", "authc");        filterChainDefinitionMap.put("/api/**", "authc");        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);        return shiroFilterFactoryBean;    }}以上方式在前后分离项目中会出现的问题  由于项目是前后分离的，前端发起的直接是访问 loginController 的请求  该请求由于配置了 authc 规则，则需要认证才能访问  所以就导致以上配置方式会直接报错  而如果将 /login 请求配置为 anon 规则，则会导致登录操作无法被自定义表单拦截器拦截解决方式  重写 FormAuthenticationFilter 接口的 onAccessDenied 方法  判断当前访问该规则的请求是否为登录请求  如果是登录请求则再次判断是否为登录提交请求 this.isLoginRequest          因为正常的登录请求中会存在一个访问登录页面和提交登录表单两个操作      而前后分离项目发起的必然是提交登录表单 this.isLoginSubmission        如果不是登录请求则返回 false@Overrideprotected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {    if (this.isLoginRequest(request, response) &amp;&amp; this.isLoginSubmission(request, response)) {        return true;    }    return false;}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> shiro </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> shiro </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 项目在 IE11 中数据更改后页面数据无变化]]></title>
      <url>/vue/javascript/2018/06/23/Vue-%E9%A1%B9%E7%9B%AE%E5%9C%A8-IE11-%E4%B8%AD%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%94%B9%E5%90%8E%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE%E6%97%A0%E5%8F%98%E5%8C%96/</url>
      <content type="text"><![CDATA[  在 IE11 中运行 Vue 项目会发现提交表单数据后，列表数据没有变化出现问题的原因  在 IE11 中，如果 GET 请求相同的 URL ，浏览器默认会使用之前的缓存数据，而不是重新请求接口解决的方式  针对 IE 浏览器，在每个请求末尾都添加一个时间戳，保证每个请求都是独立的即可  因为其他浏览器不存在此问题，所以添加时对浏览器进行判断，只为 IE 添加if (window.ActiveXObject || 'ActiveXObject' in window) {  options.url = `${options.url}?${new Date().getTime()}`}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[URLSearchParams 在 IE11 中无法被识别]]></title>
      <url>/vue/javascript/2018/06/23/URLSearchParams-%E5%9C%A8-IE11-%E4%B8%AD%E6%97%A0%E6%B3%95%E8%A2%AB%E8%AF%86%E5%88%AB/</url>
      <content type="text"><![CDATA[  URLSearchParams 是用于拼接请求参数的工具类，但在 IE11 中无法被直接识别解决办法  在项目中安装 url-search-params-polyfill  在需要使用 URLSearchParams 的类中引入即可  引入之后可以按照正常操作使用 URLSearchParamsimport 'url-search-params-polyfill'...function dataTruncateMap (objs) {  let data = new URLSearchParams()  ...}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 添加自定义 JS 文件参与 ES6 转义]]></title>
      <url>/vue/javascript/es6/2018/06/14/Vue-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89-JS-%E6%96%87%E4%BB%B6%E5%8F%82%E4%B8%8E-ES6-%E8%BD%AC%E4%B9%89/</url>
      <content type="text"><![CDATA[  vue 中可能存在部分 JS 文件使用了 ES6 语法，但默认不会被 babel-loader 扫描到，从而出现编译后的项目 ES6 语法没有被转义报错信息  下列报错信息就是说明在 ::node_modules/quill-image-extend-module/index.js:: 文件中存在 ES6 的语法糖  由于目前大部分浏览器默认不支持 ES6 语法，所以项目编译后如果没有把 ES6 语法转义成 ES5 语法，浏览器则会报错ERROR in static/js/vendor.9447dc694e95071dbce3.js from UglifyJsUnexpected token operator «=», expected punc «,» [./node_modules/quill-image-extend-module/index.js:12,0][static/js/vendor.9447dc694e95071dbce3.js:28927,35]  Build failed with errors.解决方式  在 ::webpack.base.conf.js:: 中添加如下语法{  test: /\.js$/,  loader: 'babel-loader',  include: [    resolve('src'),    resolve('test'),	  // 只有这一行是添加的，由于指定自定义扫描文件    resolve('node_modules/quill-image-extend-module/index.js')  ],},]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
          <category> es6 </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
          <tag> es6 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript 获取窗体宽高]]></title>
      <url>/javascript/2018/06/14/Javascript-%E8%8E%B7%E5%8F%96%E7%AA%97%E4%BD%93%E5%AE%BD%E9%AB%98/</url>
      <content type="text"><![CDATA[  通过 Javascript 可以方便的获取浏览器窗体的宽高获取方式document.documentElement.clientHeightdocument.documentElement.clientWidth]]></content>
      <categories>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Touch UI 基于 Vue 的移动端框架]]></title>
      <url>/vue/frame/2018/06/07/Touch-UI-%E5%9F%BA%E4%BA%8E-Vue-%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6/</url>
      <content type="text"><![CDATA[  完全免费的高质量移动端框架官网Touch UI]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> frame </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> frame </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot实现全局异常捕获]]></title>
      <url>/java/springboot/2018/06/07/SpringBoot%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</url>
      <content type="text"><![CDATA[  SpringBoot 对异常可以进行全局捕获，按照如下操作即可创建全局异常捕获器  @RestControllerAdvice 是对 @RestController 的加强          该注解是 Spring2.3 之后提供的新功能，主要用于对原生 Controller 做一些低侵入性的增加辅助      被该注解标注的类，其中的方法会被应用到 @RestController 中      作用与 @RestController 中被标注 @RequestMapping 的方法        @ExceptionHandler 是自定义错误处理器，使用时可以注明具体需要处理的错误类型          一般需要标注默认异常和自定义异常即可        该错误捕获方式是将所有错误向上一直抛出至 Spring 容器，由 Spring 自行处理          所以如果在之前进行了 try-catch 操作，会导致 Spring 无法捕获到该异常      @RestControllerAdvicepublic class GlobalExceptionHandler {    public Logger log = LoggerFactory.getLogger(getClass());    @ExceptionHandler(TSharkException.class)    public ResponseData handleTSharkException(TSharkException e) {        log.error(e.getMessage());        ResponseData responseData = new ResponseData();        responseData.setError(e.getMessage());        return responseData;    }    @ExceptionHandler(Exception.class)    public ResponseData handleException(Exception e) {        log.error(e.getMessage());        String exceptionMessage = "";        ResponseData responseData = new ResponseData();        if (e.getMessage().contains("rollback")) {            exceptionMessage = "数据已被关联或使用，无法删除！";        }        responseData.setError(exceptionMessage);        return responseData;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> exception </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[elementui elform 支持回车提交]]></title>
      <url>/vue/elementui/2018/06/06/elementui-elform-%E6%94%AF%E6%8C%81%E5%9B%9E%E8%BD%A6%E6%8F%90%E4%BA%A4/</url>
      <content type="text"><![CDATA[  el-form 组件默认不支持回车提交，需要对提交按钮进行一下更改实现方式  在表单的提交按钮上添加 Vue 原生属性 native-type="submit" 可以让按钮变为表单提交按钮  当表单中只有一个输入框时，按钮会默认为提交按钮  设置默认的提交按钮后需要阻止表单默认提交事件，在表单上添加 @submit.native.prevent 即可&lt;el-form ref="form" :model="user" :rules="rules" class="login-form" @submit.native.prevent&gt;  &lt;el-row :gutter="20"&gt;    &lt;el-col :span="24"&gt;      &lt;el-form-item prop="username"&gt;        &lt;el-input v-model="user.username" placeholder="请输入用户名" autofocus&gt;          &lt;in-icon slot="prefix" :name="userIcon"&gt;&lt;/in-icon&gt;        &lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item prop="password"&gt;        &lt;el-input v-model="user.password" type="password" placeholder="请输入密码"&gt;          &lt;in-icon slot="prefix" :name="passwordIcon"&gt;&lt;/in-icon&gt;        &lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item&gt;        &lt;el-button type="primary" native-type="submit" class="submit-btn" @click="submitForm"&gt;登录&lt;/el-button&gt;      &lt;/el-form-item&gt;    &lt;/el-col&gt;  &lt;/el-row&gt;&lt;/el-form&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> elementui </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> elementui </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Element-ui 桌面端组件库]]></title>
      <url>/vue/frame/elementui/2018/06/06/Element-ui-%E6%A1%8C%E9%9D%A2%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
      <content type="text"><![CDATA[  Element-ui 是一套基于 Vue 2.0 的桌面端组件库官网Element-ui]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> frame </category>
        
          <category> elementui </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> frame </tag>
        
          <tag> elementui </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[使用节流函数防止请求重复发送]]></title>
      <url>/vue/javascript/2018/05/28/%E4%BD%BF%E7%94%A8%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E9%98%B2%E6%AD%A2%E8%AF%B7%E6%B1%82%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81/</url>
      <content type="text"><![CDATA[  在注入输入框监听的事件中，快速的输入可能会导致请求频繁发送构造节流函数  节流函数接收两个参数，一个是待执行方法体，一个是延迟时间export function debounce(func, delay) {	// 定义一个timer用于控制延迟	let timer	return function (...args) {		// 定时器存在则清空		if (timer) {			clearTimeout(timer)		}		// 初始化定时器		timer = setTimeout(() =&gt; {			// 在延迟达到或调用原有时间			func.apply(this, args)		}, delay)	}}运用节流函数  在 Vue 的监听中可以使用节流函数来派发监听方法  表示才 200 毫秒内重复触发该方法，不会重复派发this.$watch('query', debounce((newQuery) =&gt; {	this.$emit(query, newQuery)}, 200))]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[v-charts 基于 Vue 和 ECharts 封装的图表插件]]></title>
      <url>/vue/javascript/2018/05/24/v-charts-%E5%9F%BA%E4%BA%8E-Vue-%E5%92%8C-ECharts-%E5%B0%81%E8%A3%85%E7%9A%84%E5%9B%BE%E8%A1%A8%E6%8F%92%E4%BB%B6/</url>
      <content type="text"><![CDATA[  基于 Vue 和 ECharts 封装的图标插件官网v-charts]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
          <tag> charts </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vuex 属性与 v-model 绑定]]></title>
      <url>/vue/vuex/2018/05/23/Vuex-%E5%B1%9E%E6%80%A7%E4%B8%8E-v-model-%E7%BB%91%E5%AE%9A/</url>
      <content type="text"><![CDATA[  由于 Vuex 提供的是 mapGetters 和 mapActions 对属性行获取和操作，所以无法直接适配 v-model 的双向绑定形式官网Vuex 表单数据绑定 解决方式  上述 vuex 的官方文档中提供了适配 v-model 的解决方式  一种是重写 input 的双向绑定  另外一种是提供单独的计算属性，并写明 get / set 方法，将 vuex 的 mapGetters / mapActions 分别赋值  个人认为第二种方式更实用]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> vuex </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> vuex </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[js-base64 使用 JS 解码 base64]]></title>
      <url>/vue/javascript/2018/05/21/js-base64-%E4%BD%BF%E7%94%A8-JS-%E8%A7%A3%E7%A0%81-base64/</url>
      <content type="text"><![CDATA[  使用 JS 解码 base64官网js-base64]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[create-keyframe-animation	使用 JS 创建 CSS 动画]]></title>
      <url>/vue/javascript/2018/05/17/create-keyframe-animation-%E4%BD%BF%E7%94%A8-JS-%E5%88%9B%E5%BB%BA-CSS-%E5%8A%A8%E7%94%BB/</url>
      <content type="text"><![CDATA[#vue/plugin #javascript/plugin  实现通过 JS 编写 CSS3 动画官网create-keyframe-animation]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate 双向关联转换 JSON 防止死循环]]></title>
      <url>/java/hibernate/2018/05/17/Hibernate-%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94%E8%BD%AC%E6%8D%A2-JSON-%E9%98%B2%E6%AD%A2%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
      <content type="text"><![CDATA[  Hibernate 中经常存在双向关联的情况，此处将数据转换为 JSON 格式则可能导致死循环获取数据时只需要单向关联  这种情况下父类需要子类数据，而子类不需要父类数据@Entity@Table(name = "ht_feedback_template")public class FeedbackTemplate extends BaseModel {    @OneToMany(mappedBy = "feedbackTemplate", cascade = {CascadeType.ALL}, fetch = FetchType.LAZY)    @OrderBy("indexNo asc")    private Set&lt;FeedbackQuestion&gt; questions;    public Set&lt;FeedbackQuestion&gt; getQuestions() {        return questions;    }    public void setQuestions(Set&lt;FeedbackQuestion&gt; questions) {        this.questions = questions;    }}  在子类中对父类的引用字段加上 @JsonIgnore 即可@Entity@Table(name = "ht_feedback_question")public class FeedbackQuestion extends BaseModel {    @ManyToOne    @JsonIgnore    private FeedbackTemplate feedbackTemplate;    public FeedbackTemplate getFeedbackTemplate() {        return feedbackTemplate;    }    public void setFeedbackTemplate(FeedbackTemplate feedbackTemplate) {        this.feedbackTemplate = feedbackTemplate;    }}获取数据时确实需要双向关联  在父类对子类的引用字段加上 @JsonManagedReference@Entity@Table(name = "ht_feedback_template")public class FeedbackTemplate extends BaseModel {    @OneToMany(mappedBy = "feedbackTemplate", cascade = {CascadeType.ALL}, fetch = FetchType.LAZY)    @OrderBy("indexNo asc")  @JsonManagedReference    private Set&lt;FeedbackQuestion&gt; questions;    public Set&lt;FeedbackQuestion&gt; getQuestions() {        return questions;    }    public void setQuestions(Set&lt;FeedbackQuestion&gt; questions) {        this.questions = questions;    }}  在子类中对父类的引用字段加上 @JsonBackReference 即可@Entity@Table(name = "ht_feedback_question")public class FeedbackQuestion extends BaseModel {    @ManyToOne  @JsonBackReference    private FeedbackTemplate feedbackTemplate;    public FeedbackTemplate getFeedbackTemplate() {        return feedbackTemplate;    }    public void setFeedbackTemplate(FeedbackTemplate feedbackTemplate) {        this.feedbackTemplate = feedbackTemplate;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate Criteria 模糊查询]]></title>
      <url>/java/hibernate/2018/05/14/Hibernate-Criteria-%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  使用 Hibernate 的 Criteria 可以快速进行模糊查询实现方式  进行模糊查询时需要指定匹配模式，否则会出现无搜索结果的情况，例如 MatchMode.ANYWHERE  如果匹配的条件设置到类的属性，需要使用 createAlias() 指定别名，否则会抛出无法找到 user.name 属性Criterion userCri = Restrictions.like("user.name", username, MatchMode.ANYWHERE);Criteria criteria = getSession().createCriteria(trainingCri, userCri);criteria.createAlias("user", "user", JoinType.LEFT_OUTER_JOIN);criteria.list();]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
          <tag> criteria </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate 执行 SQL 查询]]></title>
      <url>/java/hibernate/2018/05/12/Hibernate-%E6%89%A7%E8%A1%8C-SQL-%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  Hibernate 支持执行原生 SQL 查询实现方式  通过 Session 对象可以使用 createSQLQuery() 方法，传入原生 SQL 语句即可  参数格式为 paramName = :paramCodepublic List&lt;Dictionary&gt; getDictionaries(String categoryCode) {    SQLQuery sqlQuery = getSession().createSQLQuery("SELECT * FROM sys_dictionary WHERE CategoryCode = :categoryCode");    sqlQuery.addEntity(Dictionary.class);    sqlQuery.setParameter("categoryCode", categoryCode);    return sqlQuery.list();}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[vuedraggable 拖拽排序]]></title>
      <url>/vue/2018/05/11/vuedraggable-%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F/</url>
      <content type="text"><![CDATA[  vuedraggable 可实现列表的拖拽排序官网vuedraggable]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot通过jar包启动时MyBatis无法定位实体类]]></title>
      <url>/java/springboot/mybatis/error/2018/05/09/SpringBoot%E9%80%9A%E8%BF%87jar%E5%8C%85%E5%90%AF%E5%8A%A8%E6%97%B6MyBatis%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8D%E5%AE%9E%E4%BD%93%E7%B1%BB/</url>
      <content type="text"><![CDATA[  SpringBoot 通过 jar 包启动项目时，MyBatis 无法定位实体类，但通过 IDE 启动时没问题出现问题的原因  通过 jar 启动时，MyBatis 内部获得的路径不同，会导致无法根据配置文件指定的路径扫描到实体类  项目不是通过自动注入方式配置 MyBatis ，而是通过手动注入解决办法  在手动注入并指定实体类扫描路径之前，将 Spring 已经实例化的 VFS 提前指定@Bean@ConditionalOnMissingBean(SqlSessionFactoryBean.class)public SqlSessionFactory sqlSessionFactory(@Qualifier("druidDataSource") DataSource dataSource) throws Exception {    SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();    sqlSessionFactoryBean.setDataSource(dataSource);    sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations));  // 指定VFS确保可以扫描到实体类    sqlSessionFactoryBean.setVfs(SpringBootVFS.class);    sqlSessionFactoryBean.setTypeAliasesPackage(typeAliasesPackage);    return sqlSessionFactoryBean.getObject();}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> mybatis </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> mybatis </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot多环境配置]]></title>
      <url>/java/springboot/2018/05/09/SpringBoot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  SpringBoot 在开发时可以配置多个环境进行便捷切换创建多个环境配置文件  首先需要创建多个对应的配置文件，如上图  然后在 application.yml 中通过如下语法进行匹配          项目启动时会根据指定的尾缀自动去匹配对应的配置文件      spring:  profiles:    active: dev项目打包实现动态指定配置文件  执行 java -jar xxx.jar  会直接按照默认配置进行打包  执行 java -jar xxx.jar --spring.profiles.active=test 则可以动态指定配置文件]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Maven打包时抛出should not point at files within the project directory …异常]]></title>
      <url>/java/maven/error/2018/05/09/Maven%E6%89%93%E5%8C%85%E6%97%B6%E6%8A%9B%E5%87%BAshould-not-point-at-files-within-the-project-directory-%E5%BC%82%E5%B8%B8/</url>
      <content type="text"><![CDATA[  项目中通过 Maven 引入本地包后打包时抛出 should not point at files within the project directory … 警告具体问题  在项目中引入本地包&lt;dependency&gt;    &lt;groupId&gt;ppts.model&lt;/groupId&gt;    &lt;artifactId&gt;ppts-model&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;scope&gt;system&lt;/scope&gt;    &lt;systemPath&gt;${basedir}/../lib/ppts-model-1.0-SNAPSHOT.jar&lt;/systemPath&gt;&lt;/dependency&gt;  在项目进行 package 打包时，抛出以下异常，且并没有引入对应 jar 包[WARNING] 'dependencies.dependency.systemPath' for ts.core:ts-core:jar should not point at files within the project directory, ${basedir}/../lib/ts-core-1.0.jar will be unresolvable by dependent projects @ line 97, column 19解决方式  移除本地包依赖中的 &lt;scope/&gt; 和 &lt;systemPath/&gt;&lt;dependency&gt;  &lt;groupId&gt;ppts.model&lt;/groupId&gt;  &lt;artifactId&gt;ppts-model&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;  通过 maven-install-plugin 插件对 jar 包进行安装          &lt;phase&gt;clean&lt;/phase&gt; 表示该 jar 包会在执行 clean 操作时引入      &lt;plugin&gt;  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;  &lt;version&gt;2.5.2&lt;/version&gt;  &lt;executions&gt;    &lt;execution&gt;      &lt;id&gt;install-ppts-model&lt;/id&gt;      &lt;phase&gt;clean&lt;/phase&gt;      &lt;configuration&gt;        &lt;file&gt;${basedir}/../lib/ppts-model-1.0-SNAPSHOT.jar&lt;/file&gt;        &lt;repositoryLayout&gt;default&lt;/repositoryLayout&gt;        &lt;groupId&gt;ppts.model&lt;/groupId&gt;        &lt;artifactId&gt;ppts-model&lt;/artifactId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;packaging&gt;jar&lt;/packaging&gt;        &lt;generatePom&gt;true&lt;/generatePom&gt;      &lt;/configuration&gt;      &lt;goals&gt;        &lt;goal&gt;install-file&lt;/goal&gt;      &lt;/goals&gt;    &lt;/execution&gt;  &lt;/executions&gt;&lt;/plugin&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> maven </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> maven </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 实现路由过渡动画]]></title>
      <url>/vue/2018/05/08/Vue-%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB/</url>
      <content type="text"><![CDATA[  在进行路由跳转时，可以加上动画效果准备工作  编写动画效果.slide-right-enter-active,.slide-right-leave-active,.slide-left-enter-active,.slide-left-leave-active {  will-change: transform;  transition: all 500ms;  position: absolute;}.slide-right-enter {  opacity: 0;  transform: translate3d(-100%, 0, 0);}.slide-right-leave-active {  opacity: 0;  transform: translate3d(100%, 0, 0);}.slide-left-enter {  opacity: 0;  transform: translate3d(100%, 0, 0);}.slide-left-leave-active {  opacity: 0;  transform: translate3d(-100%, 0, 0);}实现步骤  为路由可能跳转到的组件添加索引，确保动画的过渡效果是有序的          在 meta 中可以添加自定义参数，此处添加 index 用于表示索引      children: [  {    path: 'hot',    name: 'hot',    component: hot,    meta: {      index: 0    }  },  {    path: 'mooc',    name: 'mooc',    component: mooc,    meta: {      index: 1    }  },  {    path: 'self',    name: 'self',    component: self,    meta: {      index: 2    }  },  {    path: 'training/:id',    name: 'training',    component: training,    props: true,    meta: {      index: 3    }  }]  在需要跳转的路由外层包裹 &lt;transition&gt; 组件          同时为组件指定可能执行的动画效果      &lt;transition :name="transitionName"&gt;  &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;  通过监听路由变化判断具体执行哪个动画          可以通过路由的参数获取到之前设置的索引，从而判断动画效果是向左还是向右      watch: {  '$route' (to, from) {    console.log(to)    let toName = to.name    const toIndex = to.meta.index    const fromIndex = from.meta.index    this.transitionName = toIndex &lt; fromIndex ? 'slide-right' : 'slide-left'  }}]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> transition </tag>
        
          <tag> animate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot集成ActiveMQ抛出java.lang.NoClassDefFoundError异常]]></title>
      <url>/java/springboot/springmvc/maven/error/2018/05/08/SpringBoot%E9%9B%86%E6%88%90ActiveMQ%E6%8A%9B%E5%87%BANoClassDefFoundError/</url>
      <content type="text"><![CDATA[  SpringBoot 在集成 JMS 及 ActiveMQ 时抛出 java.lang.NoClassDefFoundError: javax/jms/JMSContext 异常出现问题的原因  spring 5.0 以上版本不会自动导入 JMS 2.0 的依赖  但是 activemq-core 5.7  版本需要 JMS 2.0 的依赖解决办法  手动加入 JMS 2.0 依赖&lt;dependency&gt;    &lt;groupId&gt;javax.jms&lt;/groupId&gt;    &lt;artifactId&gt;javax.jms-api&lt;/artifactId&gt;    &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;  在 activemq-core 5.7 中移除低版本的默认引入&lt;dependency&gt;    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;    &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;    &lt;version&gt;5.7.0&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;            &lt;artifactId&gt;geronimo-jms_1.1_spec&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> springmvc </category>
        
          <category> maven </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> springmvc </tag>
        
          <tag> maven </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Cube-ui 基于 vue 的移动组件库]]></title>
      <url>/vue/frame/2018/05/07/Cube-ui-%E5%9F%BA%E4%BA%8E-vue-%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
      <content type="text"><![CDATA[  cube-ui 是滴滴团队开源的一套基于 vue 的移动组件库官网  Github  使用文档]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> frame </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> frame </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[es6 方法具名参数及默认值]]></title>
      <url>/javascript/es6/2018/05/03/es6-%E6%96%B9%E6%B3%95%E5%85%B7%E5%90%8D%E5%8F%82%E6%95%B0%E5%8F%8A%E9%BB%98%E8%AE%A4%E5%80%BC/</url>
      <content type="text"><![CDATA[  es6 对方法参数做了较大升级，不仅可以提供具名参数还能设定默认值携带具名参数的方法function common (message, type, { position , duration }) {  Toast({    message: message,    className: type,    position: position,    duration: duration  })}为具名参数指定默认值的方法function common (message, type, { position = 'middle', duration = 3000 }) {  Toast({    message: message,    className: type,    position: position,    duration: duration  })}注意事项  携带具名参数的方法，在调用时如果不传递对应参数也必须传递一个空的大空号，否则内部参数使用时会抛出 undefinedcommon(message, 'warning', {})  为防止这种每次调用都必须传递一对空的大空号的麻烦，可以对方法进行二次封装export function error (message, position) {  common(message, 'error', { position })}]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> es6 </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> es6 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue Aliplayer 阿里云播放器适配 vue]]></title>
      <url>/2018/05/02/vue-aliplayer-%E9%98%BF%E9%87%8C%E4%BA%91%E6%92%AD%E6%94%BE%E5%99%A8%E9%80%82%E9%85%8D-vue/</url>
      <content type="text"><![CDATA[vue-aliplayer 阿里云播放器适配 vue#vue/plugin  阿里云播放器本身没对 vue 进行专门优化，以下借助 github 上一个库进行优化官网vue-aliplayer插件源码&lt;template&gt;  &lt;div class='prism-player' :id='playerId' :style='playStyle'&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: 'Aliplayer',    props: {      playStyle: {        type: String,        default: ''      },      aliplayerSdkPath: {        // Aliplayer 代码的路径        type: String,        default: '//g.alicdn.com/de/prismplayer/2.6.0/aliplayer-min.js'      },      autoplay: {        type: Boolean,        default: false      },      isLive: {        type: Boolean,        default: false      },      playsinline: {        type: Boolean,        default: false      },      width: {        type: String,        default: '100%'      },      height: {        type: String,        default: '320px'      },      controlBarVisibility: {        type: String,        default: 'always'      },      useH5Prism: {        type: Boolean,        default: false      },      useFlashPrism: {        type: Boolean,        default: false      },      vid: {        type: String,        default: ''      },      playauth: {        type: String,        default: ''      },      source: {        type: String,        default: ''      },      cover: {        type: String,        default: ''      },      format: {        type: String,        default: 'm3u8'      },      x5_video_position: {        type: String,        default: 'top'      },      x5_type: {        type: String,        default: 'h5'      },      x5_fullscreen: {        type: Boolean,        default: false      },      x5_orientation: {        type: Number,        default: 2      },      autoPlayDelay: {        type: Number,        default: 0      },      autoPlayDelayDisplayText: {        type: String      }    },    data () {      return {        playerId: 'aliplayer_' + Math.random() * 100000000000000000,        scriptTagStatus: 0,        instance: null      }    },    created () {      if (window.Aliplayer !== undefined) {        // 如果全局对象存在，说明编辑器代码已经初始化完成，直接加载编辑器        this.scriptTagStatus = 2        this.initAliplayer()      } else {        // 如果全局对象不存在，说明编辑器代码还没有加载完成，需要加载编辑器代码        this.insertScriptTag()      }    },    mounted () {      if (window.Aliplayer !== undefined) {        // 如果全局对象存在，说明编辑器代码已经初始化完成，直接加载编辑器        this.scriptTagStatus = 2        this.initAliplayer()      } else {        // 如果全局对象不存在，说明编辑器代码还没有加载完成，需要加载编辑器代码        this.insertScriptTag()      }    },    methods: {      insertScriptTag () {        const _this = this        let playerScriptTag = document.getElementById('playerScriptTag')        // 如果这个tag不存在，则生成相关代码tag以加载代码        if (playerScriptTag === null) {          playerScriptTag = document.createElement('script')          playerScriptTag.type = 'text/javascript'          playerScriptTag.src = this.aliplayerSdkPath          playerScriptTag.id = 'playerScriptTag'          let s = document.getElementsByTagName('head')[0]          s.appendChild(playerScriptTag)        }        if (playerScriptTag.loaded) {          _this.scriptTagStatus++        } else {          playerScriptTag.addEventListener('load', () =&gt; {            _this.scriptTagStatus++            playerScriptTag.loaded = true            _this.initAliplayer()          })        }        _this.initAliplayer()      },      initAliplayer () {        const _this = this        // scriptTagStatus 为 2 的时候，说明两个必需引入的 js 文件都已经被引入，且加载完成        if (_this.scriptTagStatus === 2 &amp;&amp; _this.instance === null) {          // Vue 异步执行 DOM 更新，这样一来代码执行到这里的时候可能 template 里面的 script 标签还没真正创建          // 所以，我们只能在 nextTick 里面初始化 Aliplayer          _this.$nextTick(() =&gt; {            _this.instance = window.Aliplayer({              id: _this.playerId,              autoplay: _this.autoplay,              isLive: _this.isLive,              playsinline: _this.playsinline,              format: _this.format,              width: _this.width,              height: _this.height,              controlBarVisibility: _this.controlBarVisibility,              useH5Prism: _this.useH5Prism,              useFlashPrism: _this.useFlashPrism,              vid: _this.vid,              playauth: _this.playauth,              source: _this.source,              cover: _this.cover,              x5_video_position: _this.x5_video_position,              x5_type: _this.x5_type,              x5_fullscreen: _this.x5_fullscreen,              x5_orientation: _this.x5_orientation,              autoPlayDelay: _this.autoPlayDelay,              autoPlayDelayDisplayText: _this.autoPlayDelayDisplayText            })            // 绑定事件，当 AliPlayer 初始化完成后，将编辑器实例通过自定义的 ready 事件交出去            _this.instance.on('ready', () =&gt; {              this.$emit('ready', _this.instance)            })            _this.instance.on('play', () =&gt; {              this.$emit('play', _this.instance)            })            _this.instance.on('pause', () =&gt; {              this.$emit('pause', _this.instance)            })            _this.instance.on('ended', () =&gt; {              this.$emit('ended', _this.instance)            })            _this.instance.on('liveStreamStop', () =&gt; {              this.$emit('liveStreamStop', _this.instance)            })            _this.instance.on('m3u8Retry', () =&gt; {              this.$emit('m3u8Retry', _this.instance)            })            _this.instance.on('hideBar', () =&gt; {              this.$emit('hideBar', _this.instance)            })            _this.instance.on('waiting', () =&gt; {              this.$emit('waiting', _this.instance)            })            _this.instance.on('snapshoted', () =&gt; {              this.$emit('snapshoted', _this.instance)            })          })        }      },      /**       * 播放视频       */      play: function () {        this.instance.play()      },      /**       * 暂停视频       */      pause: function () {        this.instance.pause()      },      /**       * 重播视频       */      replay: function () {        this.instance.replay()      },      /**       * 跳转到某个时刻进行播放       * @argument time 的单位为秒       */      seek: function (time) {        this.instance.seek(time)      },      /**       * 获取当前时间 单位秒       */      getCurrentTime: function () {        return this.instance.getCurrentTime()      },      /**       *获取视频总时长，返回的单位为秒       * @returns 返回的单位为秒       */      getDuration: function () {        return this.instance.getDuration()      },      /**       获取当前的音量，返回值为0-1的实数ios和部分android会失效       */      getVolume: function () {        return this.instance.getVolume()      },      /**       设置音量，vol为0-1的实数，ios和部分android会失效       */      setVolume: function (vol) {        this.instance.setVolume(vol)      },      /**       *直接播放视频url，time为可选值（单位秒）目前只支持同种格式（mp4/flv/m3u8）之间切换暂不支持直播rtmp流切换       *@argument url 视频地址       *@argument time 跳转到多少秒       */      loadByUrl: function (url, time) {        this.instance.loadByUrl(url, time)      },      /**       * 设置播放速度       *@argument speed 速度       */      setSpeed: function (speed) {        this.instance.setSpeed(speed)      },      /**       * 设置播放器大小w,h可分别为400px像素或60%百分比chrome浏览器下flash播放器分别不能小于397x297       *@argument w 播放器宽度       *@argument h 播放器高度       */      setPlayerSize: function (w, h) {        this.instance.setPlayerSize(w, h)      },      /**       * 目前只支持HTML5界面上的重载功能,暂不支持直播rtmp流切换m3u8）之间切换,暂不支持直播rtmp流切换       *@argument vid 视频id       *@argument playauth 播放凭证       */      reloaduserPlayInfoAndVidRequestMts: function (vid, playauth) {        this.instance.reloaduserPlayInfoAndVidRequestMts(vid, playauth)      }    }  }&lt;/script&gt;&lt;style&gt;  @import url(//g.alicdn.com/de/prismplayer/2.6.0/skins/default/aliplayer-min.css);&lt;/style&gt;组件封装  插件本身属性过多，正常开发中不一定用得到，因此对插件进行再一次封装为组件，方便程序调用及适当扩展  该组件主要实现了一下功能          播放器高度自适应      自动获取视频播放地址，播放地址的实现参见 Java + jQuery 实现阿里云点播      &lt;template&gt;  &lt;ali-player v-if="playAuth" :vid="vid" :playauth="playAuth" :height="height"&gt;&lt;/ali-player&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;  import aliPlayer from './ali-player/ali-player'  export default {    name: 'in-video',    props: {      vid: {        type: String,        default: '0'      }    },    data () {      return {        playAuth: ''      }    },    watch: {      'vid' (val) {        this._getPlayAuth(val)      }    },    computed: {      // 高度自适应      height () {        let width = document.documentElement.clientWidth        return `${width / 1.7777778}px`      }    },    methods: {      // 获取视频鉴权地址      _getPlayAuth (val) {        this.$fetch.video.auth({          videoId: val        }).then((res) =&gt; {          this.playAuth = res.data        })      }    },    components: {      aliPlayer    }  }&lt;/script&gt;&lt;style lang="stylus" rel="stylesheet/stylus"&gt;&lt;/style&gt;]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 实现 slot 多层嵌套]]></title>
      <url>/vue/2018/04/25/Vue-%E5%AE%9E%E7%8E%B0-slot-%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97/</url>
      <content type="text"><![CDATA[  在引用一些框架时，通常他们自己就已经有插槽，但有时需要对插槽进行拓展定义基础组件，向插槽中再插入一个插槽  在基础组件中引入了 Mint-UI 的 mt-header 组件  并通过其提供的具名插槽向组件右侧插入内容  但该组件是我们自定义的，我们并不知道组件被调用时会被插入什么内容  所以在该组件中插入该具名插槽的内容也是一个插槽  关键点在于这个插入的未知内容的插槽也必须是具名的&lt;template&gt;  &lt;mt-header&gt;    &lt;img class="logo" src="./images/logo.png" alt="logo" slot="left"&gt;    &lt;slot name="button" slot="right"&gt;&lt;/slot&gt;  &lt;/mt-header&gt;&lt;/template&gt;子组件引用基础组件，像二级插槽中插入具体内容，并指定二级插槽的名称  在引入组件时，只需要将待插入的内容插槽名称与基础组件中覆写的插槽名称对应即可&lt;template&gt;  &lt;div class="portal-panel"&gt;    &lt;in-header&gt;      &lt;div class="btn-group" slot="button"&gt;        &lt;mt-button&gt;登录&lt;/mt-button&gt;        &lt;mt-button&gt;注册&lt;/mt-button&gt;      &lt;/div&gt;    &lt;/in-header&gt;  &lt;/div&gt;&lt;/template&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> slot </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[IntelliJ IDEA 修改 Javascript 编码风格没有分号]]></title>
      <url>/javascript/intellij/idea/2018/04/22/IntelliJ-IDEA-%E4%BF%AE%E6%94%B9-Javascript-%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%E6%B2%A1%E6%9C%89%E5%88%86%E5%8F%B7/</url>
      <content type="text"><![CDATA[  现在觉得没有分号更酷解决方式  该界面下选择 Don’t use 即可]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> intellij </category>
        
          <category> idea </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> intellij </tag>
        
          <tag> idea </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 项目启动抛出 Syntax Error/ Unexpected token]]></title>
      <url>/vue/2018/04/20/Vue-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%8A%9B%E5%87%BA-Syntax-Error-Unexpected-token/</url>
      <content type="text"><![CDATA[  项目启动时抛出了标识符无法识别的错误错误原因  ES6 新增了不少标识符，但浏览器大多无法直接识别，需要借助 babel 对 ES6 代码进行转义  项目启动时抛出如下错误，表示 ... 运算符没能被识别，该运算符属于 ES6 的解构运算符  出现该问题的原因基本上可以定位是项目没有配置 babel          即时 package.json 文件中已经引入 babel ，但仍然需要在项目根目录创建一个 .balbelrc 文件进行配置      解决方式  在项目根目录创建 .babelrc 文件即可实现对 babel 的基本配置{  "presets": [    ["env", {      "modules": false    }],    "stage-2"  ],  "plugins": ["transform-runtime", "transform-vue-jsx"]}]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 项目启动抛出 Expected indentation of 2 spaces but found 1 tab]]></title>
      <url>/vue/eslint/2018/04/20/Vue-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%8A%9B%E5%87%BA-Expected-indentation-of-2-spaces-but-found-1-tab/</url>
      <content type="text"><![CDATA[  该问题是由于 ESLint 的验证规则不匹配解决方式  在 .eslintrc.js 文件的 rules 中加入 'no-tabs': 'off' 即可不检测该问题// https://eslint.org/docs/user-guide/configuringmodule.exports = {	...  'rules': {		...		'no-tabs': 'off'  }}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> eslint </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> eslint </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 项目启动抛出 Error/ No PostCSS Config found in]]></title>
      <url>/vue/2018/04/20/Vue-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%8A%9B%E5%87%BA-Error-No-PostCSS-Config-found-in/</url>
      <content type="text"><![CDATA[  项目启动时抛出 Error: No PostCSS Config found in … 的错误表示某个 css 文件不能被引入解决办法  在项目根目录创建 postcss.config.js 文件，并配置以下内容module.exports = {    plugins: {      'autoprefixer': {browsers: 'last 5 version'}    }  } ]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[ESLint 代码规范性验证]]></title>
      <url>/vue/eslint/2018/04/20/ESLint-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%80%A7%E9%AA%8C%E8%AF%81/</url>
      <content type="text"><![CDATA[  ESLint 是可组装的JavaScript和JSX检查工具官网ESLint - Pluggable JavaScript linter - ESLint中文]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> eslint </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> eslint </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 项目启动抛出 Module build failed/ Error/ No ESLint configuration found.]]></title>
      <url>/vue/eslint/2018/04/19/Vue-%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E6%8A%9B%E5%87%BA-Module-build-failed-Error-No-ESLint-configuration-found</url>
      <content type="text"><![CDATA[  项目启动时控制台抛出 Module build failed: Error: No ESLint configuration found. 的错误出现错误的原因  因为项目根路径缺少 ESLint 的配置文件解决问题的方式  将 ESLint 相关配置文件添加至项目根路径// https://eslint.org/docs/user-guide/configuringmodule.exports = {  root: true,  parser: 'babel-eslint',  parserOptions: {    sourceType: 'module'  },  env: {    browser: true,  },  // https://github.com/standard/standard/blob/master/docs/RULES-en.md  extends: 'standard',  // required to lint *.vue files  plugins: [    'html'  ],  // add your custom rules here  'rules': {    // allow paren-less arrow functions    'arrow-parens': 0,    // allow async-await    'generator-star-spacing': 0,    // allow debugger during development    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0,    // 忽略函数空格检测    'space-before-function-paren': 0,    // 中缀操作符周围要不要有空格    'space-infix-ops': 0,    'no-trailing-spaces': 0,    'new-parens': 0  }}/build//config//dist//*.js]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> eslint </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> eslint </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot+IDEA热部署]]></title>
      <url>/java/springboot/software/2018/04/18/SpringBoot+IDEA%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      <content type="text"><![CDATA[  SpringBoot 自身有提供插件可实现代码热部署IDEA 相关配置  开启项目自动构建代码相关配置  pom 中加入以下依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;  扩展 spring-boot-maven-plugin 的插件配置项&lt;build&gt;    &lt;finalName&gt;mop&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;!-- 如果没有该项配置devtools不会起作用，即应用不会restart --&gt;                &lt;fork&gt;true&lt;/fork&gt;                &lt;!-- 支持静态文件热部署 --&gt;                &lt;addResources&gt;true&lt;/addResources&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> software </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> intellij </tag>
        
          <tag> idea </tag>
        
          <tag> software </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot集成Swagger]]></title>
      <url>/java/springboot/swagger/2018/04/17/SpringBoot%E9%9B%86%E6%88%90Swagger/</url>
      <content type="text"><![CDATA[  Swagger 是一款目前世界最流行的API管理工具官网  Swagger  Swagger Annotation集成步骤  在项目 pom 中引入以下依赖&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;  在项目中配置 Swagger@Configuration@EnableSwagger2public class SwaggerConfig {    @Bean    public Docket api() {        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()).select().apis(RequestHandlerSelectors.any()).paths(or(regex("/api/.*"))).build();    }    private ApiInfo apiInfo() {        return new ApiInfoBuilder().title("轻实训-移动端 API").version("1.0").build();    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> swagger </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> swagger </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot抛出ContextPath must start with xx and not end with xx异常]]></title>
      <url>/java/springboot/error/2018/04/17/SpringBoot%E6%8A%9B%E5%87%BAContextPath-must-start-with-xx-and-not-end-with-xx/</url>
      <content type="text"><![CDATA[  该异常属于项目配置的根路径出错解决问题的办法  在 application.yml 中将 server.servlet.context-path 设置的路径前加一个 /server:  servlet:    context-path: /api]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot启动抛出Unregistering JMX-exposed beans on shutdown异常]]></title>
      <url>/java/springboot/error/2018/04/16/SpringBoot%E5%90%AF%E5%8A%A8%E6%8A%9B%E5%87%BAUnregistering-JMX-exposed-beans-on-shutdown/</url>
      <content type="text"><![CDATA[  在配置 SpringBoot 项目时可能会抛出 Unregistering JMX-exposed beans on shutdown异常抛出错误的原因  是因为以下依赖的 scope 为 provided 导致的&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;解决的办法  将 provided 改为 compile 即可&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Muse UI]]></title>
      <url>/vue/frame/2018/04/16/Muse-UI/</url>
      <content type="text"><![CDATA[  Muse-ui 基于 Vue 2.0 和 Material Design 的 UI 组件库官网  Github  使用文档]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> frame </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> frame </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mint-ui 基于 vue 的移动端框架]]></title>
      <url>/vue/frame/mintui/2018/04/16/Mint-ui-%E5%9F%BA%E4%BA%8E-vue-%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6/</url>
      <content type="text"><![CDATA[  Mint UI 是由饿了么前端团队推出的基于 Vue.js 的移动端组件库官网  Github  使用文档]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> frame </category>
        
          <category> mintui </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> frame </tag>
        
          <tag> mintui </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 实现阿里云直播推流在线列表查询]]></title>
      <url>/java/aliyun/2018/04/12/Java-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%9C%A8%E7%BA%BF%E5%88%97%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  阿里云直播推流在线列表可以通过 API 的方式进行查询获取官网查询推流在线列表初始化配置  Constants.ALI_ACCESS_KEY_ID 是阿里云服务密钥 id ，所有服务共用  Constants.ALI_ACCESS_SECRET 是阿里云服务密钥，所有服务共用  将客户端的初始化放置在静态块中可以保证配置只初始化一次private static IAcsClient iAcsClient;static {    // 初始化配置    String regionId = "cn-shanghai";    DefaultProfile profile = DefaultProfile.getProfile(regionId, Constants.ALI_ACCESS_KEY_ID, Constants.ALI_ACCESS_SECRET);    iAcsClient = new DefaultAcsClient(profile);    // 本地调试    // System.setProperty("http.proxyHost", "127.0.0.1");    // System.setProperty("http.proxyPort", "8080");}查询推流在线列表  Constants.ALI_LIVE_PULL_URL 是阿里云直播的推流地址  Constants.ALI_LIVE_APP_NAME 是阿流云直播的应用名称          如果不指定，则会查询出所有的应用的推流列表      只能是单纯的应用名称，和阿里云直播控制台设置的保持一直        获取到推流在线列表后，只需要进行流名称的匹配即可public Boolean checkLiveBegin(String streamName) {    // 查询推流在线列表    DescribeLiveStreamsOnlineListRequest listRequest = new DescribeLiveStreamsOnlineListRequest();    listRequest.setDomainName(Constants.ALI_LIVE_PULL_URL);    listRequest.setAppName(Constants.ALI_LIVE_APP_NAME.replace("/", ""));    try {        DescribeLiveStreamsOnlineListResponse response = iAcsClient.getAcsResponse(listRequest);        // 获取当前推流列表        List&lt;LiveStreamOnlineInfo&gt; onlineInfos = response.getOnlineInfo();        for (LiveStreamOnlineInfo onlineInfo : onlineInfos) {            if (onlineInfo.getStreamName().equals(streamName)) {                return true;            }        }    } catch (ClientException e) {        logger.error("获取拉流信息失败！", e);    }    return false;}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> aliyun </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> aliyun </tag>
        
          <tag> live </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 通过 HttpConnection 解决 Ajax 请求跨域问题]]></title>
      <url>/java/crossdomain/2018/04/02/Java-%E9%80%9A%E8%BF%87-HttpConnection-%E8%A7%A3%E5%86%B3-Ajax-%E8%AF%B7%E6%B1%82%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      <content type="text"><![CDATA[  $.ajax 在访问外部服务器时会出现跨域问题，尝试过很多前端的方式解决都没有效果，最终是使用 Java 发送请求得以解决包装 Java 发送 Http 请求的工具类  该工具类中包括发送 GET/POST 请求的方法  方法只需要传入请求的地址和参数列表即可  参数列表的格式为 name1=value1&amp;name2=value2public class HttpUtils {    public static String sendGet(String url, String param) {        String result = "";        BufferedReader in = null;        try {            String urlNameString = url + "?" + param;            URL realUrl = new URL(urlNameString);            // 打开和URL之间的连接            URLConnection connection = realUrl.openConnection();            // 设置通用的请求属性            connection.setRequestProperty("accept", "*/*");            connection.setRequestProperty("connection", "Keep-Alive");            connection.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");            // 建立实际的连接            connection.connect();            // 获取所有响应头字段            Map&lt;String, List&lt;String&gt;&gt; map = connection.getHeaderFields();            // 定义 BufferedReader输入流来读取URL的响应            in = new BufferedReader(new InputStreamReader(connection.getInputStream()));            String line;            while ((line = in.readLine()) != null) {                result += line;            }        } catch (Exception e) {            System.out.println("发送GET请求出现异常！" + e);            e.printStackTrace();        } finally {            try {                if (in != null) {                    in.close();                }            } catch (Exception e2) {                e2.printStackTrace();            }        }        return result;    }    public static String sendPost(String url, String param) {        PrintWriter out = null;        BufferedReader in = null;        String result = "";        try {            URL realUrl = new URL(url);            // 打开和URL之间的连接            URLConnection conn = realUrl.openConnection();            // 设置通用的请求属性            conn.setRequestProperty("accept", "*/*");            conn.setRequestProperty("connection", "Keep-Alive");            conn.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");            // 发送POST请求必须设置如下两行            conn.setDoOutput(true);            conn.setDoInput(true);            // 获取URLConnection对象对应的输出流            out = new PrintWriter(conn.getOutputStream());            // 发送请求参数            out.print(param);            // flush输出流的缓冲            out.flush();            // 定义BufferedReader输入流来读取URL的响应            in = new BufferedReader(new InputStreamReader(conn.getInputStream()));            String line;            while ((line = in.readLine()) != null) {                result += line;            }        } catch (Exception e) {            System.out.println("发送 POST 请求出现异常！"+e);            e.printStackTrace();        } finally {            try{                if(out!=null){                    out.close();                }                if(in!=null){                    in.close();                }            } catch(IOException ex){                ex.printStackTrace();            }        }        return result;    }}调用工具类  如果调用的是 GET 请求请求参数会被拼接到链接之后，这是参数列表则需要对各种符号进行转码  URLEncoder.encode(input, "UTF-8") 是 java.net.URLEncoder 包中的方法String result = sendGet("http://120.27.199.194:7001/run", "code=" + URLEncoder.encode(input, "UTF-8"));]]></content>
      <categories>
        
          <category> java </category>
        
          <category> crossdomain </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> crossdomain </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java支付宝订单查询]]></title>
      <url>/java/pay/2018/04/01/Java-%E6%94%AF%E4%BB%98%E5%AE%9D%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  电脑网站支付成功后可通过支付宝接口主动查询订单结果前置条件  该方法基于 Java 支付宝扫码支付 (新) 实现调用查询接口进行订单查询public class AliQueryServiceImpl extends AliCoreServiceImpl {    public Boolean getPayResult(Long orderId) {        AlipayTradeQueryRequest queryRequest = new AlipayTradeQueryRequest();        queryRequest.setBizModel(generateOrderInfo(orderId));        AlipayTradeQueryResponse response = null;        try {            response = alipayClient.execute(queryRequest);        } catch (AlipayApiException e) {            logger.error("支付宝查询订单" + orderId + "失败！", e);        }        if (response == null) {            logger.error("支付宝未获取订单" + orderId + "详情！");            return false;        }        if (response.isSuccess()) {            if (response.getTradeStatus().equals(TRADE_STATUS_SUCCESS) || response.getTradeStatus().equals(TRADE_STATUS_FINISHED)) {                // 更新订单状态                updateOrderInfo(response.getOutTradeNo(), OrderPay.aliPay.getCode());                return true;            }            logger.error("支付宝订单" + orderId + "交易失败，交易状态：" + response.getTradeStatus());            return false;        } else {            logger.error("支付宝订单" + orderId + "查询失败！");            return false;        }    }    private AlipayTradeQueryModel generateOrderInfo(Long orderId) {        OrderDTO order = orderManageService.getOrder(orderId);        AlipayTradeQueryModel model = new AlipayTradeQueryModel();        model.setOutTradeNo(order.getCode());        return model;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java支付宝扫码支付[新]]]></title>
      <url>/java/pay/2018/03/31/Java-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98-%E6%96%B0/</url>
      <content type="text"><![CDATA[  支付宝老版本的 Web 端扫码支付产品为即时到账，更新到新版后现在的产品为电脑网站支付官网电脑网站支付快速接入准备数据  电脑网站支付 应用需要在开发者页面端进行申请和签约  应用签约成功之后需要获取以下信息          app_id: 签约成功的应用唯一标识      app_private_key: 通过 RSA 密钥生成的应用私钥，由开发者自己通过签名软件生成[支付宝提供]      alipay_public_key: 通过应用私钥和公钥生成的支付宝公钥，由支付宝自动生成      下载 Java 版 SDK  前往 电脑网站支付 SDK 获取 下载 Java 的 SDK  该 SDK 目前不支持 Maven 方式引入，只能通过本地引入  正常开发模式只需要引入 alipay-sdk-java-3.0.0.jar 即可获取支付宝客户端  支付宝客户端是调用所有接口的前置条件，所以应该放置在顶层父类做一次初始化  SOPConstants.ALI_PAY_SEND_URL 是该支付方式的统一请求接口，值为 https://openapi.alipay.com/gateway.dopublic class AliCoreServiceImpl extends OrderCoreServiceImpl {    // 参数返回格式    private static final String ALI_PAY_FORMAT = "json";    // 编码集，支持 GBK/UTF-8    protected static final String ALI_PAY_CHARSET = "utf-8";    // 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2/RSA ，推荐使用 RSA2    protected static final String ALI_PAY_SIGN_TYPE = "RSA2";    // 订单支付成功状态    protected static final String TRADE_STATUS_SUCCESS = "TRADE_SUCCESS";    // 订单支付结束状态    protected static final String TRADE_STATUS_FINISHED = "TRADE_FINISHED";    // 支付宝客户端    protected static AlipayClient alipayClient;    static {        // 初始化支付宝客户端        alipayClient = new DefaultAlipayClient(                SOPConstants.ALI_PAY_SEND_URL,                SOPConstants.ALI_PAY_APP_ID,                SOPConstants.ALI_PAY_PRIVATE_KEY,                ALI_PAY_FORMAT,                ALI_PAY_CHARSET,                SOPConstants.ALI_PAY_PUBLIC_KEY,                ALI_PAY_SIGN_TYPE);    }}发起支付宝付款页面请求  新版的扫码支付对请求参数和响应参数都做了封装，只需要传入对应参数值即可  SOPConstants.ALI_PAY_RETURN_URL 是支付宝付款成功需要的同步回执地址  SOPConstants.ALI_PAY_NOTIFY_URL 是支付宝付款成功需要的异步回执地址  以上两个地址都需要能够外网访问  该请求方式是通过拼接请求使用 iframe 获取支付宝的付款二维码          通过客户端发起请求时不使用一般的 pageExecute() 而使用 sdkExecute()      sdkExecute() 获取的是请求之后的参数值，所以还需要拼接请求地址      SOPConstants.ALI_PAY_SEND_URL 是支付请求地址      public class AliPayServiceImpl extends AliCoreServiceImpl {    public String aliPay(Long orderId) {        // 创建统一下单请求        AlipayTradePagePayRequest payRequest = new AlipayTradePagePayRequest();        payRequest.setReturnUrl(SOPConstants.ALI_PAY_RETURN_URL);        payRequest.setNotifyUrl(SOPConstants.ALI_PAY_NOTIFY_URL);        // 将订单详情传入业务请求参数中        payRequest.setBizModel(generateOrderInfo(orderId));        String body = null;        try {            body = alipayClient.sdkExecute(payRequest).getBody();        } catch (AlipayApiException e) {            logger.error("订单" + orderId + "获取支付宝付款界面失败！");        }        if (body == null) {            logger.error("订单" + orderId + "未成功获取支付宝付款界面！");        }        return SOPConstants.ALI_PAY_SEND_URL + "?" + body;    }    private AlipayTradePagePayModel generateOrderInfo(Long orderId) {        // 获取订单信息        OrderDTO order = orderManageService.getOrder(orderId);        AlipayTradePagePayModel model = new AlipayTradePagePayModel();        model.setOutTradeNo(order.getCode());        model.setProductCode("FAST_INSTANT_TRADE_PAY");        model.setTotalAmount(String.valueOf(order.getPrice()));        model.setSubject("实训在线-" + order.getName());        model.setBody("实训在线-" + order.getName());        // 二维码获取方式为模式4，最简洁模式，只有二维码        model.setQrPayMode("4");        model.setQrcodeWidth(240L);        return model;    }}  控制层调用请求接口获取完整请求地址@RequestMapping("/ali/{orderId}")public String ali(Model model, @PathVariable String orderId) {    model.addAttribute("order", orderManageService.getOrder(IdEncoder.decodeId(orderId)));    model.addAttribute("orderType", OrderPay.aliPay.getCode());    model.addAttribute("aliPayUrl", aliPayService.aliPay(IdEncoder.decodeId(orderId)));    return "/order/pay/ali";}  上述方法中拼接完整的二维码请求地址可以直接放置到 iframe 的 src 属性中          如果页面没有成功获取，可根据报错信息前往 验签失败错误排查 进行解决      &lt;iframe id="aliPayFrame" src="${aliPayUrl}" frameborder="0"&gt;&lt;/iframe&gt;接收同步回执  该地址需要与之前初始化客户端时提交给支付宝的同步回执地址保持一致  回执地址不能有任何多余参数@RequestMapping("/ali/return")public String aliReturn(HttpServletRequest request) {    aliNotifyService.aliReturn(request);    return null;}  新版的同步回执中不会携带订单的状态信息，所以只能用做一般的信息接收，不能做为交易成功的依据          同步回执需要验签，但验签的方法支付宝已提供，即 AlipaySignature.rsaCheckV2()      public void aliReturn(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    Boolean result = false;    try {        // 回执验签        result = AlipaySignature.rsaCheckV2(parameterToMap(request, false), SOPConstants.ALI_PAY_PUBLIC_KEY, ALI_PAY_CHARSET, ALI_PAY_SIGN_TYPE);    } catch (AlipayApiException e) {        logger.error("支付宝订单" + orderCode + "同步回执验签失败！", e);    }    if (result) {        logger.info("支付宝订单" + orderCode + "同步回执接收成功！");    } else {        logger.error("支付宝订单" + orderCode + "同步回执无效！");    }}  对同步回执中的响应参数验签之前，需要先将参数转化为 map 形式private Map&lt;String, String&gt; parameterToMap(HttpServletRequest request, Boolean isNotify) {    // 获取回执内容    Map requestParams = request.getParameterMap();    // 过滤回执内容    Map&lt;String, String&gt; params = Maps.newHashMap();    for (Object o : requestParams.keySet()) {        String name = (String) o;        String[] values = (String[]) requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        if (isNotify) {            params.put(name, valueStr);        } else {            try {                params.put(name, new String(valueStr.getBytes("ISO-8859-1"), "utf-8"));            } catch (UnsupportedEncodingException e) {                logger.error("支付宝订单同步回执转码失败！", e);            }        }    }    return params;}接收异步回执  该地址需要与之前初始化客户端时提交给支付宝的异步回执地址保持一致  回执地址不能携带任何参数@RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic String aliNotify(HttpServletRequest request) {    return aliNotifyService.aliNotify(request);}  异步回执作为支付成功的依据，支付宝成功通知到本地后，需要明确告知支付宝交易已成功          交易成功后返回 success 即可      当订单支付成功后订单可以展现两种状态，TRADE_SUCCESS 或 TRADE_FINISHED      public String aliNotify(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 订单状态    String orderStatus = request.getParameter("trade_status");    boolean result = false;    try {        result = AlipaySignature.rsaCheckV2(parameterToMap(request, true), SOPConstants.ALI_PAY_PUBLIC_KEY, ALI_PAY_CHARSET, ALI_PAY_SIGN_TYPE);    } catch (AlipayApiException e) {        logger.error("支付宝订单" + orderCode + "异步回执验签失败，订单状态为：" + orderStatus + "！", e);    }    // 验签成功    if (result) {        // 订单已支付        if (orderStatus.equals(TRADE_STATUS_SUCCESS) || orderStatus.equals(TRADE_STATUS_FINISHED)) {            // 更新订单状态            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());            return "success";        } else {            logger.error("支付宝订单" + orderCode + "未支付，订单状态为：" + orderStatus + "！");            return "fail";        }    } else {        logger.error("支付宝订单" + orderCode + "异步回执接收失败，订单状态为：" + orderStatus + "！");        return "fail";    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java微信订单查询]]></title>
      <url>/java/pay/2018/03/31/Java-%E5%BE%AE%E4%BF%A1%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  Java 通过统一下单 API 进行订单支付后，除等待微信通过 notify_url 进行回调通知外，还可以主动查询订单状态前置条件可参考 Java 微信扫码支付 如果实现微信支付官网【微信支付】扫码支付开发者文档定义请求参数对象  订单查询请求参数（必填）public class QueryOrderRequest {    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 商户订单号，32位以内，不重复    private String out_trade_no;    // 随机字符串，32位以内    private String nonce_str;    // 签名，遵循签名算法    private String sign;}  查询订单请求参数（非必填）public class QueryOrderRequestExt extends QueryOrderRequest {    // 签名类型，默认MD5    private String sign_type;}定义接收参数对象  查询订单接收参数（必填）public class QueryOrderResponse {    // 返回状态码，通信标识，SUCCESS/FAIL    private String return_code;    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 随机字符串    private String nonce_str;    // 签名    private String sign;    // 业务结果，交易标识，SUCCESS/FAIL    private String result_code;    // 用户标识    private String openid;    // 交易类型，JSAPI，NATIVE，APP    private String trade_type;    // 交易状态，SUCCESS-成功 USERPAYING-支付中    private String trade_state;    // 付款银行    private String bank_type;    // 标价金额，单位分    private int total_fee;    // 现金支付金额    private int cash_fee;    // 微信支付订单号    private String transaction_id;    // 商户订单号    private String out_trade_no;    // 支付完成时间    private String time_end;    // 交易状态描述    private String trade_state_desc;}  查询订单接收参数（非必填）public class QueryOrderResponseExt extends QueryOrderResponse {    // 返回信息，非空则表示返回了错误信息    private String return_msg;    // 错误代码    private String err_code;    // 错误代码描述    private String err_code_des;    // 设备号    private String device_info;    // 是否关注公众号    private String is_subscribe;    // 应结订单金额    private String settlement_total_fee;    // 标价币种    private String fee_type;    // 现金支付币种    private String cash_fee_type;    // 附加数据    private String attach;}生成订单信息  SOPConstants.WECHAT_PAY_APP_ID 是公众账号 id  SOPConstants.WECHAT_PAY_MCH_ID 是商户id  WechatUtil.makeNonceStr() 是生成的随机字符串  WechatUtil.makeSign(BeanMap.create(ext)) 是根据请求参数制作签名  WechatUtil.truncateDataToXML(QueryOrderRequestExt.class, ext) 是将数据转换为 XML 形式private String generateOrderInfo(Long orderId) {    OrderDTO order = orderManageService.getOrder(orderId);    QueryOrderRequestExt ext = new QueryOrderRequestExt();    ext.setAppid(SOPConstants.WECHAT_PAY_APP_ID);    ext.setMch_id(SOPConstants.WECHAT_PAY_MCH_ID);    ext.setOut_trade_no(order.getCode());    ext.setNonce_str(WechatUtil.makeNonceStr());    ext.setSign(WechatUtil.makeSign(BeanMap.create(ext)));    return WechatUtil.truncateDataToXML(QueryOrderRequestExt.class, ext);}向微信发起订单查询请求  SOPConstants.WECHAT_PAY_QUERY_URL 是微信订单查询的请求 URL  WechatConnection.connect() 是向微信发起请求的通用方法  只有 ext.getResult_code() ext.getResult_code()  ext.getTrade_state() 的值都是 SUCCESS 才能确定订单支付成功public Boolean getPayResult(Long orderId) {    String orderInfo = generateOrderInfo(orderId);    QueryOrderResponseExt ext = null;    try {        ext = (QueryOrderResponseExt) WechatConnection.connect(SOPConstants.WECHAT_PAY_QUERY_URL, orderInfo, QueryOrderResponseExt.class);    } catch (IOException e) {        logger.error("微信查询订单" + orderId + "失败！", e);    }    if (ext == null) {        return false;    }    if (WechatConnection.SUCCESS_CODE.equals(ext.getResult_code())) {        if (WechatConnection.SUCCESS_CODE.equals(ext.getResult_code()) &amp;&amp; WechatConnection.SUCCESS_CODE.equals(ext.getTrade_state())) {            // 更新订单状态            orderPayService.updateOrderInfo(ext.getOut_trade_no(), OrderPay.wchatPay.getCode());            return true;        } else {            logger.error("订单" + orderId + "交易失败，交易状态：" + ext.getTrade_state());            return false;        }    } else {        logger.error("订单" + orderId + "查询失败！");        return false;    }}微信支付相关操作工具类  该工具类目前提供了数据转换、签名生成、随机数生成的通用方法public class WechatUtil {    private static Logger logger = LoggerFactory.getLogger(WechatUtil.class);    /**     * 数据转换为xml格式     *     * @param object     * @param obj     * @return     */    public static String truncateDataToXML(Class&lt;?&gt; object, Object obj) {        XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));        xStream.alias("xml", object);        return xStream.toXML(obj);    }    /**     * 数据转换为对象     *     * @param object     * @param str     * @return     */    public static Object truncateDataFromXML(Class&lt;?&gt; object, String str) {        XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));        xStream.alias("xml", object);        return xStream.fromXML(str);    }    /**     * 生成随机字符串     *     * @return     */    public static String makeNonceStr() {        StringBuffer str = new StringBuffer(DateUtil.getSysDateString("yyyyMMddHHmmssS"));        str.append((new Random().nextInt(900) + 100));        return str.toString();    }    /**     * 拼接签名数据     *     * @return     */    public static String makeSign(BeanMap beanMap) {        SortedMap&lt;String, String&gt; signMaps = Maps.newTreeMap();        for (Object key : beanMap.keySet()) {            Object value = beanMap.get(key);            // 排除空数据            if (value == null) {                continue;            }            signMaps.put(key + "", String.valueOf(value));        }        // 生成签名        return generateSign(signMaps);    }    /**     * 生成签名     *     * @param signMaps     * @return     * @throws Exception     */    public static String generateSign(SortedMap&lt;String, String&gt; signMaps) {        StringBuffer sb = new StringBuffer();        // 字典序        for (Map.Entry signMap : signMaps.entrySet()) {            String key = (String) signMap.getKey();            String value = (String) signMap.getValue();            // 为空不参与签名、参数名区分大小写            if (null != value &amp;&amp; !"".equals(value) &amp;&amp; !"sign".equals(key) &amp;&amp; !"key".equals(key)) {                sb.append(key).append("=").append(value).append("&amp;");            }        }        // 拼接key        sb.append("key=").append(SOPConstants.WECHAT_PAY_KEY);        // MD5加密        return Objects.requireNonNull(encoderByMd5(sb.toString())).toUpperCase();    }    /**     * 利用MD5进行加密     *     * @param str 待加密的字符串     * @return 加密后的字符串     */    private static String encoderByMd5(String str) {        // 生成一个MD5加密计算摘要        MessageDigest md = null;        try {            md = MessageDigest.getInstance("MD5");        } catch (NoSuchAlgorithmException e) {            logger.error("MD5加密失败！", e);        }        if (md == null) {            return null;        }        // 计算md5函数        md.update(str.getBytes());        // digest()最后确定返回md5 hash值，返回值为8为字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符        // BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值        return new BigInteger(1, md.digest()).toString(16);    }}微信支付请求建立类public class WechatConnection {    // 成功标志    public static final String SUCCESS_CODE = "SUCCESS";    /**     * 建立微信连接，并返回结果     *     * @param url     * @param info     * @param object     * @return     * @throws IOException     */    public static Object connect(String url, String info, Class&lt;?&gt; object) throws IOException {        // 建立连接        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();        conn.setConnectTimeout(8000);        conn.setRequestMethod("POST");        conn.setDoOutput(true);        // 发送数据        BufferedOutputStream bos = new BufferedOutputStream(conn.getOutputStream());        bos.write(info.getBytes());        bos.flush();        bos.close();        // 获取数据        BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));        // 接收数据        String line;        StringBuffer str = new StringBuffer();        while ((line = reader.readLine()) != null) {            str.append(line);        }        return WechatUtil.truncateDataFromXML(object, str.toString());    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> wechatpay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[BeanMap 实现对象转换 Map]]></title>
      <url>/java/map/2018/03/31/BeanMap-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2-Map/</url>
      <content type="text"><![CDATA[  通过 org.springframework.cglib.beans 的 BeanMap 可以实现对象将字段和字段值直接转换为 Map 的 key-value 形式实现方式SortedMap&lt;String, String&gt; signMaps = Maps.newTreeMap();BeanMap beanMap = BeanMap.create(ext);for (Object key : beanMap.keySet()) {    Object value = beanMap.get(key);    // 排除空数据    if (value == null) {        continue;    }    signMaps.put(key + "", String.valueOf(value));}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> map </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> map </tag>
        
          <tag> spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 实现阿里云直播]]></title>
      <url>/java/jquery/aliyun/2018/03/19/Java-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B4%E6%92%AD/</url>
      <content type="text"><![CDATA[  阿里云播放器直接在线点播视频以及直播技术，此处记录直播实现过程官网阿里云直播-快速入门 准备步骤  创建 阿里云账号  根据 流程 完成实名认证，以确保可以使用阿里云相应服务  在密钥管理页面获取阿里云访问密钥，AccessKeyId 和 AccessKeySecret  开通阿里云直播服务关键点  阿里云直播服务端提供了 一系列 API ，但如果只是单纯的直播[推流和拉流] ，实际不需要使用这些 API推流准备  推流即直播人员进行视频播放的操作，这需要使用推流客户端 第三方推流工具 OBS  在推流工具中需要指定推流地址、流名称、鉴权密钥  如果上述信息阿里云验证合法，既可以开始直播，在阿里云后端可以看到正在直播的流信息拉流准备  拉流即直播观众通过视频播放器在线获取直播信息，播放器使用 阿里云播放器 即可，该播放器目前只是阿里云的点播和直播服务  获取拉流地址后传入播放器，即可开始观看直播Java 开发注意点  在阿里云直播的文档中有提供 Java SDK          目前 SDK 中推荐引入的版本号是 2.3.0 ，但其实所有 API 参照的都是最新版 SDK ，最新的版本号可在 阿里云SDK频道 找到        但如果只是单纯的直播[推流和拉流] ，则不需要进行以上操作  推流的关键点在于 直播鉴权          此处介绍的直播鉴权只是说的 auth_key 的拼接和验证规则      完整的推流和拉流地址并不知这些，需要依旧案例参考      获取推流地址  此处获取的只是推流地址的房间号及其他请求参数  完整的推流地址需要加上阿里云直播中心地址和用户的产品名称          直播中心地址 http://video-center.alivecdn.com      产品名称[支持自定义] /appName/        vhost 用于接收拉流地址，即申请阿里云直播时准备的直播域名  此处使用 Java MD5加密 实现字串加密，加密后长度需要是 32 位  加密串中的 Constants.ALI_LIVE_PRIVATE_KEY  可在阿里云后端的直播鉴权处获取// 获取推流地址public String getPushUri(String roomName, Long endTime) {    return getRoomName(roomName) + "vhost=" + Constants.ALI_LIVE_PULL_URL + "&amp;" + generateAuthKey(roomName, endTime);}// 房间号private String getRoomName(String roomName) {    return roomName + "?";}// 完整验签串private String generateAuthKey(String roomName, Long endTime) {    return "auth_key=" + endTime + generateUuid() + generateEncryptStr(roomName, endTime);}// 唯一标识private String generateUuid() {    String uuid = "0";    String uid = "0";    return "-" + uuid + "-" + uid + "-";}// 验签密钥private String generateEncryptStr(String roomName, Long endTime) {    String uri = Constants.ALI_LIVE_APP_NAME + roomName;    return md5(uri + "-" + endTime + generateUuid() + Constants.ALI_LIVE_PRIVATE_KEY);}获取拉流地址  此处获取的拉流地址是完整的，因为拉流地址是直接获取后传入前端的阿里云播放器中  注意房间名后面加的后缀 .m3u8 用于表示接受的直播视频类型，阿里云官方还提供其他几种类型，可在文档中查看  拉流地址和推流地址最大的区别在于请求地址的不同，拉流是请求自己提供给阿里云的直播域名，而拉流是请求阿里云的直播中心  而且推流时需要指定 vhost 告知阿里云直播域名，但拉流时不需要  获取到拉流地址后可直接参照 Java + jQuery 实现阿里云播放器接口 实现播放器的对接          在播放器的的配置中指明 isLive: true 表名是直播操作      上述笔记中实现的是点播接口，利用的通过 vid 获取 playAuth 的方式，这不适用于直播      直播需要直接指定 source: url 即可      public String getPullUrl(String roomName, Long endTime) {    roomName += ".m3u8";    return "http://" + Constants.ALI_LIVE_PULL_URL + generateUri(roomName) + generateAuthKey(roomName, endTime);}// 获取请求参数private String generateUri(String roomName) {	return Constants.ALI_LIVE_APP_NAME + getRoomName(roomName);}// 房间号private String getRoomName(String roomName) {    return roomName + "?";}// 完整验签串private String generateAuthKey(String roomName, Long endTime) {    return "auth_key=" + endTime + generateUuid() + generateEncryptStr(roomName, endTime);}// 唯一标识private String generateUuid() {    String uuid = "0";    String uid = "0";    return "-" + uuid + "-" + uid + "-";}// 验签密钥private String generateEncryptStr(String roomName, Long endTime) {    String uri = Constants.ALI_LIVE_APP_NAME + roomName;    return md5(uri + "-" + endTime + generateUuid() + Constants.ALI_LIVE_PRIVATE_KEY);}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> jquery </category>
        
          <category> aliyun </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> jquery </tag>
        
          <tag> aliyun </tag>
        
          <tag> player </tag>
        
          <tag> live </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 实现阿里云短信]]></title>
      <url>/java/aliyun/2018/03/11/Java-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1/</url>
      <content type="text"><![CDATA[  阿里云提供一套短信发送的服务可通过 Java 进行对接官网短信发送API(SendSms)—阿里云准备步骤  创建 阿里云账号  根据 流程 完成实名认证，以确保可以使用阿里云相应服务  在密钥管理页面获取阿里云访问密钥，AccessKeyId 和 AccessKeySecret  想要成功发送一条短信需要获取 短信签名 和 短信模版在项目 pom 中引入对接所需要的 jar 包&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;    &lt;version&gt;3.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt;    &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;获取对接需要的数据  将 AccessKeyId 、AccessKeySecret 、SignName 、TemplateCode 进行相应存储新建 MessageServiceImpl 类用于和阿里云短信接口对接@Servicepublic class MessageServiceImpl extends AbstractBaseService {		...}在上述类中生成一个静态块用于在初始化对接信息  Constants.ALI_ACCESS_KEY_ID 和 Constants.ALI_ACCESS_SECRET 是密钥，成对生成和使用  其他参数信息按照阿里云开发手册说明，均不需要改变// 用于从阿里云获取数据的权限客户端private static IAcsClient iAcsClient;static {    // 超时时间    System.setProperty("sun.net.client.defaultConnectTimeout", "10000");    System.setProperty("sun.net.client.defaultReadTimeout", "10000");    // 初始化配置    String regionId = "cn-hangzhou";    DefaultProfile profile = DefaultProfile.getProfile(regionId, Constants.ALI_ACCESS_KEY_ID, Constants.ALI_ACCESS_SECRET);    try {        String productId = "Dysmsapi";        String domain = "dysmsapi.aliyuncs.com";        DefaultProfile.addEndpoint(regionId, regionId, productId, domain);    } catch (ClientException e) {        throw new TSharkException("初始化短信接口配置失败！", e);    }    // 初始化权限客户端    iAcsClient = new DefaultAcsClient(profile);}创建用于发送短信的 sendMessage 方法  发送短信之前通常需要验证短信是否已发送，防止重复发送  为了验证短信是否发送可将通过短信发送的验证码存放于 Redis 中  Constants.ALI_MESSAGE_SIGN_NAME 是从阿里云获取的短信签名  为提高公用性，发送短信的方法支持从外部调用时传入具体模版编号  短信接口调用时如果出现异常反馈，请参照 短信接口调用错误码@Autowiredprivate RedisHelper redisHelper;public Boolean sendMessage(String mobile, String template) {    // 有效性验证    if (checkMobile(mobile)) {        throw new TSharkException("验证码已发送，请稍后再试！");    }    SendSmsRequest request = new SendSmsRequest();    SendSmsResponse response = null;    // 生成随机数    String random = String.valueOf(new Random().nextInt(999999));    request.setMethod(MethodType.POST);    request.setPhoneNumbers(mobile);    request.setSignName(Constants.ALI_MESSAGE_SIGN_NAME);    request.setTemplateCode(template);    request.setTemplateParam("{\"name\":\"" + mobile + "\", \"code\":\"" + random + "\"}");    try {        response = iAcsClient.getAcsResponse(request);    } catch (ClientException e) {        throw new TSharkException("接收短信回执失败！", e);    }    boolean result = response.getCode() != null &amp;&amp; response.getCode().equals("OK");    if (result) {        // 保存随机数        saveRandom(mobile, random);    }    return result;}通过 Redis 验证短信是否发送private Boolean checkMobile(String mobile) {    String randomKey = "random:" + mobile;    return redisHelper.get(randomKey) != null;}短信发送成功后需要将手机号和验证码成对存储于 Redis 中，以供之后使用private void saveRandom(String mobile, String random) {    String randomKey = "random:" + mobile;    if (checkMobile(mobile)) {        return;    }    redisHelper.set(randomKey, random);    // 5分钟失效    redisHelper.expire(randomKey, 5, TimeUnit.MINUTES);}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> aliyun </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> aliyun </tag>
        
          <tag> message </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java + jQuery 实现阿里云点播]]></title>
      <url>/java/jquery/aliyun/2018/03/11/Java-+-jQuery-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%82%B9%E6%92%AD/</url>
      <content type="text"><![CDATA[  阿里云播放器直接在线点播视频以及直播技术，此处记录点播实现过程官网获取阿里云视频播放凭证阿里云Aliplayer播放器准备步骤  创建 阿里云账号  根据 流程 完成实名认证，以确保可以使用阿里云相应服务  在密钥管理页面获取阿里云访问密钥，AccessKeyId 和 AccessKeySecret后端相关操作在项目 pom 中引入所需 jar 包&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;    &lt;version&gt;3.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;获取对接需要的数据  将 AccessKeyId 、AccessKeySecret 进行相应存储新建 VideoController 用于接收前端获取视频播放凭证的请求@Controller@RequestMapping("/api/video")public class VideoController extends AbstractBaseController {    @Autowired    private VideoServiceImpl videoServiceImpl;    /**     * 获取播放凭证     *     * @param videoId     * @return     */    @RequestMapping(value = "/auth", method = RequestMethod.POST)    @ResponseBody    public ResponseData playAuth(@RequestParam final String videoId) {        return new SimpleActionHandler(request) {            @Override            protected void doHandle(ResponseData responseData) throws Exception {                responseData.setData(videoServiceImpl.getVideoPlayAuth(videoId));            }        }.handle();    }}新建 VideoServiceImpl 用于和阿里云播放器接口对接@Servicepublic class VideoServiceImpl extends AbstractBaseService {	...}在 VideoServiceImpl 中添加获取客户端的 getClient() 方法  Constants.ALI_ACCESS_KEY_ID 和 Constants.ALI_ACCESS_SECRET 是密钥，成对生成和使用  其他参数信息按照阿里云开发手册说明，均不需要改变private DefaultAcsClient getClient() {    // 初始化配置    DefaultProfile profile = DefaultProfile.getProfile("cn-shanghai", Constants.ALI_ACCESS_KEY_ID, Constants.ALI_ACCESS_SECRET);    // 获取客户端    return new DefaultAcsClient(profile);}通过外部传入的视频 id 从客户端获取视频播放凭证public String getVideoPlayAuth(String videoId) {    GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest();    GetVideoPlayAuthResponse response = null;    // 播放id    request.setVideoId(videoId);    try {        response = getClient().getAcsResponse(request);    } catch (ClientException e) {        logger.error("视频客户端获取失败！", e);    }    if (response != null) {        return response.getPlayAuth();    }    return null;}前端相关操作引入播放器所需要的 css/js 文件  以下引入的 js 文件为通用版本，包括了 flash 和 h5 的播放器  如果只想单独引入 flash 或 h5 ，只需要将名称中间加上对应标识即可，例如 aliplayer-h5-min.js  css 文件为公有版本，无需区分类型&lt;link rel="stylesheet" href="//g.alicdn.com/de/prismplayer/2.5.1/skins/default/aliplayer-min.css"/&gt;&lt;script charset="utf-8" type="text/javascript" src="//g.alicdn.com/de/prismplayer/2.5.1/aliplayer-min.js"&gt;&lt;/script&gt;准备待转化为播放器的标签内容  标签中的 data-id 是将视频传入到阿里云播放器后端之后返回的一个 vid  该 vid 可以通过 接口上传 也可以通过阿里云后端上传，此处不做介绍&lt;div class="prism-player" id="prismPlayer" data-id="281fc1687cb245658dc5e7462e54bc66"&gt;&lt;/div&gt;初始化视频播放器  $.ts.doAction 是经过封装后的 ajax 操作  Aliplayer({...}) 则是具体的播放器初始化操作var playerTag = target.find("#prismPlayer");var videoId = playerTag.data("id");// 移除文字标识playerTag.empty();// 非空验证if (videoId === undefined) {    return;}$.ts.doAction("/api/video/auth", {    videoId: videoId}, function () {    Aliplayer({        id: "prismPlayer",        autoplay: true,        width: "100%",        vid: videoId,        playauth: this.data    });}, '', '', '');]]></content>
      <categories>
        
          <category> java </category>
        
          <category> jquery </category>
        
          <category> aliyun </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> jquery </tag>
        
          <tag> aliyun </tag>
        
          <tag> player </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis抛出You can't operate on a closed Connection!!!]]></title>
      <url>/java/mybatis/error/2018/03/08/MyBatis%E6%8A%9B%E5%87%BAYou-can't-operate-on-a-closed-Connection!!!/</url>
      <content type="text"><![CDATA[  有时候通过 Session 获取数据库连接时为空碰到的问题  一般通过以下方式获取数据库连接  但有时候会出现获取不到连接，从而抛出 You can’t operate on a closed Connection!!! 的异常Connection connection = this.SqlSession().getConnection();解决的方式  使用以下方式获取数据库连接可保证获取的连接存在与事务中不会莫名丢失SqlSessionTemplate st = (SqlSessionTemplate) this.getSqlSession();SqlSession session = SqlSessionUtils.getSqlSession(st.getSqlSessionFactory(), st.getExecutorType(), st.getPersistenceExceptionTranslator());Connection connection = session.getConnection();]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[List抛出ConcurrentModificationException]]></title>
      <url>/java/list/error/2018/03/01/List%E6%8A%9B%E5%87%BAConcurrentModificationException/</url>
      <content type="text"><![CDATA[  在对 List 进行遍历的同时进行 remove 元素操作，可能会抛出 java.util.ConcurrentModificationException 异常错误示范  在遍历 List 时获取元素实际上通过迭代器在进行，迭代器在获取下一个元素时会对 modCount 和 expectedCount 进行匹配  遍历的同时直接对 List 进行 remove 操作，会导致只有 modCount 发生变化，而expectedCount 未发生变化  所以迭代器在获取下一个元素会发现两个值不匹配则抛出 java.util.ConcurrentModificationException 异常for (CourseDTO course : courses) {    for (MemberCourseDTO memberCourse : memberCourses) {        if (course.getId().equals(memberCourse.getCourse().getId())) {            courses.remove(course);        }    }}正确处理  使用迭代器原生的 remove 方法去操作 List 元素即可for (Iterator&lt;CourseDTO&gt; it = courses.iterator(); it.hasNext(); ) {    CourseDTO course = it.next();    for (MemberCourseDTO memberCourse : memberCourses) {        if (course.getId().equals(memberCourse.getCourse().getId())) {            // 移除当前元素            it.remove();        }    }}Java 8 的处理方式question.getOptions().removeIf(option -&gt; option.getContent().trim().equals(""));]]></content>
      <categories>
        
          <category> java </category>
        
          <category> list </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> list </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript数组属性]]></title>
      <url>/javascript/array/2018/02/11/Javascript%E6%95%B0%E7%BB%84%E5%B1%9E%E6%80%A7/</url>
      <content type="text"><![CDATA[  Javascript数组可用来存储多个数组，但他也有些不常见的内置功能数组的真面目  数组的索引其实也是数组的属性，所以如下操作是等同的let array = ['Tom', 'Jerry']console.log(array[0]) =&gt; Tomconsole.log(array.0) =&gt; Tom   数组的内置属性let array = ['Tom', 'Jerry']console.log(array.length) =&gt; 2console.log(array['length']) =&gt; 2  数组其实可以添加自定义属性，因为数组其实也是一个object对象let array = ['Tom', 'Jerry']array.itemName = 'wow'console.log(array.itemName) =&gt; wow循环数组的元素  自从ES6发布之后，可以不再使用传统的 for 循环对数组进行遍历，而可以使用 for ... of 循环直接操作数组元素for (let item of array) {	console.log(item)}数组元素的数量不等于数组长度  通常情况下数组元素的数量就是数组的长度，但这种关系非常脆弱，参见如下代码let array = []array.lentgh = 3console.log(array.length) =&gt; 3array[5] = 'Lily'console.log(array.length) =&gt; 5]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> array </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> array </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue获取组件name属性]]></title>
      <url>/vue/components/2018/02/05/Vue%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6name%E5%B1%9E%E6%80%A7/</url>
      <content type="text"><![CDATA[  Vue在编写组件时一般都会显式的指明其name属性获取name属性this.$options.name]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> components </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> components </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate防止setter()方法更新数据库]]></title>
      <url>/java/hibernate/2018/02/05/Hibernate%E9%98%B2%E6%AD%A2setter()%E6%96%B9%E6%B3%95%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="text"><![CDATA[  Hibernate从数据库获取到对象后直接调用其setter()方法对内部数据做更改，可能会导致直接将数据更新至数据库产生问题的原因  Hibernate分为三种基本状态：游离态，自由态，持久态  从数据库中获取到对象属于持久态，直接进行操作会导致处于Session中的数据发生改变，从而触发数据库更新解决办法  获取到当前的Session对象，将该对象从Session中清除super.getEntityDao().getSession().evict(userWork);]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue集成highlight.js]]></title>
      <url>/vue/2018/02/03/Vue%E9%9B%86%E6%88%90highlight.js/</url>
      <content type="text"><![CDATA[  highlight.js是一个比较实用的语法高亮插件，但其默认并不能在Vue中直接使用在项目的package.json文件中安装highlight.js{	...	"dependencies": {		...		"highlight.js": "^9.12.0"	},	...}编写集成文件，稍后会作为自定义插件引入Vueimport Hljs from 'highlight.js'import 'highlight.js/styles/googlecode.css'let Highlight = {}Highlight.install = (Vue, options) =&gt; {  Vue.directive('highlight', (el) =&gt; {    let blocks = el.querySelectorAll('pre code')        blocks.forEach((block) =&gt; {      Hljs.highlightBlock(block)    })  })}export default Highlight在main.js中引入上述文件...import Highlight from './assets/plugins/highlight/highlight.js'Vue.use(Highlight)...在需要使用到语法高亮的标签上使用v-highlight并传入待显示内容  由于定义的监听规则是带 pre code 的内容，所以可能需要手动为待显示内容进行一次标签包裹&lt;div v-highlight v-html="showFileContent"&gt;&lt;/div&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue自定义v-model]]></title>
      <url>/vue/2018/02/02/Vue%E8%87%AA%E5%AE%9A%E4%B9%89v-model/</url>
      <content type="text"><![CDATA[  Vue的v-model双向绑定非常实用，对于自定义组件也可以自定义实现v-model实现方案  在组件的 props 中定义 value 值用于接收父级传入的内容props: {  value: {    type: Boolean,    default: false  }}  在组件的 data() 中定义将 value 另存为的实际值data () {  return {    show: false  }}  在组件的 watch 中监听两个值的变化          监听 value 变化的目的是将最新的值专递给组件中的实际值      监听 show 变化的目的是当实际值发生变化时告知父容器传入值已发生变化      watch: {  value (val) {    if (val === this.show) {      return false    }    this.show = val  },  show (val) {    this.$emit('input', val)  }}  在父容器中使用 v-model 传入需要双向绑定的值即可]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java8 Lambda遍历集合]]></title>
      <url>/java/jdk8/2018/01/20/Java8-Lambda%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88/</url>
      <content type="text"><![CDATA[  Java8支持使用Lambda语法对集合进行遍历，语法如下ListallQuestions.forEach(question -&gt; {    if (question.getType().getCode().equals(typeCode)) {        filterQuestions.add(question);    }});Mapitems.forEach((k, v) -&gt; {    System.out.println("Item : " + k + " Count : " + v);    if("E".equals(k)) {        System.out.println("Hello E");    }});]]></content>
      <categories>
        
          <category> java </category>
        
          <category> jdk8 </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> jdk8 </tag>
        
          <tag> for </tag>
        
          <tag> map </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate @OneToOne 自动新增和删除]]></title>
      <url>/java/hibernate/2018/01/12/Hibernate-@OneToOne-%E8%87%AA%E5%8A%A8%E6%96%B0%E5%A2%9E%E5%92%8C%E5%88%A0%E9%99%A4/</url>
      <content type="text"><![CDATA[  Hibernate创建一对一关系时两张表主表保持一致则可以实现自动新增和删除主表配置  主表对应类中需要通过@OneToOne来表示其与从表的关系@Entity@Table(name = "sys_user")public class User {    @Id    @GeneratedValue(strategy = IDENTITY)    private Long id = new Long(0);    @OneToOne(cascade = {CascadeType.ALL}, mappedBy = "user", fetch = FetchType.LAZY)    @JsonIgnore    private UserAccount userAccount;    public UserAccount getUserAccount() {        return userAccount;    }    public void setUserAccount(UserAccount userAccount) {        this.userAccount = userAccount;    }}从表配置  从表中的id需要通过@GeneratedValue和@GenericGenerator来指明该值从主表中获取  从表中同时需要通过@OneToOne来表示其与主表的关系          在维护与主表关系中需要通过@PrimaryKeyJoinColumn来表示两个表是主键关联，不存在多余外键      @Entity@Table(name = "sys_user_account")public class UserAccount {    @Id    @GeneratedValue(generator = "generator")    @GenericGenerator(name = "generator", strategy = "foreign", parameters = @Parameter(name = "property", value = "user"))    private Long id = 0L;    @OneToOne(fetch = FetchType.LAZY)    @PrimaryKeyJoinColumn    private User user;    public UserAccount() {    }    public UserAccount(User user) {        this.user = user;    }    public Long getId() {        return id;    }    public void setId(Long id) {        this.id = id;    }    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}保存操作  主表在执行保存操作时，需要将从表注入其中，同时将主表的引入也注入到从表，才能实现两个对象的双向关联  当主表的id自增成功时，由于从表保有对主表的引用，所以也可以得到主表的idpublic void save(User user) {    if (user.isNew()) {        user.setUserAccount(new UserAccount(user));        super.save(user);    } else {        super.save(userModel);    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot从数据库加载配置信息]]></title>
      <url>/java/springboot/hibernate/2017/12/31/SpringBoot%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
      <content type="text"><![CDATA[  Spring Boot 通过@Value注解可实现获取配置文件中的数据，而配置文件中的数据可以通过修改MutablePropertySources从数据库注入该示例基于Hibernate实现实体类  根据Hibernate的配置，实体类对应数据库中的表即可@Entity@Table(name = "sys_config")@Inheritance(strategy = InheritanceType.SINGLE_TABLE)public class Config implements Serializable {    @Id    private Long id;    @Column    private String code;    @Column    private String value;    @Column    private String name;    @Column    private String description;  ...}服务类  服务类用于从数据库中获取列表信息@Servicepublic class SystemConfigService extends SimpleHibernateService&lt;Config, Long&gt; {   ...}配置类  该配置类会在系统启动时自动加载  根据内部逻辑会将从数据库取出的列表信息注入到MutablePropertySources属性集合中  动态注入的属性集合无需有对应的 .properties 文件存在@Configurationpublic class SystemConfig {    @Autowired    private ConfigurableEnvironment environment;    @Autowired    private SystemConfigService service;    @PostConstruct    public void initDatabasePropertySourceUsage() {        // 获取系统属性集合        MutablePropertySources propertySources = environment.getPropertySources();        try {            // 从数据库获取自定义变量列表            Map&lt;String, String&gt; collect = service.getAll().stream().collect(Collectors.toMap(Config::getCode, Config::getValue));            // 将转换后的列表加入属性中            Properties properties = new Properties();            properties.putAll(collect);            // 将属性转换为属性集合，并指定名称            PropertiesPropertySource constants = new PropertiesPropertySource("system-config", properties);            // 定义寻找属性的正则，该正则为系统默认属性集合的前缀            Pattern p = Pattern.compile("^applicationConfig.*");            // 接收系统默认属性集合的名称            String name = null;            // 标识是否找到系统默认属性集合            boolean flag = false;            // 遍历属性集合            for (PropertySource&lt;?&gt; source : propertySources) {                // 正则匹配                if (p.matcher(source.getName()).matches()) {                    // 接收名称                    name = source.getName();                    // 变更标识                    flag = true;                    break;                }            }            if (flag) {                // 找到则将自定义属性添加到该属性之前                propertySources.addBefore(name, constants);            } else {                // 没找到默认添加到第一位                propertySources.addFirst(constants);            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }}工具类  由于Spring Boot不支持静态变量的自动注入，所以需要使用一个非静态的setter方法将通过@Value注解获取到的属性信息赋值给对应静态变量  @DependsOn({"systemConfig"}) 的意思是说 Constants 依赖于 SystemConfig ，所以需要确保 SystemConfig 在 Constants 之前加载@Configuration@DependsOn({"systemConfig"})public class Constants {    // 资源服务器地址    public static String RESOURCE_SERVER_URL;    @Value("${resource.server.url}")    public void setResourceServerUrl(String resourceServerUrl) {        RESOURCE_SERVER_URL = resourceServerUrl;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot+Vue表单文件上传]]></title>
      <url>/java/springboot/vue/2017/12/31/SpringBoot+Vue%E8%A1%A8%E5%8D%95%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      <content type="text"><![CDATA[  Spring Boot + Vue 的文件上传本身没有什么难点，但如果涉及到是一个表单对象中存在文件，则会比较繁琐后端实体类  Spring Boot中对于文件的接收类型和Spring MVC保持一致，使用MultipartFile  与Spring MVC不同的是Spring Boot进行文件上传操作不需要添加配置信息，Spring Boot自身已经默认开启了文件上传功能...public class Work {  ...    @Transient    private MultipartFile referenceFile;  ...}后端接收请求的接口  SpringBoot与Vue进行集成，使用axios进行异步请求发送，对于接收对象类型的数据一般使用@RequestBody的注解将对象解析为JSON格式  但是MultipartFile类型的文件无法转换为JSON格式，所以此处需要使用@ModelAttribute的注解接收对象信息...@RestController@RequestMapping("/${contextPath}/works")public class WorkController extends SimpleController&lt;Work, WorkService&gt; {  ...    @ApiOperation("保存作业")    @PostMapping("")    public ResponseData saveRule(@ModelAttribute Work work) {  return workService.save(work);    }  ...}前端对文件数据的处理  使用默认的文件输入框进行文件上传会影响美观，所以通常将输入框隐藏后通过点击按钮进行调用  由于文件格式的input属性是只读的，所以无法使用v-model对其数据的更改进行实时获取  所以需要通过@change对其数据的更改进行监听，并赋值给表单的对应属性&lt;template&gt;  &lt;in-form ref="inForm" :form="work" :rules="rules" :is-file="true"&gt;    ...    &lt;el-button type="success" v-else @click="uploadReferenceFile"&gt;    上传答案 &lt;span v-text="work.reference"&gt;&lt;/span&gt;    &lt;input type="file" class="upload-file" ref="referenceFile" @change="setReferenceFile"&gt;    &lt;/el-button&gt;    ...  &lt;/in-form&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;...  export default {    ...    methods: {...      // 上传参考答案      uploadReferenceFile () {        this.$refs.referenceFile.click()      },      // 设置参考答案      setReferenceFile (item) {        let currentFile = item.target.files[0]        this.work.reference = currentFile.name        this.work.referenceFile = currentFile      }...  }&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt;  .upload-file    display none&lt;/style&gt;前端发起请求的方式  文件格式的数据无法通过JSON格式进行传递，所以需要使用FormData对表单数据进行转换  但FormData只能接受String和File格式的数据，对应Object格式的数据无法处理  如果涉及到Object格式的数据则需要前后端配合进行数据转换  通常情况下对象中关联的对象只涉及到其中的某一个值，所以前端在处理时可以单独将该值进行传递  后端在接收到该值后，可以在其Setter方法中将数据赋予对应的对象即可export function save ({url, data}, isFile) {  // 带文件的上传功能  if (isFile) {    let formData = new FormData()        // 遍历传入的数据    for (let key in data) {      // 获取当前值      let currentData = data[key]        // 对于空值进行过滤      if (currentData === '') {        continue      }            // 将对象中的键值对传入formData中      formData.append(key, currentData)    }        data = formData  }    return fetch({    url: url,    method: config.POST,    data  })}限制文件大小  只需要在::application.properties::中添加如下配置即可spring.http.multipart.max-file-size=10MBspring.http.multipart.max-request-size=10MB]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> vue </tag>
        
          <tag> form </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue支持JSX语法]]></title>
      <url>/vue/2017/12/18/Vue%E6%94%AF%E6%8C%81JSX%E8%AF%AD%E6%B3%95/</url>
      <content type="text"><![CDATA[  Vue中的渲染函数可以支持JSX语法，但需要进行如下配置官网渲染函数 &amp; JSX — Vue.js为项目添加依赖  首先需要引入 babel-plugin-transform-vue-jsx 插件          在::package.json::中的 devDependencies 加入如下配置      插件官网中提到的 babel-preset-env 可能已经存在，所以未指出      "babel-plugin-syntax-jsx": "^6.18.0","babel-plugin-transform-vue-jsx": "^3.5.0","babel-helper-vue-jsx-merge-props": "^2.0.3",在.babelrc中加入如下配置  transform-vue-jsx 是上述操作中导入的插件名称{  "presets": [    ["env", {      "modules": false    }],    "stage-2"  ],  "plugins": ["transform-runtime", "transform-vue-jsx"]}完成以上两点后即可按照Vue for JSX的语法进行编写，但编译器中可能会报错，需要做如下更改  将 &lt;script/&gt; 脚本类型改为 type="text/jsx"&lt;script type="text/jsx"&gt;	...&lt;/script&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> jsx </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue元素点击时获取当前对象]]></title>
      <url>/vue/2017/12/16/Vue%E5%85%83%E7%B4%A0%E7%82%B9%E5%87%BB%E6%97%B6%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1/</url>
      <content type="text"><![CDATA[  vue中在元素点击时获取当前对象需要手动传入当前对象在点击时传入当前对象  $event 表示当前被点击的对象&lt;el-menu-item v-for="submenu in menu.submenus" @click="clickSubmenu(submenu.operations, $event)"&gt;	&lt;/el-menu-item&gt;在触发的方法中通过声明参数进行接收clickSubmenu (operations, event) {  if (event &amp;&amp; hasClass(event.$el, 'is-active')) {    return false  }}]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Maven针对SpringBoot的多项目依赖配置]]></title>
      <url>/java/maven/springboot/2017/12/16/Maven%E9%92%88%E5%AF%B9Spring-Boot%E7%9A%84%E5%A4%9A%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  在Spring Boot中对于多项目依赖配置，可通过Maven实现创建一个父级的pom文件  在该pom中指定其 &lt;groupId/&gt;、&lt;artifactId/&gt; 、&lt;version/&gt;  &lt;packaging/&gt; 必须是pom  &lt;parent/&gt; 需要引入 spring-boot-starter-parent 表示继承Spring Boot的父级配置  &lt;modules/&gt; 中依次引入后续需要相互依赖的项目  &lt;dependencyManagement/&gt; 中对上述引入的项目进行完成依赖配置&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;        &lt;groupId&gt;com.innovaee.hts.parent&lt;/groupId&gt;    &lt;artifactId&gt;innovaee-hts-parent&lt;/artifactId&gt;    &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;name&gt;innovaee-hts-parent&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;1.5.8.RELEASE&lt;/version&gt;    &lt;/parent&gt;    &lt;modules&gt;        &lt;module&gt;hts-admin-backend&lt;/module&gt;  ...    &lt;/modules&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.innovaee.hts&lt;/groupId&gt;                &lt;artifactId&gt;hts-admin-backend&lt;/artifactId&gt;                &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;            &lt;/dependency&gt;  ...        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;&lt;/project&gt;在各个子项目的pom中对依赖关系进行配置  父级不再指向Spring Boot的父级，而是上述自定义父级&lt;parent&gt;    &lt;groupId&gt;com.innovaee.hts.parent&lt;/groupId&gt;    &lt;artifactId&gt;innovaee-hts-parent&lt;/artifactId&gt;    &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt;  从父级中获取需要的依赖配置&lt;dependency&gt;    &lt;groupId&gt;org.tshark.core&lt;/groupId&gt;    &lt;artifactId&gt;tshark-core&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  ...&lt;/dependency&gt;在需要被打包成jar包的项目中引入Spring Boot的编译插件&lt;build&gt;    &lt;finalName&gt;hts-admin&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;在父级pom所在的目录中执行打包命令对项目进行打包mvn clean package -Dmaven.test.skip=true]]></content>
      <categories>
        
          <category> java </category>
        
          <category> maven </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> maven </tag>
        
          <tag> springboot </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[es6为类创建多个构造函数]]></title>
      <url>/javascript/es6/2017/12/15/es6%E4%B8%BA%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
      <content type="text"><![CDATA[  虽然ES6之后可以实现JavaScript创建Class，但自身并不提供函数重载，所以无法直接创建多个构造函数解决  原理则是对一个构造函数的传值进行类型判断，从而实现根据类型的不同调用不同的构造函数方法体export default class User {    constructor (obj) {    if (typeof obj === 'string') {      this._constructorSimple(obj)    } else if (typeof obj === 'object') {      this._constructorComplex(obj)    }  }    _constructorSimple (id) {    this.id = id    this.code = ''    this.name = ''    this.sex = '男'    this.age = 20    this.birthday = ''    this.address = ''    this.selectedGroup = []    this.selectedRoles = []  }    _constructorComplex (data) {    this.id = data.id    this.code = data.code    this.name = data.name    this.sex = data.sex    this.age = data.age    this.birthday = data.birthday    this.address = data.address    this.selectedGroup = data.groupIds.split(',')    this.selectedRoles = data.selectedRoles  }}]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> es6 </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> es6 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[vue-quill-editor 富文本框编辑器]]></title>
      <url>/vue/2017/12/07/vue-quill-editor-%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A1%86%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      <content type="text"><![CDATA[  基于quilljs实现的支持vue的富文本框编辑器官网  vue-quill-editor  Toolbar Module - Quill  vue-quill-image-upload图片支持上传服务器并调整大小  在 package.json 中加入 "quill-image-extend-module": "^1.1.2" 依赖  在编辑器组件中引入以下代码&lt;template&gt;  &lt;div class="in-editor-panel"&gt;    &lt;quill-editor ref="quillEditor" v-model="content" :options="editorOption" @change="onChange"&gt;    &lt;/quill-editor&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;  import 'quill/dist/quill.core.css'  import 'quill/dist/quill.snow.css'  import { quillEditor, Quill } from 'vue-quill-editor'  import { ImageExtend, QuillWatch } from 'quill-image-extend-module'  import { hasClass } from 'assets/scripts/dom/dom'  Quill.register('modules/ImageExtend', ImageExtend)  export default {    props: {      value: {        type: String,        default: ''      },      toolbarMode: {        type: Number,        default: 0      },      placeholder: {        type: String,        default: '请输入内容'      },      height: {        type: Number,        default: 170      },      imagePath: {        type: String,        default: ''      }    },    data () {      return {        content: '',        toolbars: [          [            ['bold', 'italic', 'underline', 'strike'],            ['blockquote', 'code-block'],            [{'header': 1}, {'header': 2}],            [{'list': 'ordered'}, {'list': 'bullet'}],            [{'script': 'sub'}, {'script': 'super'}],            [{'indent': '-1'}, {'indent': '+1'}],            [{'direction': 'rtl'}],            [{'size': ['small', false, 'large', 'huge']}],            [{'header': [1, 2, 3, 4, 5, 6, false]}],            [{'font': []}],            [{'color': []}, {'background': []}],            [{'align': []}],            ['clean'],            ['link', 'image', 'video']          ],          [            ['bold', 'italic', 'underline'],            ['blockquote', 'code-block'],            [{'list': 'ordered'}, {'list': 'bullet'}],            [{'header': [1, 2, 3, 4, 5, 6, false]}],            [{'color': []}, {'background': []}],            [{'align': []}],            ['link', 'image', 'video']          ],          [            ['bold', 'italic', 'underline'],            ['blockquote', 'code-block'],            [{'list': 'ordered'}, {'list': 'bullet'}],            [{'color': []}, {'background': []}],            ['insert']          ]        ],        editorOption: {          modules: {            ImageExtend: {              loading: true,              name: 'image',              size: 2,              action: `/api/file/upload/image?filePath=${JSON.stringify(this.imagePath)}`,              response: (res) =&gt; {                return res.data              }            },            toolbar: {              container: [],              handlers: {                'image': function () {                  QuillWatch.emit(this.quill.id)                }              }            }          },          placeholder: this.placeholder        }      }    },    computed: {      editor () {        return this.$refs.quillEditor.quill      }    },    watch: {      // 监听父组件传入的内容      value (newVal) {        this.$nextTick(() =&gt; {          this._listenerImage()        })        if (newVal === this.content) {          return false        }        // 传入的内容不等于编辑器自身内容，则更新        this.content = newVal      },      'content' () {        this._listenerImage()      }    },    created () {      // 指定工具栏      this.editorOption.modules.toolbar.container = this.toolbars[this.toolbarMode]    },    mounted () {      // 设置编辑器高度      this.editor.container.style.height = `${this.height}px`    },    methods: {      // 显示宽度修改框      _showWidthBox (event) {        // 获取当前图片对象        let currentImg = event.target        // 弹出宽度输入框        this.$prompt('请输入宽度', '提示', {          inputValue: currentImg.width,          confirmButtonText: '确定',          cancelButtonText: '取消'        }).then(({value}) =&gt; {          // 赋值新宽度          currentImg.width = value        }).catch(() =&gt; {})      },      // 监听图片点击      _listenerImage () {        // 获取DOM对象        let editor = document.getElementsByClassName('ql-editor')[0]        let img = editor.getElementsByTagName('img')        // 非空验证        if (img.length === 0) {          return        }        for (let i = 0; i &lt; img.length; i++) {          let currentImg = img[i]          // 绑定且防止重复绑定          currentImg.removeEventListener('dblclick', this._showWidthBox, false)          currentImg.addEventListener('dblclick', this._showWidthBox, false)        }      },      onChange () {        // 告知父组件内容发生变化        this.$emit('input', this.content)      }    },    components: {      quillEditor    }  }&lt;/script&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> editor </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[export和export default的区别]]></title>
      <url>/javascript/es6/2017/11/27/export%E5%92%8Cexport-default%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="text"><![CDATA[  export 本质上就是规定模块[js文件]的对外接口[属性或方法]export default 则是在 export 的基础上，为规定模块提供一个默认的对外接口export的使用  直接输出export let words = 'hello world!!!'export function output() {	// ...}  先定义再输出 推荐使用          需要注意的是，对于这种输出方式，不论最终 export 决定输出几个接口，都需要使用一堆大括号包裹      let firstWords = 'hello'let secondWords = 'world'let thirdWords = '!!!'function output() {	// ...}export {firstWords, secondWords, thirdWords, output}export default的使用  export default 用于规定模块的默认对外接口  很显然默认对外接口只能有一个，所以 export default 在同一个模块中只能出现一次  export default 除了不具备 export 所拥有的第二种输出方式以外，其在 import 方式上也和 export 存在一定区别          从以下两种 import 方式即可显著看出 export default 的 import 方式不需要使用大括号包裹      因为对于 export default 其输出的本来就只有一个接口，提供的是模块的默认接口，自然不需要使用大括号包裹        export的输出与import输入export function output() {	// ...}import {output} from './example'  export default的输出与import输入export default function output() {	// ...}import output from './example']]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> es6 </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> es6 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[vue-lazyload懒加载]]></title>
      <url>/vue/2017/11/24/vue-lazyload%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      <content type="text"><![CDATA[  用于vue中的懒加载插件，可实现图片懒加载等操作官网GitHub - hilongjw/vue-lazyload: A Vue.js plugin for lazyload your Image or Component in your application.]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> lazyload </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue生命周期图例]]></title>
      <url>/vue/2017/11/24/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E4%BE%8B/</url>
      <content type="text"><![CDATA[  以下是对Vue声明周期官方图例的简单解读]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue生命周期]]></title>
      <url>/vue/2017/11/24/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="text"><![CDATA[  每个Vue实例都有个完整的生命周期，也就是Vue实例从创建到销毁的整个过程，实际上在这个过程中Vue的实例经历了很多变化解读生命周期图例Vue生命周期图例每个钩子函数的触发时间  beforeCreate          在实例初始化之前被调用      数据观测和初始化事件都还没开始        created          实例已经创建完之后被调用      此处已经完成数据观测和初始化事件[数据、方法的运算，watch/event回调]        beforeMount          在对象挂载之前被调用      相关联的render函数首次被执行        mounted          new Vue() 声明中的 el 被 vm.$el 替换，并挂载到实例上之后，调用此钩子      在整个生命周期中只执行一次，即时之后实例被update        beforeUpdate          数据更新时被调用      此操作发生在虚拟DOM重新渲染和打补丁之前      可在该钩子中对状态做进一步更改，此时不会触发重新渲染，而是直接执行本次渲染        updated          虚拟DOM重新渲染和打补丁之后被调用      该钩子被调用时，组件的DOM元素已经被更新，理论上可以在此时对DOM进行操作，但不推荐在此时更改实例状态，因为可能会导致无限循环      该钩子在服务器首次渲染实例时不会被调用        beforeDestroy          实例销毁之前被调用      在此时实例依旧可以被调用        destroyed          实例销毁之后被调用      该钩子执行完毕之后会带来以下操作                  实例所指向的所有属性、方法都会解绑          所有的监听事件都会被移除          所有的子实例也会被销毁                    该钩子在服务器首次渲染实例时不会被调用      ]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[var let const 的区别]]></title>
      <url>/javascript/es6/2017/11/23/var-let-const-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="text"><![CDATA[  var是ES6之前JavaScript用于定义变量的语法，而let const是ES6之后JavaScript用于定义变量的语法var存在的两个bug  JS没有块级作用域          通过var声明的变量，其作用域是函数的全部        循环内变量会过度共享          意思就是说在循环内部定义的变量，在循环外部依旧可以访问      let存在的意义  let声明的变量拥有块级作用域          let声明的变量其作用域只是外层快，而不是外层函数        let声明的全局变量不是全局对象的属性          通过let声明的全局变量无法通过window.变量名进行访问，其只存在于一个不存的作用域中        行如 for(let x in data) 的循环在每次迭代时都会为 x 创建新的绑定  let声明的变量无法重新被定义const的作用  const就是用于定义常量的]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> es6 </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> es6 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[better-scroll移动端滚动]]></title>
      <url>/vue/2017/11/23/better-scroll%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%BB%9A%E5%8A%A8/</url>
      <content type="text"><![CDATA[  better-scroll的核心借鉴了iscroll的实现，其重点解决移动端各种滚动场景需求官网  GitHub - ustbhuangyi/better-scroll: inspired by iscroll, and it has a better scroll perfermance  Document]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> scroll </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue编写代理请求的方法改进]]></title>
      <url>/vue/webpack/2017/11/23/Vue%E7%BC%96%E5%86%99%E4%BB%A3%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E6%96%B9%E6%B3%95%E6%94%B9%E8%BF%9B/</url>
      <content type="text"><![CDATA[  vue升级到2.9.1后，通过其vue-cli构建的webpack项目目录结构发生以下变化发生的变化1. 在2.9.1之前，通过vue-cli构建的项目build目录如下，如左图2. 在2.9.1之后，通过vue-cli构建的项目build目录如下，如右图 ![](http://asing1elife.com/sources/images/FD738C66-A0DB-4492-959D-EB22CC7F23C4.png)  ![](http://asing1elife.com/sources/images/AD33A96F-6270-409A-94BB-C83EE75FE58D.png)3. 通过以上两张图可以明确看出新版本构建出的项目缺少了**dev-client.js**和**dev-server.js**文件造成的问题  缺少dev-server.js文件之后，所带来的问题是之前我们在需要编写代理请求时会在该文件中自定义如下路由信息，而现在应该将这些路由信息存放在哪var apiRoutes = express.Router()apiRoutes.get('/getDiscList', function (req, res) {  var url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'  axios.get(url, {    headers: {      referer: 'https://c.y.qq.com/',      host: 'c.y.qq.com'    },    params: req.query  }).then((response) =&gt; {    res.json(response.data)  }).catch((e) =&gt; {    console.log(e)  })})app.use('/api', apiRoutes)解决的方式  其实在新版本中关于服务器的配置信息都被存放在webpack.dev.conf.js文件中，所以对于用来发送代理请求的自定义路由信息自然也应该存放到该文件中  只是存放的方式稍有变化，在新版本中服务器通过webpack-dev-server进行管理，所以需要在该server启动之前将代理请求接口映射完毕  webpack3内置了express() ，以下代码中的app就是express返回的对象devServer: {  ...  // 在服务器开启之前，将需要被代理的请求与本地接口进行一一对应  before (app) {    // 由于QQ音乐获取歌单列表的接口做了header信息的验证，所以需要通过代理的方式去模拟其规则范围的header，使用其允许的header发起请求    app.get('/api/getDiscList', function (req, res) {      // 真实的QQ音乐获取歌单列表的请求      const url = 'https://c.y.qq.com/splcloud/fcgi-bin/fcg_get_diss_by_tag.fcg'      // 通过axios发送异步请求      axios.get(url, {        // 在发送请求时修改头文件，模拟合法的头文件，去欺骗服务器获取请求数据        headers: {          referer: 'https://c.y.qq.com/',          host: 'c.y.qq.com'        },        // 获取参数列表        // 由于浏览器请求参数是穿透传播的，所以当前端请求getDiscList时，传递的参数在次数可以直接获取到        params: req.query      }).then((response) =&gt; {        // res是本地方法接收本地请求的返回值        // response是访问服务器接口的返回值        // 此处只需要将从服务器获取的返回值通过json的方式传递给本地请求的返回值，即实现了一次代理转发        res.json(response.data)      }).catch((e) =&gt; {        // 捕获错误信息并输出        console.error(e)      })    })  }}]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> webpack </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> webpack </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue修改项目启动端口号]]></title>
      <url>/vue/2017/11/23/Vue%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7/</url>
      <content type="text"><![CDATA[  Vue项目启动时默认端口号是8080，如果要启动多个项目就会发生冲突，通过以下方式可修改默认端口号在项目的package.json中可以找到如下代码  start属性指定的文件就是通过开发模式启动的服务文件"scripts": {  "dev": "node build/dev-server.js",  "start": "node build/dev-server.js",  "build": "node build/build.js",  "lint": "eslint --ext .js,.vue src"}在build目录下的dev-server.js中可以找到如下代码  可以发现uri在拼接port接口之前，port接口首先根据是生产还是开发，被赋予了不同的端口号  而开发环境下的端口号来自config目录var config = require('../config')...var port = process.env.PORT || config.dev.port...var uri = 'http://localhost:' + port在config目录下的index.js中可以找到如下代码  修改此处的port即可修改开发环境下启动项目的端口号dev: {	...  port: 8090,	...}]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JSONP实现]]></title>
      <url>/javascript/jsonp/2017/11/23/JSONP%E5%AE%9E%E7%8E%B0/</url>
      <content type="text"><![CDATA[  实现简单的JSONP语法网址GitHub - webmodules/jsonp: A simple JSONP implementation]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> jsonp </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> jsonp </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Axios ajax异步库]]></title>
      <url>/vue/2017/11/23/Axios-ajax%E5%BC%82%E6%AD%A5%E5%BA%93/</url>
      <content type="text"><![CDATA[  axios是vue官方推荐使用的实现ajax异步的插件库官网GitHub - axios/axios: Promise based HTTP client for the browser and node.js]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> axios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[WebStorm for vue环境准备]]></title>
      <url>/vue/intellij/webstorm/2017/11/22/WebStorm-for-vue%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/</url>
      <content type="text"><![CDATA[  在WebStorm中导入项目后，vue的语法默认不能被识别，所以需要做到如下配置插件  输入 Command+, 进入Preferences界面，并找到Plugins分支  点击页面底部的Browse repositories进入到插件商店  在商店中搜索 Vue ，选中并安装  重启WebStorm语法  输入 Command+, 进入Preferences界面，并找到Languages Frameworks分支  打开分支选择第一项JavaScript  将分支页面中的JavaScript language version修改为 ECMAScript 6 即可]]></content>
      <categories>
        
          <category> vue </category>
        
          <category> intellij </category>
        
          <category> webstorm </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> intellij </tag>
        
          <tag> webstorm </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue-CLI命令行工具]]></title>
      <url>/vue/2017/11/22/Vue-CLI%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
      <content type="text"><![CDATA[  vue-cli是Vue官网提供的一个命令行工具，可用于快速搭建大型单页应用在全局安装vue-clinpm install --global vue-cli创建一个基于webpack的新项目  执行该命令后会先下载templates  之后会依次要求输入一系列项目信息vue init webpack my-project跳转到项目根目录对项目进行安装npm install在项目根目录启动项目npm run dev]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Vue 集成 Animate.css]]></title>
      <url>/vue/2017/11/21/Vue-%E9%9B%86%E6%88%90-Animate.css/</url>
      <content type="text"><![CDATA[  通过CSS实现了很多动画效果，可以直接调用官网Animate.css实现方式  下载 animate.css 文件并在项目的 main.js 中引入import Vue from 'vue'...import 'assets/plugins/animate/animate.css'.../* eslint-disable no-new */new Vue({  el: '#app',  render: h =&gt; h(App),  store,  router})结合 transition 组件一起使用  duration 可控制动画的加载速度&lt;transition leave-active-class="animated fadeOutRight" enter-active-class="animated fadeInRight" :duration="300"&gt;  &lt;mt-field class="search-input" placeholder="请输入搜索内容" v-show="search" v-model="searchContent"&gt;&lt;/mt-field&gt;&lt;/transition&gt;]]></content>
      <categories>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> vue </tag>
        
          <tag> transition </tag>
        
          <tag> animate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Velocity.js动画库]]></title>
      <url>/javascript/animate/2017/11/21/Velocity.js%E5%8A%A8%E7%94%BB%E5%BA%93/</url>
      <content type="text"><![CDATA[  通过JS实现了很多动画效果，可以直接调用官网Velocity.js 中文文档]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> animate </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> animate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Tween.js 动画库]]></title>
      <url>/javascript/animate/2017/11/21/Tween.js-%E5%8A%A8%E7%94%BB%E5%BA%93/</url>
      <content type="text"><![CDATA[  TweenJS是一个简单的JS动画库官网Tween]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> animate </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> animate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Circles 圆形进度条]]></title>
      <url>/javascript/charts/2017/11/19/Circles-%E5%9C%86%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
      <content type="text"><![CDATA[  生成一个圆形的进度条官网Create circular SVG charts with Circles : Lugo Labs]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> charts </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> charts </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Lodash 扩展js通用方法]]></title>
      <url>/2017/11/18/Lodash-%E6%89%A9%E5%B1%95JS%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="text"><![CDATA[Lodash 扩展JS通用方法#javascript/plugin  Lodash是一个著名的javascript原生库，不需要引入其他第三方依赖。是一个意在提高开发者效率,提高JS原生方法性能的JS库官网  Lodash Documentation  lodash 中文文档语法集合[Collection]  _.find  在集合中获取到指定元素var users = [  { 'user': 'barney',  'age': 36, 'active': true },  { 'user': 'fred',    'age': 40, 'active': false },  { 'user': 'pebbles', 'age': 1,  'active': true }] // 自定义匹配规则_.find(users, function(o) { return o.age &lt; 40; })  _.filter 获取集合中满足条件的元素集var users = [  { 'user': 'barney', 'age': 36, 'active': true },  { 'user': 'fred',   'age': 40, 'active': false }] // =&gt; { 'user': 'fred',   'age': 40, 'active': false }_.filter(users, function(o) { return !o.active; })数组[Array]  _.findIndex 在数组中获取指定元素的索引          匹配的规则可自定义      匹配到则返回对应索引，否则返回-1      let fileType = currentFile.typelet currentIndex = _.findIndex(this.types, function (type) {	return fileType.toLowerCase().match(new RegExp(type))})  _.unionWith 连接两个数组          连接的规则可自定义      规则返回true的则跳过      this.examPaper.examQuestions = _.unionWith(this.examPaper.examQuestions, this.selectQuestions, (a, b) =&gt; {  return a.hexId === b.hexId})  _.drop 移除数组元素          默认移除第一个元素      可显式指定从第几个元素开始移除      _.drop(this.userWorkIds)]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC配置i18n]]></title>
      <url>/java/springmvc/i18n/2017/11/14/SpringMVC%E9%85%8D%E7%BD%AEi18n/</url>
      <content type="text"><![CDATA[  i18n是internationalization首字母i和末尾字母n以及中间18个字母的简称，意于国际化在/src/main/resources下新建messages文件夹  新增以下文件          message.properties用于默认资源      message_zh_CN.properties用于中文资源      message_en_US.properties用于英文资源      spring-config.xml添加配置信息&lt;!-- 配置i18n资源文件 --&gt;&lt;bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;  &lt;!-- 资源文件路径 --&gt;  &lt;property name="basename" value="classpath:messages/message"/&gt;  &lt;!-- 默认编码 --&gt;  &lt;property name="defaultEncoding" value="UTF-8"/&gt;  &lt;!-- 指定默认资源文件 --&gt;  &lt;property name="useCodeAsDefaultMessage" value="true"/&gt;&lt;/bean&gt;spring-mvc.xml添加配置信息&lt;!-- 将Locale信息存放于Session中 --&gt;&lt;!-- id必须是localeResolver，否则会报cannot change HTTP Head ... --&gt;&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.SessionLocaleResolver"/&gt;&lt;!-- 配置拦截器获取Locale信息 --&gt;&lt;mvc:interceptors&gt;  &lt;bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/&gt;&lt;/mvc:interceptors&gt;IndexControler.java中的添加获取Locale信息方法public class IndexController {    @Autowired  private MessageSource messageSource;  @RequestMapping("")  public String main(Model model, HttpServletRequest request, HttpServletResponse response) {    // 设置语言格式    setLanguage(model, request, response, Locale.getDefault());        return "/index";  }    @RequestMapping("/{language}")  public String main(Model model, HttpServletRequest request, HttpServletResponse response, @PathVariable String language) {    // 分割参数    String[] languages = language.split("_");        // 设置系统语言    setLanguage(model, request, response, new Locale(languages[0], languages[1]));        return "/index";  }    /**   * 设定语言格式   */  private void setLanguage(Model model, HttpServletRequest request, HttpServletResponse response, Locale locale) {    // 获取LocaleResolver    LocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(request);        // 设置Locale信息    localeResolver.setLocale(request, response, locale);        // 传递正确的Locale信息到页面    model.addAttribute("encoding", messageSource.getMessage("encoding", new Object[0], locale));  }  }页面中添加spring的tag用于使用message.properties中的标签信息&lt;%@ taglib uri="http://www.springframework.org/tags" prefix="spring" %&gt;页面上使用spring标签获取标签信息&lt;spring:message code="title" /&gt;首页提供一个下拉框用于手动切换语言&lt;div class="form select-langugae-panel"&gt;  &lt;div class="form-group"&gt;    &lt;select class="select-content select-content-btn"&gt;      &lt;option value="zh_CN" &lt;c:if test="${encoding eq 'zh_CN' }"&gt;selected&lt;/c:if&gt;&gt;中文&lt;/option&gt;      &lt;option value="en_US" &lt;c:if test="${encoding eq 'en_US' }"&gt;selected&lt;/c:if&gt;&gt;English&lt;/option&gt;    &lt;/select&gt; &lt;i class="select-arrow"&gt;&lt;/i&gt;  &lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> i18n </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> i18n </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC+MyBatis项目搭建]]></title>
      <url>/java/springmvc/mybatis/2017/11/12/SpringMVC+MyBatis%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      <content type="text"><![CDATA[  SpringMVC作为一个敏捷开发的常用框架，和MyBatis进行集成需要如下步骤构建项目  创建一个Maven Project，并添加web.xml  在pom.xml中引入以下依赖包  为保证项目编译的JDK版本统一，需要加入以下配置&lt;build&gt;  &lt;plugins&gt;    &lt;plugin&gt;      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;      &lt;configuration&gt;        &lt;source&gt;1.8&lt;/source&gt;        &lt;target&gt;1.8&lt;/target&gt;      &lt;/configuration&gt;    &lt;/plugin&gt;  &lt;/plugins&gt;&lt;/build&gt;添加Spring依赖包&lt;!-- Spring核心包 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-core&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring IoC --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring包扫描 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring数据库连接 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring事务管理器 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring Web --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring WebMVC --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;添加MyBatis依赖包&lt;!-- MyBatis核心包 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.2.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- MyBatis Spring依赖包 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;  &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;添加数据库依赖包&lt;!-- MySQL连接 --&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;5.1.18&lt;/version&gt;&lt;/dependency&gt;&lt;!-- c3p0 --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.mchange&lt;/groupId&gt;  &lt;artifactId&gt;c3p0&lt;/artifactId&gt;  &lt;version&gt;0.9.5.1&lt;/version&gt;&lt;/dependency&gt;添加视图层依赖包&lt;!-- 视图层的核心包 --&gt;&lt;dependency&gt;  &lt;groupId&gt;taglibs&lt;/groupId&gt;  &lt;artifactId&gt;standard&lt;/artifactId&gt;  &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- JSTL --&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;jstl&lt;/artifactId&gt;  &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Servlet容器 --&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;  &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;在web.xml中添加配置  配置 DispatcherServlet&lt;!-- 配置DispatcherServlet --&gt;&lt;servlet&gt;  &lt;servlet-name&gt;asl-ums-dispatcher&lt;/servlet-name&gt;  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  &lt;!-- 加载Spring配置文件 --&gt;  &lt;init-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;!-- 项目启动时加载文件 --&gt;  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;  映射路径规则```xml  asl-ums-dispatcher  /## 创建**spring-mvc.xml**并添加配置```xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc"xsi:schemaLocation="                http://www.springframework.org/schema/beans                http://www.springframework.org/schema/beans/spring-beans.xsd                http://www.springframework.org/schema/mvc                http://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/context                http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 自动注入 --&gt;&lt;!-- 用于提供数据绑定、数字@NumberFormat和日期格式化@DateTimeFormat以及xml和json的默认读写支持 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 配置静态资源 --&gt;&lt;!-- 加入对js/gif/png等静态资源的处理 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 指定默认路径 --&gt;&lt;mvc:view-controller path="/" view-name="redirect:/index"/&gt;&lt;!-- 配置JSP显示 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;  &lt;property name="prefix" value="/WEB-INF/views"/&gt;  &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt;&lt;!-- 扫描指定路径下的类 --&gt;&lt;context:component-scan base-package="online.shixun.asl.module"&gt;  &lt;!-- 扫描带有@Controller注解的类 --&gt;  &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;  &lt;!-- 扫描带有@Service注解的类 --&gt;  &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;创建spring-config.xml并添加配置&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;!-- 指定数据库文件 --&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;&lt;!-- 配置c3p0连接池 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;  &lt;!-- 数据库连接信息 --&gt;  &lt;property name="driverClass" value="${driver}"/&gt;  &lt;property name="jdbcUrl" value="${url}"/&gt;  &lt;property name="user" value="${username}"/&gt;  &lt;property name="password" value="${password}"/&gt;  &lt;!-- 最大连接数 --&gt;  &lt;property name="maxPoolSize" value="30"/&gt;  &lt;!-- 最小连接数 --&gt;  &lt;property name="minPoolSize" value="10"/&gt;  &lt;!-- 获取连接的超时时间，毫秒 --&gt;  &lt;property name="checkoutTimeout" value="5000"/&gt;  &lt;!-- 连接失败后的重连次数 --&gt;  &lt;property name="acquireRetryAttempts" value="1"/&gt;&lt;/bean&gt;&lt;!-- 配置事务管理器，MyBatis采用jdbc的事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;  &lt;!-- 指定数据源 --&gt;  &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;!-- 配置声明式事务 --&gt;&lt;tx:annotation-driven/&gt;&lt;!-- 配置SqlSessionFactory --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;  &lt;!-- 指定数据源 --&gt;  &lt;property name="dataSource" ref="dataSource"/&gt;  &lt;!-- 指定MyBatis全局配置文件 --&gt;  &lt;property name="configLocation" value="classpath:spring-mybatis.xml"/&gt;  &lt;!-- 指定实体类扫描路径 --&gt;  &lt;property name="typeAliasesPackage" value="online.shixun.asl.dto"/&gt;  &lt;!-- 指定映射文件的扫描路径 --&gt;  &lt;property name="mapperLocations" value="classpath:mapper/*Mapper.xml"/&gt;&lt;/bean&gt;&lt;!-- 将Dao注入Spring容器中 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;  &lt;!-- 指定扫描路径 --&gt;  &lt;property name="basePackage" value="online.shixun.asl.module"/&gt;  &lt;!-- 扫描带有@MyBatisRepository --&gt;  &lt;property name="annotationClass" value="online.shixun.asl.core.MyBatisRepository"/&gt;&lt;/bean&gt;&lt;/beans&gt;创建spring-mybatis.xml并添加配置&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;!-- 配置全局属性 --&gt;    &lt;settings&gt;        &lt;!-- 使用数据库自增主键 --&gt;        &lt;setting name="useGeneratedKeys" value="true"/&gt;        &lt;!-- 显示SQL语句 --&gt;        &lt;setting name="logImpl" value="STDOUT_LOGGING"/&gt;    &lt;/settings&gt;&lt;/configuration&gt;项目配置完毕后，想要启动项目，则需要在Mapper映射路径下至少存在一个mapper.xml]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis二级缓存]]></title>
      <url>/java/mybatis/2017/11/12/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      <content type="text"><![CDATA[  MyBatis的二级缓存可以通过极少的配置项实现对数据库查询数据的缓存规则  映射文件中所有的 &lt;select/&gt; 语句都会被缓存  映射文件中所有的 &lt;insert/&gt; &lt;update/&gt; &lt;delete/&gt; 语句都会刷新缓存  基于以上两点，需要被缓存的数据库表的所有操作都应该放在同一个Mapper文件中在MyBatis的配置文件中添加以下配置  实际上即时不在配置文件中显式的声明该配置项，MyBatis的二级缓存也是默认开启的，因为该配置项的默认值就是true          &lt;setting name="cacheEnabled" value="true" /&gt;        在需要进行缓存的Mapper文件中添加以下配置          &lt;cache eviction="FIFO" flushInterval="60000" size="512" readOnly="true" /&gt;      可选配置  eviction 回收策略          LRU [default] 移除最长时间不被使用的对象      FIFO 按对象进入缓存的顺序进行移除      SOFT 移除基于垃圾回收器状态和软引用规则的对象      WEAK 更积极的移除基于垃圾回收器状态和弱引用规则的对象        flushInterval 刷新间隔，毫秒          没有默认值，表明没有刷新间隔，缓存只有在调用刷新语句时刷新        size 引用数目          1024 [default] 存储列表集合和对象的1024个引用        readOnly  只读          false [default] 可读写的缓存会返回缓存对象的拷贝，性能稍差，但安全性更高      true 只读的缓存会给所有调用者返回缓存对象的相同实例，所以该对象无法被修改，性能更高      可选属性  useCache 让单个 &lt;select/&gt; 语句自行选择是否被缓存  flushCache 让单个 &lt;select/&gt; 语句自行选择是否被刷新缓存]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
          <tag> cache </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Struts2 项目搭建]]></title>
      <url>/java/struts/2017/09/21/Struts2-%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      <content type="text"><![CDATA[  Struts2 作为一个应用开发框架，在项目中引入需要如下步骤创建一个 Web Project 并添加默认的 web.xml 文件  这个好像没啥好说的引入以下 jar 包到 lib 目录中  commons-fileupload-1.3.3.jar  commons-lang3-3.6.jar  freemarker-2.3.23.jar  javassist-3.20.0-GA.jar  log4j-api-2.8.2.jar  ognl-3.1.12.jar  struts2-core-2.5.12.jar在 web.xml 中添加 filter 配置&lt;filter&gt;	&lt;filter-name&gt;struts2&lt;/filter-name&gt;	&lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;	&lt;filter-name&gt;struts2&lt;/filter-name&gt;	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;在 src 目录下添加 struts.xml 文件  要让 Struts2 支持异步的 json 数据访问在 &lt;package&gt; 的 extend 属性中添加 json-default  添加 struts2-json-plugin-2.5.12.jar 包  在对应的 &lt;action&gt;  请求的 &lt;result&gt; 中添加 type="json" 属性，并删除页面内容&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC        "-//Apache Software Foundation//DTD Struts Configuration 2.5//EN"        "http://struts.apache.org/dtds/struts-2.5.dtd"&gt;&lt;struts&gt;	&lt;package name="default-package" extends="struts-default, json-default"&gt;		&lt;!-- name 表示请求路径 --&gt;		&lt;!-- class 表示请求路径对应的处理类 --&gt;		&lt;!-- method 表示处理类中对应的方法 --&gt;		&lt;action name="category" class="online.shixun.hpeu.action.GoodsCategoryAction" method="list"&gt;			&lt;result name="success"&gt;/WEB-INF/views/category.jsp&lt;/result&gt;		&lt;/action&gt;				&lt;!-- 异步获取商品描述 --&gt;		&lt;action name="description" class="online.shixun.hpeu.action.GoodsAction" method="description"&gt;			&lt;result name="success" type="json"&gt;&lt;/result&gt;		&lt;/action&gt;	&lt;/package&gt;&lt;/struts&gt;接收/显示数据  Struts2 的特点在于对数据的接收/显示进行封装  要获取页面传递到 action 的参数，只需要在 action 中定义对应名称的私有属性，并提供 setter 方法即可  要将数据显示到页面中，只需要在 action 中定义对应名称的私有属性，并提供 getter 方法即可public class GoodsAction {		private GoodsServiceImpl goodsService = new GoodsServiceImpl();		// 从页面接收商品类别id	private Long categoryId;		// 从页面接收商品id	private Long goodsId;		// 从DB获取商品列表，用于展示到页面上	private List&lt;GoodsModel&gt; goods;		// 从DB获取商品描述信息，用于展示到页面上	private String description;		/**	 * 加载商品列表页	 * @return	 */	public String list() {		goods = goodsService.getGoodsByCategoryId(categoryId);				return "success";	}		/**	 * 获取商品描述信息	 * @return	 */	public String description() {		// 通过商品id获取商品描述信息		description = goodsService.getGoodsById(goodsId).getDescription();				return "success";	}	public void setCategoryId(Long categoryId) {		this.categoryId = categoryId;	}	public void setGoodsId(Long goodsId) {		this.goodsId = goodsId;	}	public String getDescription() {		return description;	}	public List&lt;GoodsModel&gt; getGoods() {		return goods;	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> struts </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> struts </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate项目搭建]]></title>
      <url>/java/hibernate/2017/09/21/Hibernate%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      <content type="text"><![CDATA[  Hibernate 作为一个全自动的持久层[ORM]框架，在项目中引入需要以下步骤基础步骤  进入 Hibernate官网 下载 Hibernate 源码包  解压源码包后进入下图中的目录，将目录中的所有 jar 包复制到项目的 lib 目录中  在项目 src 目录下新建 hibernate.cfg.xml 文件          若实体类使用注解，则需要在最后加入对实体类的映射      若实体类使用配置文件，则需要在最后引入对应配置文件      &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN"  "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt;  &lt;!-- 数据库配置信息 --&gt;  &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;  &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///asl_dev&lt;/property&gt;  &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt;  &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt;  &lt;!-- Hibernate 方言 --&gt;  &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;  &lt;!-- 是否显示 sql --&gt;  &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt;  &lt;!-- 是否格式化 sql --&gt;  &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;    &lt;!-- 注解实体类映射 --&gt;  &lt;mapping class="online.shixun.hpeu.model.GoodsModel"/&gt;  &lt;!-- 配置实体类映射 --&gt;  &lt;mapping resource="com/qingshixun/model/User.hbm.xml"/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt;制作 Hibernate 工具类  通过该工具类可以便捷的重复调用 Session 对象  但如果涉及到 CUD 操作，则需要另外开启事务，并管理事务的提交或回滚public class HibernateUtil {    private static SessionFactory sessionFactory;    static {        Configuration configuration = new Configuration().configure();        StandardServiceRegistryBuilder ssrb = new StandardServiceRegistryBuilder();        StandardServiceRegistry serviceRegistry = ssrb.applySettings(configuration.getProperties()).build();        sessionFactory = configuration.buildSessionFactory(serviceRegistry);    }    public static Session getSession() {        return sessionFactory.openSession();    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring事务隔离级别]]></title>
      <url>/java/springmvc/springboot/2017/09/14/Spring%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      <content type="text"><![CDATA[  Spring 事务隔离级别是指 Spring 如何去处理每个事务之间的关联，可用于防止一些数据错误隔离级别  TransactionDefinition.ISOLATION_DEFAULT [默认值]          表示使用底层数据库的默认隔离级别，通常为 TransactionDefinition.ISOLATION_READ_COMMITTED      数据库的隔离级别参见 MySQL 数据库隔离级别        TransactionDefinition.ISOLATION_READ_UNCOMMITTED          表示一个事务可以读取到另一个事务修改但还未提交的数据      无法防止脏读、不可重复读、幻读      不推荐使用        TransactionDefinition.ISOLATION_READ_COMMITTED          表示一个事务只能读取到另一个事务已经提交的数据      可防止脏读      推荐使用        TransactionDefinition.ISOLATION_REPEATABLE_READ          表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同      可防止脏读、不可重复读        TransactionDefinition.ISOLATION_SERIALIZABLE          表示所有事务一次逐个执行，事务之间完全不可能产生干扰      可防止脏读、不可重复读、幻读      过于严密的隔离级别会严重影响系统性能      不推荐使用      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> springboot </tag>
        
          <tag> spring </tag>
        
          <tag> transaction </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring事务传播行为]]></title>
      <url>/java/springmvc/springboot/2017/09/14/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/</url>
      <content type="text"><![CDATA[  Spring 事务的传播行为是指当存在多个事务同时存在的时候，Spring 应该如何处理这些这些事务传播行为  TransactionDefinition.PROPAGATION_REQUIRED [默认值]          如果当前存在事务，则加入该事务      如果当前不存在事务，则创建一个新的事务        TransactionDefinition.PROPAGATION_REQUIRES_NEW          创建一个新的事务      如果当前存在事务，则将当前事务挂起        TransactionDefinition.PROPAGATION_SUPPORTS          如果当前存在事务，则加入该事务      如果当前没有事务，则以非事务的方式继续执行        TransactionDefinition.PROPAGATION_NOT_SUPPORTED          以非事务方式运行      如果当前存在事务，则将当前事务挂起        TransactionDefinition.PROPAGATION_NEVER          以非事务方式运行      如果当前存在事务，则抛出异常        TransactionDefinition.PROPAGATION_MANDATORY          如果当前存在事务，则加入该事务      如果当前没有事务，则抛出异常        TransactionDefinition.PROPAGATION_NESTED          如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行      如果当前没有事务，则根据 TransactionDefinition.PROPAGATION_REQUIRED 决定      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> springboot </tag>
        
          <tag> spring </tag>
        
          <tag> transaction </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL数据库隔离级别]]></title>
      <url>/database/mysql/2017/09/14/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      <content type="text"><![CDATA[  数据库隔离级别用于处理数据库中的数据读写规则定义  脏读          事务 A 对数据进行了增删改，但未提交事务，事务 B 可读取到该数据      如果事务 A 进行回滚，则事务 B 读取到的数据是脏数据        不可重复读          事务 A 中发生了两次读操作      在第一次读操作和第二次读操作之间，事务 B 对该数据进行了修改      导致事务 A 两次读取的数据是不一致的        幻读          事务 A 对一定范围内的数据进行了修改      事务 B 在这个范围内新增了一条数据      这时事务 A 对这些数据进行的修改会丢失      隔离级别  Read-Uncommitted - Level 0          导致脏读        Read-Committed - Level 1          避免脏读      允许不可重复读和幻读        Repeatable-Read - Level 2          避免脏读      避免不可重复读和幻读        Serializable - Level 3          串行化读，事务只能依次执行      避免脏读      避免不可重复读和幻读      执行效率慢，慎重使用      总结  隔离级别越高，越能保证数据安全，但对并发性能的影响越大  Oracle 、SqlServer 的默认隔离级别是 Read-Committed  MySQL 的默认隔离级别是 Repeatable-Read]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript 修改 input 验证提示]]></title>
      <url>/javascript/2017/08/21/Javascript-%E4%BF%AE%E6%94%B9-input-%E9%AA%8C%E8%AF%81%E6%8F%90%E7%A4%BA/</url>
      <content type="text"><![CDATA[  HTML5 为 form 中的 input 提供了一系列的验证提示，通过 Javascript 可以对验证提示的内容进行自定义定义一个 input 标签，并添加 required 属性&lt;input type="text" name="username" required&gt;定义一个方法，使用 setCustomValidity() 方法添加自定义的验证提示内容&lt;script type="text/javascript"&gt;function checkInput(input) {    if (input.value.length &lt; 20) {        input.setCustomValidity("输入内容不得少于20个字符");    } else {        input.setCustomValidity("");    }}&lt;/script&gt;在 input 标签中添加 invalid 属性，指定调用前续方法，并传入当前输入框&lt;input type="text" name="username" oninvalid="checkInput(this)" required&gt;]]></content>
      <categories>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> dom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript 为 String 提供分离字符的全局方法]]></title>
      <url>/javascript/2017/08/20/Javascript-%E4%B8%BA-String-%E6%8F%90%E4%BE%9B%E5%88%86%E7%A6%BB%E5%AD%97%E7%AC%A6%E7%9A%84%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95/</url>
      <content type="text"><![CDATA[  在一个字符串的每个字符之间插入空格，并且这个方法可以直接被字符串调用实现方式String.prototype.spacify = function(){    return this.split("").join(" ");};]]></content>
      <categories>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript数组排序]]></title>
      <url>/javascript/array/2017/06/08/Javascript%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
      <content type="text"><![CDATA[  Javascript 提供 sort() 函数用于排序但默认情况是使用字符串 Unicode 码点排序问题// 得到的结果是 [1, 10, 2, 5][1, 5, 2, 10].sort();解决[1, 5, 2, 10].sort((a, b) =&gt; a - b);]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> array </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> array </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread.wait()]]></title>
      <url>/java/multithreading/2017/05/05/Java-Thread.wait()/</url>
      <content type="text"><![CDATA[  wait() 和 notify() 必须在 synchronized 语句块中使用wait() 是强迫一个线程等待notify() 是通知一个线程继续运行功能  wait() 是针对已经获取对象锁的线程进行操作  当线程获取对象锁后，调用 wait() 主动释放对象锁，同时该线程休眠  直到其他线程调用 notify() 唤醒该线程，才继续获取对象锁，并执行  调用 notify() 唤醒线程并不是实时的，而是等相应的 synchronized 语句块执行结束，自动释放对象锁  再由 JVM 选取休眠的线程赋予对象锁，并执行，从而实现线程间同步、唤醒的操作对比  wait() 和 sleep() 都可以通过 interrupt() 打断线程的暂停状态，从而使线程立刻抛出 InterruptedException          通过 interrupt() 打断线程时，只需在 catch() 中捕获到异常即可安全结束线程      InterruptedException 是线程内部抛出，并不是 interrupt() 抛出      当线程执行普通代码时调用 interrupt() 并不会抛出异常，只有当线程进入 wait() / sleep() / join() 后才会立即抛出        wait() 和 sleep() 都可以暂定当前线程，其区别在于 wait() 在暂定的同时释放了对象锁  sleep() 是 Thread 的静态方法，wait() 是 Object 的一般方法实现public class WaitTest extends Thread {    private final Object self;    private final Object last;    public WaitTest(String name, Object self, Object last) {        super(name);        this.self = self;        this.last = last;    }    public void run() {        for (int i = 0; i &lt; 10; i++) {            // 锁住下一个对象            synchronized (last) {                // 锁住当前对象                synchronized (self) {                    if (super.getName().equals("A")) {                        System.out.println("第 " + (i + 1) + " 次运行！");                    }                    System.out.println(super.getName());                    // 等待一轮循环结束后唤醒当前线程                    self.notify();                }                try {                    // 释放下一个线程的对象锁                    last.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    public static void main(String[] args) {        Object a = new Object();        Object b = new Object();        Object c = new Object();        WaitTest waitA = new WaitTest("A", a, b);        WaitTest waitB = new WaitTest("B", b, c);        WaitTest waitC = new WaitTest("C", c, a);        waitA.start();        waitB.start();        waitC.start();    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC使用MultipartFile实现文件上传]]></title>
      <url>/java/springmvc/2017/04/26/SpringMVC%E4%BD%BF%E7%94%A8MultipartFile%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      <content type="text"><![CDATA[  SpringMVC 接收 MultipartFile 需要在 spring-mvc.xml 中配置文件解析器配置&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;    &lt;property name="maxUploadSize" value="20971520"/&gt;    &lt;property name="defaultEncoding" value="UTF-8"/&gt;&lt;/bean&gt;依赖&lt;dependency&gt;	&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;	&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;	&lt;groupId&gt;commons-io&lt;/groupId&gt;	&lt;artifactId&gt;commons-io&lt;/artifactId&gt;&lt;/dependency&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> fileupload </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread.yield()]]></title>
      <url>/java/multithreading/2017/04/21/Java-Thread.yield()/</url>
      <content type="text"><![CDATA[  yield() 是 Thread 提供的一个静态方法，可直接通过 Thread 调用yield() 是提醒线程暂停功能  暂停当前正在执行的线程对象，并执行其他线程特点  让当前运行线程回到可运行状态，从而让拥有相同优先级的线程获取运行机会  其目的是让拥有相同优先级的线程之前能适当的轮转运行  实际上 yeld() 的可行性无法得到保证，因为回到可运行状态的线程依旧有可能有限被调度程序选中  yeld() 不会导致线程回到等待/睡眠/阻塞状态，所以对线程执行该方法后可能没有效果对比  sleep() 放线程进行停滞状态，导致线程在指定时间内停止运行  yield() 只是让线程回到可运行状态，但重新获取运行权的可能还是这个线程  sleep() 允许优先级较低线程在当前线程停滞后获取运行权  yield() 不可能让比当前线程优先级低的线程获取运行权实现public YieldTest extends Thread {	public YieldTest (String name) {		super(name);	}	public void run() {		for (int i = 1; i &lt;= 5; i++) {			System.out.println(this.getName() + " 运行 " + i + " 次");			if (i == 3) {				this.yield();			}		}	}	public static void main(String[] args) {		YieldTest tom = new YieldTest("tom");		YieldTest jerry = new YieldTest("jerry");		tom.start();		jerry.start();	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread 调度]]></title>
      <url>/java/multithreading/2017/04/21/Java-Thread-%E8%B0%83%E5%BA%A6/</url>
      <content type="text"><![CDATA[  Thread 调整线程优先级，称为线程调度线程优先级越高，则会获得更多的运行机会级别  优先级的取值范围是 1-10 ，但只提供 3 个常量          Thread.MAX_PRIORITY - 最高优先级，取值 10      Thread.MIN_PRIORITY - 最低优先级，取值 1      Thread.NORM_PRIORITY - 默认优先级，取值 5        虽然 JVM 提供了 10 个优先级，但不推荐使用常量以外的其他优先级，因为其一致性不佳  线程的优先级拥有继承关系，子类默认和父类拥有相同优先级方法  setPriority() 设置优先级  getPriority() 获取优先级]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread join()]]></title>
      <url>/java/multithreading/2017/04/21/Java-Thread-join()/</url>
      <content type="text"><![CDATA[  join() 是 Thread 提供的一个方法，线程启动后可直接调用join() 是等待线程终止功能  线程调用 join() 后，主线程必须等待该线程终止后，主线程才能终止场景  当主线程调用子线程后，子线程需要大量的耗时运算  由于多线程的特性，往往导致主线程会在子线程之前结束  那么主线程结束之前就无法获取到子线程的运算结果  当子线程调用 join() 后，会强制主线程必须等待子线程终止后，主线程才能终止  从而主线程就可以获取到子线程的运算结果实现  主线程的结束语句一定会等两个子线程都结束后才会运行public JoinTest implements Runnable {	private String name;	public JoinTest(String name) {		this.name = name;	}	public void run() {		System.out.println(name = " 线程开始运行！");		for (int i = 1; i &lt;= 5; i++) {			System.out.println(name = " 线程运行 " + i + " 次！");			try {				Thread.sleep(500);			} catch (InterruptedException e) {				e.printStackTrace();			}		}				System.out.println(name = " 线程运行结束！");	}	public static void main(String[] args) {		System.out.println("主线程开始运行！\n");		JoinTest tom = new JoinTest("tom");		JoinTest jerry = new JoinTest("jerry");		Thread tomThread = new Thread(tom);		Thread jerryThread = new Thread(jerry);		tomThread.start();		jerryThread.start();		try {			tomThread.join();			jerryThread.join();		} catch (InterruptedException e) {			e.printStackTrace();		}		System.out.println("\n主线程运行结束！");	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread 状态转换]]></title>
      <url>/java/multithreading/2017/04/18/Java-Thread-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</url>
      <content type="text"><![CDATA[  下图对 Thread 的所有状态进行流程描述分解  初始 - 新创建一个线程对象  就绪- 对象的 start() 被调用          处于该状态的线程位于可运行线程池中，等待获取 CPU 使用权        运行 - 执行程序代码  阻塞 - 因为某种原因放弃 CPU 使用权，暂时停止运行          处于该状态的线程直到重新进入就绪状态，才有机会回到运行状态      该状态具体分为三种                  等待 - 该线程执行 wait() ，JVM 将该线程放入等待池中，并释放持有的锁          同步 - 该线程在获取对象同步锁时，发现该同步锁被占用，JVM 则将该线程放入锁池中          其他 - 该线程执行 sleep() 或 join() 或发出 I/O 请求，JVM 将该线程改为阻塞状态                      死亡 - 线程执行结束或因抛出异常导致退出 run()]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 继承 Thread 类]]></title>
      <url>/java/multithreading/2017/04/17/Java-%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB/</url>
      <content type="text"><![CDATA[  如果只是启动一个线程，则可通过继承 Thread 类来实现但一般推荐使用 Runnable - Java 实现 Runnable 接口Thread 类实际上也是实现了 Runnable 接口注意  程序运行时，Java 虚拟机启动一个进程，主线程在 main() 调用时被创建  在 main() 中调用 ThreadTest 的两个对象，则启动两个线程  start() 的调用不会立即执行多线程代码，而是促使该线程变为可运行态，具体运行时间由操作系统决定  多线程是乱序执行的，每次执行的结果都不确定  在多线程中调用 sleep() 的目的是不让当前线程占用全部系统资源  如果一个对象的 start() 被重复调用，则会抛出 java.lang.IllegalThreadStateException 异常实现public class ThreadTest extends Thread {	private String name;	public ThreadTest (String name) {		this.name = name;	}	public void run() {		for (int i = 1; i &lt;= 5; i++) {			System.out.println(name + " 运行 " + i + " 次");			try {					// 单位毫秒				sleep(1000);			} catch (InterruptedException e) {				e.printStackTrace();			}		}	}	public static void main(String[] args) {		ThreadTest tom = new ThreadTest("tom");		ThreadTest jerry = new ThreadTest("jerry");		tom.start();		jerry.start();	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 实现 Runnable 接口]]></title>
      <url>/java/multithreading/2017/04/17/Java-%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3/</url>
      <content type="text"><![CDATA[  与 Java 继承 Thread 类 一样，实现 Runnable 接口也是启动 Java 线程的一种方式通过继承 Thread 类实现多线程的对象，不适合资源共享，而实现 Runnable 接口，则适合资源共享不论是通过继承 Thread 类或者实现 Runnable 接口来实现多线程，最终都是通过 Thread 的 API 控制线程注意  run() 是多线程程序的一个约定，所有的多线程代码都在其中执行  在启动多线程时，首先需要通过 Thread(Runnable target) 构造出线程对象，再调用 start() 运行多线程  所有的多线程代码都是通过 Thread 的 start() 来运行优势 - Runnable 相较于 Thread  适合拥有多个相同程序代码的线程去处理同一资源  可以避免 Java 中的单继承限制  代码可以被多个线程共享  代码和数据实现独立  增加程序的健壮性  线程池只能放入实现 Runnable 或 Callable 的类，不能直接放入继承 Thread 的类实现public class RunnableTest implements Runnable {	private String name;	public RunnableTest(String name) {		this.name = name;	}	public void run() {		for (int i = 1; i &lt;= 5; i++) {			System.out.println(name + " 运行 " + i + " 次");			try {				Thread.sleep(1000);			} catch (InerruptedException e) {				e.printStackTrace();			}		}	}	public static void main(String[] args) {		RunnableTest tom = new RunnableTest("tom");		RunnableTest jerry = new RunnableTest("jerry");		new Thread(tom).start();		new Thread(jerry).start();	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 身份证号码验证]]></title>
      <url>/java/validate/2017/04/16/Java-%E8%BA%AB%E4%BB%BD%E8%AF%81%E5%8F%B7%E7%A0%81%E9%AA%8C%E8%AF%81/</url>
      <content type="text"><![CDATA[  对身份证号码前 17 位通过一段算法规则进行计算，可得出身份证号码最后 1 位的值所以身份证号码最后一位实际上是身份证号码校验码结构  地址码 - 6 位          表示编码对象常住户口所在市区县的行政区域划分代码      按 GB/T2260 规定执行        出生日期码 - 8 位          表示编码对象出生的年月日      按 GB/T7408 规定执行        顺序码 - 3 位          表示在他同一地址码所标识的区域范围内，对同年同月同日出生的人编订的顺序码      顺序码奇数为男生，偶数为女生        校验码 - 1 位          前 17 位数字本体码加权求和                  S = Sum(Ai * Wi)          Ai : 表示 0 - 17 位身份证号码的数值 0 - 9          Wi : 表示 0 - 17 位身份证号码的加权因子 7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2                    根据求和结果计算模                  Y = mod(S, 11)                    根据模查找对应校验码                  Y            0 1 2 3 4 5 6 7 8 9 10          校验码  1 0 X 9 8 7 6 5 4 3 2                    实现  通过计算获取第 18 位的校验码// 十七位数字本体码权重int[] weight = {7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2};// mod 对应校验码字符值char[] validate = {'1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'};public char getValidateCode(String id17) {    int sum = 0;    int mode = 0;    for (int i = 0; i &lt; id17.length(); i++) {        sum = sum + Integer.parseInt(String.valueOf(id17.charAt(i))) * weight[i];    }    mode = sum % 11;    return validate[mode];}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> validate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> validate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 代理之静态代理]]></title>
      <url>/java/proxy/2017/04/13/Java-%E4%BB%A3%E7%90%86%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="text"><![CDATA[  静态代理是指在程序运行前代理关系就已经存在其代理类和委托类会实现同一接口或是来自相同的父类定义共同接口public class Sell {	void sell();	void ad();}定义委托类public class Vendor implements Sell {	public void sell() {		System.out.println("In sell method");	}	public void ad() {		System.out.println("In ad method");	}}定义代理类  通过代理，可是实现对委托类被代理方法的修改，但不影响被代理方法的原始逻辑public class BusinessAgent implements Sell {	private Vendor vendor;	public BusinessAgent(Vendor vendor) {		this.vendor = vendor;	}	public void sell() {		System.out.println("-- before --");		vendor.sell();		System.out.println("-- after --");	}	public void add() {		System.out.println("-- before --");		vendor.ad();		System.out.println("-- after --");	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> proxy </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> proxy </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 代理之动态代理]]></title>
      <url>/java/proxy/2017/04/13/Java-%E4%BB%A3%E7%90%86%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      <content type="text"><![CDATA[  通过使用代理可以隐藏委托类的实现，并且实现客户与委托类之间的解耦，在不修改委托类的前提下为客户做一些额外处理类型  静态代理 - Java 代理之静态代理          虽然具备代理的两个优点      但局限在于运行前必须编写好代理类        动态代理          代理类在程序运行时才被创建      其优势在于可以对多个代理类进行统一处理，而不用修改每个代理类的实现      定义 InvocationHandler 接口，充当调用处理器  java.lang.reflect.InvocationHandler 是 Java 自带的调用处理器  为处于代理类和委托类之间的中间类提供实现接口  代理类作为参数 proxy 传入  参数 method 标识具体调用代理类的哪个方法  参数 args 是这个代理类方法的参数public interface InvocationHandler {	Object invoke(Object proxy, Method method, Object[] args);}定义委托类，使用动态代理，委托类必须实现某个接口public class Sell {	void sell();	void ad();}public class Vendor implements Sell {	public void sell() {		System.out.println("In sell method");	}	public void ad() {		System.out.println("In ad method");	}}定义中介类，其必须实现 InvocationHandler 接口  该类持有一个委托类的引用  中介类和委托类构成静态代理，中介类充当代理类，委托类依旧是委托类  中介类和代理类构成静态代理，中介类充当委托类，代理类依旧是代理类  所以实际上动态代理是由两组静态代理组成public class DynamicProxy implements InvocationHandler {	private Object object;	public DynamicProxy(Object object) {		this.object = object;	}	public void invoke(Object proxy, Mehtod method, Object[] args) {		System.out.println("-- before --");		Object result = method.invoke(object, args);		System.out.println("-- after --");		return result;	}}动态生成代理类  通过调用 Proxy.newProxyInstance() 获取代理类实例，其实现指定接口并将方法滴啊用分发到指定的调用处理器  该方法的声明 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)  参数 loader 是定义了代理类的 ClassLoader  参数 interfaces 是代理类实现的接口列表  参数 h 是调动处理器public class MainTest {	public static void main(String[] args) {		DynamicProxy dynamicProxy = new DynamicProxy(new Vendor());		Sell sell = (Sell) Proxy.newProxyInstance(Sell.class.getClassLoader(), new Class[]{Sell.class}, dynamicProxy);		sell.sell();		sell.ad();	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> proxy </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> proxy </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CORS 处理跨域请求]]></title>
      <url>/javascript/crossdomain/2017/04/12/CORS-%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
      <content type="text"><![CDATA[  CORS 是一个 W3C 标准，全称跨域资源共享 (Cross-orign resource sharing)其允许浏览器向跨域服务器发起异步请求，从而客服 ajax 受同源策略的限制使用  http-equiv 相当于 http 的响应头，其回应给浏览器一些有用的信息，用来帮助正确和精确的显示网页内容  以下规则表示允许任意域名下的网页跨域访问&lt;meta http-equiv="Access-Control-Allow-Origin" content="*"&gt;规则[1-8 为服务器提供，9-10 为浏览器 OPTIONS 请求默认自带]  Access-Control-Allow-Origin          指定允许哪些源的网页发送请求        Access-Control-Allow-Credentials          指定是否允许发送 cookie        Access-Control-Allow-Methods          指定允许哪些请求方法        Access-Control-Allow-Headers          指定允许哪些常规的头域字段，比如 Content-Type      常规头域字段有 Cache-Control 、Content-Language 、Content-Type 、Expires 、Last-Modified 、Pragma        Access-Control-Expose-Headers          指定允许哪些额外的头域字段，比如 X-Custom-Header      该字段只有需要获取基本字段以外的其他字段时，才需要使用        Access-Control-Max-Age          指定 preflight OPTIONS 请求的有效期，单位秒        Access-Control-Request-Method          告知服务器，浏览器将发送哪种请求，例如 POST        Access-Control-Request-Headers          告知服务器，浏览器将包含哪些额外的头域字段      类型  简单请求，满足以下两个条件          请求时如下三种之一                  HEAD          GET          POST                    http 头域不超过一下几种字段                  Accept          Accept-Language          Content-Language          Last-Event-ID          Content-Type 且内容限定为 application/x-www-form-urlencodedplain  multipart/form-data  text/plain                      非简单请求          不满足简单请求的两个条件，即为非简单请求      ]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> crossdomain </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> crossdomain </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OpenOffice 在 Linux 下安装使用]]></title>
      <url>/java/openoffice/linux/2017/04/11/OpenOffice-%E5%9C%A8-Linux-%E4%B8%8B%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      <content type="text"><![CDATA[  OpenOffice在linux下如何安装及使用官网OpenOffice安装  根据实际的 Linux 版本决定下载类型  在 tar 包所在目录，输入 tar -xzvf Apache_OpenOffice_4.1.3_Linux_x86-64_langpack-rpm_zh-CN.tar.gz 解压下载的 tar 包  接下来出来的文件在同目录下的 zn-CH  中，里面包含三个目录 RPMS readmes licenses  进入到 RPMS 中，执行 rpm -ivh *rpm 安装该目录下所有的 rpm 文件使用  进入默认安装目录 /opt/openoffice4/program 中  执行 /opt/openoffice4/program/soffice "-accept=socket,host=127.0.0.1,port=8100;urp;" -headless -nofirststartwizard &amp;  在命令的最后输入 &amp; 可确保服务在后端运行注意  若执行启动命令时报错 /opt/openoffice4/program/soffice.bin: error while loading shared libraries: libXext.so.6: cannot open shared object file: No such file or directory ，则需要安装 libXext 依赖包，根据 Linux 版本选择安装类型          执行 yum install libXext.x86_64      在 /usr/lib64 或 /usr/lib 中找到 libXext.so.6 文件，复制到 /opt/openoffice4/program/ 目录中      对复制过来的文件执行 chmod 777 libXext.so.6      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> openoffice </category>
        
          <category> linux </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> openoffice </tag>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java使用OpenOffice在线预览Office及PDF]]></title>
      <url>/java/openoffice/2017/04/11/Java%E4%BD%BF%E7%94%A8OpenOffice%E5%9C%A8%E7%BA%BF%E9%A2%84%E8%A7%88-Office-%E5%8F%8A-PDF/</url>
      <content type="text"><![CDATA[  使用OpenOffice可实现在线预览office文件内容思路  用 OpenOffice 将 word / excel / ppt 转换为 pdf  用 pdf.js 将转换后的 pdf 显示在浏览器中显示准备  安装 OpenOffice ，参见 OpenOffice 在 Linux 下安装使用  启动 OpenOffice ，soffice "-accept=socket,host=localhost,port=8100;urp;" -headless -nofirststartwizard &amp;          Mac端需要跳转到 Applications/OpenOffice.app/Contents/program 才可启动服务        下载 JODConverter ，在其 lib 目录中找到 jodconverter-cli-2.2.2.jar ，并引入以下 jar 包  下载 PDF.js ，并引入到项目中          vue项目使用vue.js pdf viewer      在项目 pom.xml 中引入以下包&lt;dependency&gt;    &lt;groupId&gt;org.openoffice&lt;/groupId&gt;    &lt;artifactId&gt;juh&lt;/artifactId&gt;    &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openoffice&lt;/groupId&gt;    &lt;artifactId&gt;jurt&lt;/artifactId&gt;    &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openoffice&lt;/groupId&gt;    &lt;artifactId&gt;ridl&lt;/artifactId&gt;    &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openoffice&lt;/groupId&gt;    &lt;artifactId&gt;unoil&lt;/artifactId&gt;    &lt;version&gt;4.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.openoffice&lt;/groupId&gt;    &lt;artifactId&gt;jodconverter&lt;/artifactId&gt;    &lt;version&gt;2.2.2&lt;/version&gt;    &lt;scope&gt;system&lt;/scope&gt;    &lt;systemPath&gt;${basedir}/../lib/jodconverter-2.2.2.jar&lt;/systemPath&gt;&lt;/dependency&gt;调用服务并转换文件  通过 OpenOfficeConnection 调用 OpenOffice 服务，并将传入文件转换为 PDF 格式public static File fileToPdf(File file) {    // 文件全路径名    String fileName = file.getPath();    // 存放转换结果的 pdf 文件    File pdfFile = new File(fileName.substring(0, fileName.lastIndexOf(".")) + Constants.REPORT_FILE_PREVIEW_SUFFIX);    // 非空验证    if (!file.exists() || !file.isFile()) {        return null;    }    // 存在则不再转换    if (pdfFile.exists() &amp;&amp; pdfFile.isFile()) {        return pdfFile;    }    // 获取连接    OpenOfficeConnection connection = new SocketOpenOfficeConnection(Constants.OPEN_OFFICE_CONNECTION_PORT);    try {        // 建立连接        connection.connect();        // 开始转换        DocumentConverter converter = new OpenOfficeDocumentConverter(connection);        converter.convert(file, pdfFile);        // 关闭连接        connection.disconnect();    } catch (ConnectException e) {        logger.error("PDF 转换失败，OpenOffice 服务未启动！", e);        throw new TSharkException("PDF 转换失败，OpenOffice 服务未启动！", e);    }    return pdfFile;}在页面准备显示内容的区域  页面上通过 iframe 引入 pdf.js 中的 viewer.html  并传入待显示的 pdf 文件&lt;iframe src="${ctx}/assets/plugins/pdf/web/viewer.html?file=&lt;c:url value="/api/report/intro/preview/file/${fileNamePrefix}/${fileNameSuffix}"/&gt;" width="100%" height="100%" frameborder="0" scrolling="hidden"&gt;&lt;/iframe&gt;后端返回待显示的文件流  后端将待显示的 pdf 文件通过 ResponseEntity 传入到前端public ResponseEntity&lt;byte[]&gt; preview(String fileName) throws IOException {    // 获取文件    File file = new File(Constants.REPORT_SOURCE_FILE_PATH + fileName);    // 转换并返回结果    byte[] pdfFileBytes = FileUtils.readFileToByteArray(OnlinePreviewUtil.fileToPdf(file));    HttpHeaders httpHeaders = new HttpHeaders();    httpHeaders.setContentType(MediaType.valueOf("application/pdf"));    httpHeaders.setContentLength(pdfFileBytes.length);    httpHeaders.add(HttpHeaders.ACCEPT_RANGES, "bytes");    return new ResponseEntity&lt;byte[]&gt;(pdfFileBytes, httpHeaders, HttpStatus.OK);}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> openoffice </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> openoffice </tag>
        
          <tag> pdf </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring的@Transactional详解]]></title>
      <url>/java/springboot/springmvc/2017/04/05/Spring%E7%9A%84@Transactional%E8%AF%A6%E8%A7%A3/</url>
      <content type="text"><![CDATA[  Spring 提供的事务管理机制为不同的事务 API 提供一致的编程模型管理方式  编程式事务          TransactionTemplate [推荐]      PlatformTransactionManager [基于底层]        声明式事务 [推荐]          基于 &lt;tx/&gt; 和 &lt;aop/&gt; 的 xml 配置文件      使用 @Transactional 注解 [推荐]      配置方式  使用 @Transactional 注解的声明式配置参见 SpringMVC声明式事务配置注意点  默认情况下，数据库处于紫铜提交模式，每个语句处于单独的事务中  对于正常的事务管理，应当是一组相关操作处于同一个事务中  Spring 默认将底层连接的自动提交设置为 false  有些数据连接池提供自动提交的开关设置，但 c3p0 未提供  JDBC 规范明文指出当连接对象建立时应该处理自动提交模式，对于自动提交的开关应该进行显示处理  当一个连接关闭时，未提交的事务应该回滚，虽然 JDBC 规范未明确指出，但 c3p0 默认将 autoCommitOnClose 设置为 false  MyBatis 会自动参与到 Spring 的事务管理中，只要二者引用的数据源一致@Transactional 属性  value - String          限定描述符，用于指定使用的事务管理器        isolation - enum          事务隔离级别，参见 Spring 事务隔离级别        propagation - enum          事务传播行为，参见 Spring 事务传播行为        readOnly - boolean          事务只读属性，默认读写      false = 读写，true = 只读      只读属性用于特殊情景优化，例如在使用 Hibernate 时，默认使用读写事务        timeout - int          事务超时时间，单位秒      如果超过该时间事务还没完成，则自动回滚事务      默认设置为底层事务系统的超时值，如果底层未设置，则为 none        rollbackFor - Class 对象数组，必须继承自 Throwable          导致事务回滚的异常类数组        rollbackForClassName - 类名数组，必须继承自 Throwable          导致事务回滚的异常类名称数组        noRollbackFor - Class 对象数组，必须继承自 Throwable          不会导致事务回滚的异常类数组        noRollbackForClassName - 类名数组，必须继承自 Throwable          不会导致事务回滚的异常类名称数组      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> springmvc </tag>
        
          <tag> spring </tag>
        
          <tag> transaction </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Maven POM 解析]]></title>
      <url>/java/maven/2017/04/05/Maven-POM-%E8%A7%A3%E6%9E%90/</url>
      <content type="text"><![CDATA[  描述Maven的pom文件中各项配置作用基础结构&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;    &lt;!-- maven 版本号，是固定值 --&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;!-- 项目包名 --&gt;    &lt;groupId&gt;org.seckill&lt;/groupId&gt;    &lt;!-- 项目名 + 模块名 --&gt;    &lt;artifactId&gt;seckill&lt;/artifactId&gt;    &lt;!-- 打包类型，默认 jar --&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;!-- 版本号 0.0.0 大版本号.分支版本号.小版本号 --&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;!-- 项目描述名 --&gt;    &lt;name&gt;seckill Maven Webapp&lt;/name&gt;    &lt;!-- 项目地址 --&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;!-- 项目描述 --&gt;    &lt;description&gt;product second kill system&lt;/description&gt;    &lt;!-- 开发者信息 --&gt;    &lt;developers&gt;        &lt;developer&gt;            &lt;name&gt;ThkcDo&lt;/name&gt;        &lt;/developer&gt;    &lt;/developers&gt;    &lt;!-- 许可证信息 --&gt;    &lt;licenses&gt;        &lt;license&gt;            &lt;name&gt;xxx&lt;/name&gt;        &lt;/license&gt;    &lt;/licenses&gt;    &lt;!-- 组织信息 --&gt;    &lt;organization&gt;        &lt;name&gt;ThkcDo&lt;/name&gt;    &lt;/organization&gt;    &lt;!-- 依赖类库列表 --&gt;    &lt;dependencies&gt;        &lt;!-- 测试相关依赖，使用 junit4 ，因为 junit4 是基于注解的 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;!-- 依赖范围，compile 默认类型，表示编译测试运行都有效 --&gt;            &lt;!-- test 表示只在测试时使用 --&gt;            &lt;!-- provided 表示在编译和测试时有效 --&gt;            &lt;!-- runtime 表示在测试和运行时有效 --&gt;            &lt;!-- system 表示在编译和测试时有效，但需要和本机系统关联，也就是依赖包的路径来自于本机，可移植性差 --&gt;            &lt;!-- import 表示从其他 pom 中导入依赖 --&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;!-- 设置依赖是否可选，默认 false --&gt;            &lt;optional&gt;false&lt;/optional&gt;            &lt;!-- 排除依赖传递列表 --&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;                    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;!-- 依赖管理，用于父模块声明公共依赖供子模块调用 --&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;                &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;	  &lt;!-- 构建信息 --&gt;    &lt;build&gt;        &lt;finalName&gt;seckill&lt;/finalName&gt;        &lt;!-- 插件列表 --&gt;        &lt;plugins&gt;            &lt;!-- 具体插件 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;                &lt;version&gt;2.4&lt;/version&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> maven </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> maven </tag>
        
          <tag> pom </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript 获取 XMLHttpRequest 对象]]></title>
      <url>/javascript/ajax/2017/04/05/Javascript-%E8%8E%B7%E5%8F%96-XMLHttpRequest-%E5%AF%B9%E8%B1%A1/</url>
      <content type="text"><![CDATA[  浏览器通过 XMLHttpRequest 对象实现 Ajax 功能 而 IE6 以下版本只支持通过 ActiveXObject 对象实现 Ajax 功能以下提供一个全平台兼容获取 Ajax 支持对象的方法实现方式function getXHR(){  var xhr = null;	// 浏览器支持 XMLHttpRequest  if(window.XMLHttpRequest) {		xhr = new XMLHttpRequest();  } else if (window.ActiveXObject) {		// IE6 以下浏览器只支持 AactiveXObject    	try {			// 获取 MSXML3 标准      	xhr = new ActiveXObject("Msxml2.XMLHTTP");	    } catch (e) {  		    try {				// 备选方案，功能不完善，不推荐使用      		xhr = new ActiveXObject("Microsoft.XMLHTTP");		    } catch (e) {         		alert("您的浏览器暂不支持Ajax!");      	}    	}  }  return xhr;}]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> ajax </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> ajax </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Protostuff 自定义序列化]]></title>
      <url>/java/2017/04/04/Java-Protostuff-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      <content type="text"><![CDATA[  虽然 Java 提供内置的序列化 API Serializable ，但其效率并不是最高的Google 提供了一个效率很高的序列化 API Protobuf ，但其使用过于复杂开源社区在 Protobuf 的基础上封装出 Protostuff ，在不丢失效率的前提上，让使用步骤变得更简单一般情况下 Protostuff 序列化后的数据大小是 Serializable 的 1/10 之一，速度更是两个量级以上依赖&lt;dependency&gt;	&lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;	&lt;artifactId&gt;protostuff-core&lt;/artifactId&gt;	&lt;version&gt;1.1.1&lt;/version&gt;	&lt;/dependency&gt;&lt;dependency&gt;	&lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt;	&lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt;	&lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;创建 Schema 序列化规则对象  规则对象只接受任何带 set/get 方法的 POJO 对象private RuntimeSchema&lt;RecordDTO&gt; schema = RuntimeSchema.createFrom(RecordDTO.class);数据序列化public void setRecord(RecordDTO record) {	// 将未序列化的对象数据通过 schema 规则进行序列化	// LinkedBuffer 缓存器的作用是当对象数据过大时，可以对数据进行缓存，从而实现分布序列化	byte[] bytes = ProtobufIOUtil.toByteArray(record, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));}数据反序列化public RecordDTO getRecord(byte[] bytes) {	// 空的对象数据	RecordDTO record = schema.newMessage();	// 将被序列化的对象数据通过 schema 规则反序列化转换到空的对象数据中	ProtobufIOUtil.mergeFrom(bytes, record, schema);	return record;}]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> serializable </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis批量新增]]></title>
      <url>/java/mybatis/2017/03/31/MyBatis%E6%89%B9%E9%87%8F%E6%96%B0%E5%A2%9E/</url>
      <content type="text"><![CDATA[  通过循环 values 语句实现批量新增数据&lt;insert id="saveTimetables"&gt; INSERT INTO pt_timetable (  id,  lessonNo ) VALUES  &lt;foreach collection="list" item="item" separator=","&gt;   (    #{item.id},              #{item.lessonNo}          )  &lt;/foreach&gt;&lt;/insert&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Apache POI 操作 Excel 导入]]></title>
      <url>/java/poi/2017/03/31/Java-Apache-POI-%E6%93%8D%E4%BD%9C-Excel-%E5%AF%BC%E5%85%A5/</url>
      <content type="text"><![CDATA[  Java 可以通过 Apache POI 操作 Excel 的导入导出Apache POI 是一套操作 Microsoft Office 套件的开源 Java API官网Apache POI依赖  要使用 Apache POI 的功能需要引入以下两个 jar 包          操作 Excel 2003 (.xls) 及之前的版本，只用导入 poi 即可      操作 Excel 2007 (.xlsx) 及以后的版本，则还需要导入 poi-ooxml 才可      &lt;dependency&gt;	&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;	&lt;artifactId&gt;poi&lt;/artifactId&gt;	&lt;version&gt;3.10.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;	&lt;groupId&gt;org.apache.poi&lt;/groupId&gt;	&lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;	&lt;version&gt;3.10.1&lt;/version&gt;&lt;/dependency&gt;判断文件版本  通过上传的文件类型，判断 Excel 的版本，根据具体版本返回解析类          上传 Excel 文件的方式和普通的文件上传没有差异      对于 springMVC 则可以使用 MultipartFile 进行文件获取      private static Workbook getWorkbook(MultipartFile excelFile) throws IOException {    // 获取文件输入流    InputStream inputStream = excelFile.getInputStream();    // 获取文件内容    String fileName = excelFile.getOriginalFilename();    // 获取文件类型    String fileType = fileName.substring(fileName.indexOf("."));    // 判断文件类型    if (("xls").equalsIgnoreCase(fileType)) {        return new HSSFWorkbook(inputStream);    } else if (("xlsx").equalsIgnoreCase(fileType)) {        return new XSSFWorkbook(inputStream);    } else {        logger.error("Excel 文件解析失败，格式错误！");        throw new TSharkException("Excel 文件解析失败，格式错误！");    }}获取到 Excel 文件解析类后则对文件进行解压  解压的方式是依次遍历 Excel 内容：sheet-row-column  遍历时需要考虑到每个阶段非空的情况  遍历 row 的时候需要考虑过滤表头的情况，一般表头可能是表格信息（具体情况需要根据模版决定）public static List&lt;List&lt;Object&gt;&gt; getExcelContent(MultipartFile excelFile) {    // 行列表    List&lt;List&lt;Object&gt;&gt; contents = Lists.newArrayList();    Workbook workbook;    try {        // 解析 Excel 获取 Workbook        workbook = getWorkbook(excelFile);    } catch (IOException e) {        logger.error("获取 Excel 内容失败！", e);        throw new TSharkException("获取 Excel 内容失败！", e);    }    // 遍历所有表    for (int i = 0; i &lt; workbook.getNumberOfSheets(); i++) {        // 获取当前表        Sheet sheet = workbook.getSheetAt(i);        // 非空验证        if (null == sheet) {            continue;        }        // 遍历当前表中所有行,过滤掉标题行        for (int j = sheet.getFirstRowNum() + 1; j &lt;= sheet.getLastRowNum(); j++) {            // 获取当前行            Row row = sheet.getRow(j);            // 非空验证            if (null == row) {                continue;            }            // 单元格列表            List&lt;Object&gt; cells = Lists.newArrayList();            // 遍历当前行中所有单元格            for (int k = row.getFirstCellNum(); k &lt;= row.getLastCellNum(); k++) {                // 获取当前单元格                Cell cell = row.getCell(k);                // 非空验证                if (null == cell) {                    continue;                }                // 获取单元格格式化后的内容                cells.add(formatCellValue(cell));            }            // 获取所有行的单元格列表            contents.add(cells);        }    }    return contents;}遍历文件内容  遍历内容到最后是获取单元格内容，而单元格的内容获取需要进行一定的格式化处理private static Object formatCellValue(Cell cell) {    Object cellValue = null;    switch (cell.getCellType()) {        case Cell.CELL_TYPE_STRING:            cellValue = cell.getRichStringCellValue().toString();            break;        case Cell.CELL_TYPE_NUMERIC:            // 获取具体类型            String dataFormat = cell.getCellStyle().getDataFormatString();            // 具体类型判断            if (("General").equalsIgnoreCase(dataFormat)) {                cellValue = new DecimalFormat("0").format(cell.getNumericCellValue());            } else if (("m/d/yy").equalsIgnoreCase(dataFormat)) {                cellValue = DateUtil.dateToString(cell.getDateCellValue());            } else {                cellValue = new DecimalFormat("0.00").format(cell.getNumericCellValue());            }            break;        case Cell.CELL_TYPE_BOOLEAN:            cellValue = cell.getBooleanCellValue();            break;        case Cell.CELL_TYPE_BLANK:            cellValue = "";            break;        default:            break;    }    return cellValue;}处理过滤得到的数据  将 Excel 中的内容遍历到 List 列表中后，则需要对列表中的有效内容进行读取          读取的具体内容索引根据模版实际情况决定      在读取内容的同时则可以对数据进行持久化操作      private List&lt;UniversityMemberDTO&gt; generateUniversityMembers(List&lt;List&lt;Object&gt;&gt; contents) {    List&lt;UniversityMemberDTO&gt; universityMembers = Lists.newArrayList();    // 遍历内容列表    for (List&lt;Object&gt; content : contents) {        UniversityMemberDTO universityMember = new UniversityMemberDTO();        // 登录名        universityMember.setLoginName((String) content.get(0));        // 真实姓名        universityMember.setRealName((String) content.get(1));        // 联系方式        universityMember.setMobile((String) content.get(2));        // 邮箱        universityMember.setEmail((String) content.get(3));        // 专业名称        universityMember.setMajorName((String) content.get(4));        // 学院名称        universityMember.setInstituteName((String) content.get(5));        // 用户类型        universityMember.setType(getUniversityMemberType((String) content.get(6)));        universityMembers.add(universityMember);    }    return universityMembers;}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> poi </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> poi </tag>
        
          <tag> excel </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC的CacheManager配置]]></title>
      <url>/java/springmvc/2017/03/27/SpringMVC%E7%9A%84CacheManager%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  Spring 3.1 后提供一个新特性 基于注释驱动的缓存可以通过在方法上加入注解，从而缓存该方法返回的数据编写配置文件&lt;!-- 使用缺省名称为 cacheManager 的缓存管理器，其缺省实现为 org.springframework.cache.support.SimpleCacheManager --&gt;&lt;cache:annotation-driven/&gt;&lt;!-- 配置 cacheManager --&gt;&lt;bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager"&gt;&lt;!-- 配置缓存集合 --&gt;&lt;property name="caches"&gt;&lt;set&gt;&lt;!-- 缺省方案 --&gt;&lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="default"/&gt;&lt;!-- 自定义方案 --&gt;&lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="dictionaryCache"/&gt;&lt;/set&gt;&lt;/property&gt;&lt;/bean&gt;在需要缓存的方法上加缓存注释，并指定自定义名称@Cacheable(value = "dictionaryCache")public List&lt;DictionaryDTO&gt; getDictionaries(String className) {return dictionaryDao.getDictionaries(className);}清空缓存  allEntries = true 表示清空所有缓存  key = "#dictionary.getName()" 表示只清空方法参数中带有指定key的缓存@CacheEvict(value = "departmentService", allEntries = true)public ResponseData removeDictionary(Long id) {...}@CacheEvict(value = "departmentService", key = "#dictionary.getName()")public void addDictionary(DictionaryDTO dictionary) {...}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> cache </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC声明式事务配置]]></title>
      <url>/java/springmvc/2017/03/25/SpringMVC%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  Spring 的事务管理机制用处在于保证数据统一性在事务执行过程中如果出现报错，Spring 的事务管理机制会回滚事务，保证数据库的数据不会出现只更改一部分的情况但触发事务回滚的报错必须是 RuntimeExpection，只有这种异常可以被 Spring 事务捕获到如果随意使用 try-catch 对报错进行包裹，会导致报错在方法体内被处理报错信息不再向上抛出，即 Spring 捕获不到关键的 RuntimeExpection根据持久层类型选择正确的事务管理器进行配置  MyBatis 采用的是 JDBC 的事务管理器  Hibernate 采用的是 Hibernate 自己的事务管理器  dataSource 是数据源&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;配置声明式事务  默认使用注解管理事务行为，注解也是管理实务的最佳行为&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;通过 @Transactional 指定需要事务管理的方法体  事务注解最好是打到具体的方法体上，如果打到类名上则意味着整个类都需要进行事务控制，多余的事务控制会影响事务的执行时间  方法体中存在增删改操作才需要事务控制  只读操作不需要事务控制@Transactionalpublic void executeSkill() { ... }]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> transaction </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis集成到Spring之生成Session工厂]]></title>
      <url>/java/springmvc/mybatis/2017/03/24/MyBatis%E9%9B%86%E6%88%90%E5%88%B0Spring%E4%B9%8B%E7%94%9F%E6%88%90Session%E5%B7%A5%E5%8E%82/</url>
      <content type="text"><![CDATA[  虽然 Spring 自身没有对 MyBatis 提供支持但 MyBatis 主动对 Spring 进行了整合依赖依赖&lt;dependency&gt;&lt;groupId&gt;org.mybatis&lt;/groupId&gt;&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;&lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;配置  在 Spring 中集成 MyBatis 需要使用 SqlSessionFactoryBean 来生成 MyBatis 所需的 Session 工厂&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;...&lt;/bean&gt;  SqlSessionFactoryBean 实际上并不是真正的 Session 工厂，其经历了如下转换SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();SqlSessionFactory sessionFactory = factoryBean.getObject();属性  指定数据源          该数据源通常引用的是一个数据库连接池的配置项别名      &lt;property name="dataSource" ref="dataSource" /&gt;        MyBatis 全局配置文件          mybatis-config.xml 中的内容是 MyBatis settings 配置表      &lt;property name="configLocation" value="classpath:mybatis-config.xml" /&gt;        自动扫描 Mapper 文件          &lt;property name="mapperLocations" value="classpath:mapper/*Mapper.xml" /&gt;      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis集成到Spring之注入Dao接口]]></title>
      <url>/java/springmvc/mybatis/2017/03/24/MyBatis%E9%9B%86%E6%88%90%E5%88%B0Spring%E4%B9%8B%E6%B3%A8%E5%85%A5Dao%E6%8E%A5%E5%8F%A3/</url>
      <content type="text"><![CDATA[  MyBatis 的 MapperScannerConfigurer 可以将 Dao 接口和 Mapper 文件注入到 Spring 容器中配置&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;...&lt;/bean&gt;属性  指定 Session 工厂          通常情况下系统只会存在一个 DataSource ，这时 MapperScannerConfigurer 会自动装配 Session 工厂，无需手动指定      必须使用 value 注入 Bean 的名称，而不是使用 ref 对 Bean 进行引用      sqlSessionFactory 的实例在 MyBatis 集成到 Spring 之生成 Session 工厂      &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;        指定 Dao 接口的扫描路径          同时指定多个路径只需要通过逗号分隔即可      &lt;property name="basePackage" value="org.seckill.module" /&gt;      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Maven 项目管理器]]></title>
      <url>/java/maven/2017/03/23/Maven-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      <content type="text"><![CDATA[  maven的基础介绍和命令官网Apache Maven介绍  基于对象模型（POM），通过一段描述信息对项目的构建、报告和文档进行管理的软件项目管理工具安装  在终端中运行 brew install maven 即可一键安装结构  bin      存放运行脚本  boot   包含一个类加载器框架  conf    存放配置文件  lib        存放依赖类库命令  查看版本号 mvn -v  编译项目 mvn complie  测试项目 mvn test  打包项目 mvn package  删除项目 target 目录 mvn clean  安装项目 jar 包到本地目录 mvn install  创建项目，按提示输入项目信息 mvn archetype:generate  创建项目，直接指定项目信息 mvn archtype:generate -DgroupId=org.secskill -DartifactId=secskill -Dversion=1.0]]></content>
      <categories>
        
          <category> java </category>
        
          <category> maven </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> maven </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis的settings配置表]]></title>
      <url>/java/mybatis/2017/03/22/MyBatis%E7%9A%84settings%E9%85%8D%E7%BD%AE%E8%A1%A8/</url>
      <content type="text"><![CDATA[  &lt;settings/&gt; 标签是 MyBatis 中的属性配置项，可以改变 MyBatis 的运行时行为规则  标签中的 value 为该设置的默认值  缓存全局开关          &lt;setting name="cacheEnabled" value="true" /&gt;        延迟加载全局开关          值为 true 时所有对象延迟加载      可通过在具体的查询中设置 fetchType 来覆盖该设置      &lt;setting name="lazyLoadingEnabled" value="false" /&gt;        所有对象直接加载          &lt;setting name="aggressiveLazyLoading" value="true" /&gt;        允许单一语句返回多个结果集，需要兼容驱动          &lt;setting name="multipleResultSetsEnabled" value="true" /&gt;        使用列标签代替类名          &lt;setting name="useColumnLabel" value="true" /&gt;        允许 JDBC 使用数据库自增主键          &lt;setting name="useGeneratedKeys" value="true" /&gt;        指定自动映射到字段的规则          NONE 取消自动映射      PARTIAL 只映射没有定义嵌套结果集映射的结果集      FULL 自动映射任何结果集      &lt;setting name="autoMappingBehavior" value="PARTIAL" /&gt;        指定当自动映射碰到未知列的处理规则          NONE 不做任何处理      WARNING 输入警告日志      FAILING 抛出 SqlSessionException 异常      &lt;setting name="autoMappingUnknownColumnBehavior" value="NONE" /&gt;        配置默认执行器          SIMPLE 普通执行器      REUSE 重用预处理语句      BATCH 重用语句并执行批量更新      &lt;setting name="defaultExecutorType" value="SIMPLE" /&gt;        设置驱动等待数据库响应的超时时间          该设置项默认没有值      值的范围是任意正整数      值的单位是秒      &lt;setting name="defaultStatementTimeout" value="" /&gt;        为驱动的结果集数量设置提示值          该设置项默认没有值      值的范围是任意正整数      可在具体查询中通过 fetchSize 覆盖该设置项      &lt;setting name="defaultFetchSize" value="" /&gt;        允许在嵌套语句中使用分页 RowBounds          &lt;setting name="safeRowBoundsEnabled" value="false" /&gt;        允许在嵌套语句中使用分页 RowHandler          &lt;setting name="safeRowHandlerEnabled" value="true" /&gt;        开启驼峰命令规则自动转换功能          例如：create_time &gt; createTime      &lt;setting name="mapUnderscoreToCameCase" value="false" /&gt;        利用本地缓存机制防止循环引用和加速重复嵌套查询          SESSION 缓存一个会话中执行的所有查询      STATEMENT 本地会员只用在语句执行中，对相同 SqlSession 的不同调用不会共享数据      &lt;setting name="localCacheScope" value="SESSION" /&gt;        当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型          OTHER 一般类型      NULL 空值      VARCHAR 字符串      &lt;setting name="jdbcTypeForNull" value="OTHER" /&gt;        指定某个对象的方法触发一次延迟加载          多个方法名称通过逗号划分      &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString /&gt;"        指定动态 SQL 生成的默认语言          &lt;setting name="defaultScriptingLanguage" value="org.apache.ibatis.scripting.xmltags.XMLLanguageDriver" /&gt;        当结果集为 NULL 时，调用映射对象的 setter 方法为结果赋值          结果集类型是 List 时，调用 setter 方法      结果集类型是 Map 时，调用 put 方法      该属性对于基本类型无效      &lt;setting name="callSetterOnNulls" value="false" /&gt;        当对象所有列都返回 NULL 时，将整个对象设置为 NULL          &lt;setting name="returnInstanceForEmptyRow" value="false" /&gt;        指定日志名称的前缀          该设置项没有默认值      值可以是任何字符串      &lt;setting name="logPrefix" value="" /&gt;        指定日志的具体实现方式          该设置项没有默认值      值可以是 slf4j / log4j / log4j2 / jdk_logging / commons_logging / stdout_logging / no_loggging      未指定值的时候会在上述支持列表中自动查找      &lt;setting name="logImpl" value="" /&gt;        指定创建具有延迟加载能力的对象所用到的代理工具          值可以是 CGLIB / JAVASSIST      &lt;setting name="proxyFactory" value="JAVASSIST" /&gt;        指定 VFS 的实现          该设置项没有默认值      值可以是自定义 VFS 的实现类全名      多个 VFS 可以通过逗号划分      &lt;setting name="vfsImpl" value="" /&gt;        允许使用方法签名中的名称作为语句参数名称          仅在 Java 8 环境中生效，并且需要在环境变量中加上 -parameters      &lt;setting name="useActualParamName" value="true" /&gt;      完整配置示例&lt;settings&gt;  &lt;setting name="cacheEnabled" value="true"/&gt;  &lt;setting name="lazyLoadingEnabled" value="true"/&gt;  &lt;setting name="multipleResultSetsEnabled" value="true"/&gt;  &lt;setting name="useColumnLabel" value="true"/&gt;  &lt;setting name="useGeneratedKeys" value="false"/&gt;  &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt;  &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt;  &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt;  &lt;setting name="defaultStatementTimeout" value="25"/&gt;  &lt;setting name="defaultFetchSize" value="100"/&gt;  &lt;setting name="safeRowBoundsEnabled" value="false"/&gt;  &lt;setting name="mapUnderscoreToCamelCase" value="false"/&gt;  &lt;setting name="localCacheScope" value="SESSION"/&gt;  &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt;  &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt;&lt;/settings&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis防止死循环]]></title>
      <url>/java/mybatis/error/2017/02/18/MyBatis%E9%98%B2%E6%AD%A2%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
      <content type="text"><![CDATA[  mybatis的mapper文件中如果存在错误，会导致项目启动时加载mapper进入死循环，却不输出错误重新buildSqlSessionFactory()  重写org.mybatis.spring.SqlSessionFactoryBean的buildSqlSessionFactory()方法public class FixedSqlSessionFactory extends SqlSessionFactoryBean {    @Override    protected SqlSessionFactory buildSqlSessionFactory() throws IOException {        try {            return super.buildSqlSessionFactory();        }catch (Exception e){            e.printStackTrace();        }finally {            ErrorContext.instance().reset();        }        return null;    }}修改配置文件中的引用为上述包装类&lt;bean id="sqlSessionFactory" class="com.innovaee.hts.sop.web.FixedSqlSessionFactory"&gt;    &lt;property name="dataSource" ref="dataSource"/&gt;    ...&lt;/bean&gt;启动项目，则会在控制台输出具体错误信息]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate枚举映射策略]]></title>
      <url>/java/hibernate/2017/02/15/Hibernate%E6%9E%9A%E4%B8%BE%E6%98%A0%E5%B0%84%E7%AD%96%E7%95%A5/</url>
      <content type="text"><![CDATA[  稍微解释一下Hibernate枚举策略枚举类型映射到数据库的方式  int，即获取枚举的索引值存入数据库，从0开始  String，即获取枚举的name属性存入数据库Hibernate默认把枚举类型的字段当做基本类型(int)的字段来映射  可以通过注解的方式进行控制          @Enumerated(EnumType.ORDINAL)  默认方式，int型      @Enumerated(EnumType.STRING)  String型，会获取枚举的name属性      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
          <tag> enum </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java支付宝扫码支付[旧]]]></title>
      <url>/java/pay/2017/02/14/Java%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98-%E6%97%A7/</url>
      <content type="text"><![CDATA[  在实际开发过程中，首先采用当面付模式进行开发，但没有成功，个人认为当面付更适合线下模式之后改用即时到账模式才成功接入支付宝扫码支付功能以下内容是基于即时到账模式开发要使用支付宝即时到账接口，首先需要签约即时到账产品， 申请地址审核进度通常需要1个工作日，但实际几小时即可之后需要获取和设置如下关键信息pid:2088621150311111          合作伙伴身份IDkey:zrqyf6dfli7dvji4mmi4sw1111111111      MD5密钥notify_url:http://127.0.0.1:8080/sop/order/notify/ali    异步通知回调地址return_url:http://127.0.0.1:8080/sop/order/notify/ali/return  同步通知回调地址官网支付宝-开放平台模式  当面付 ，消费者扫描商户二维码完成支付。并不适用于Web网页端扫码支付  即时到账 ，用户在线向开发者的支付宝账号支付资金。Web网页端扫码支付首选开发步骤  下载支付宝提供的即时到账 DEMO          按下图所示将alipay下所有文件复制到项目开发目录，支付宝已将接口的调用、请求、验签等操作完成，我们只需要包装好数据后调用即可        打开AlipayConfig.java，将其中关键信息替换成之前准备好的内容          除了下述四个信息，其他内容均不需要修改      ** partner**即pid，key即md5密钥，都可以在 mapi网关产品密钥 获取      notify_url是支付宝异步通知链接，由支付宝主动调用，一旦用户完成支付，即调用该地址      不可添加自定义参数      必须保证外网可正常访问      使用POST方式发送/接收数据      没有时间限制      如果是https，则必须安装ssl证书，并且需要正规的证书机构签发，自签名的无法识别      return_url，是支付宝同步跳转通知，用户完成支付后，在支付页面完成跳转      不可添加自定义参数      必须保证外网可正常访问，但可在本机测试      使用GET方式发送/接收数据      一分钟超时      // 合作身份者ID，签约账号，以2088开头由16位纯数字组成的字符串，查看地址：https://b.alipay.com/order/pidAndKey.htmpublic static String partner = SOPConstants.ALI_PAY_PARTNER_ID; // MD5密钥，安全检验码，由数字和字母组成的32位字符串，查看地址：https://b.alipay.com/order/pidAndKey.htmpublic static String key = SOPConstants.ALI_PAY_MD5_KEY;// 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问public static String notify_url = SOPConstants.ALI_PAY_NOTIFY_URL;// 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问public static String return_url = SOPConstants.ALI_PAY_RETURN_URL;  在订单支付页面创建一个空的div，用于接收调用即时到账接口返回的表单数据$.ts.doAction("/api/order/pay/ali", {    orderId: orderId}, function () {    // 提交表单内容    $orderSubmitPanel.find("#returnAli").append(this.data);   // 打开订单状态轮询页面，确保支付完成后，支付页面能自动跳转    $.ts.openModalWindow("/api/order/pay/ali/tip/" + orderId, 350, 300);}, "", "", "");@RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic ResponseData ali(HttpServletRequest request, @RequestParam("orderId") final String orderId) {    SimpleActionHandler actionHandler = new SimpleActionHandler(request) {        @Override        protected void doHandle(ResponseData responseData) throws Exception {            responseData.setData(orderPayService.aliPay(IdEncoder.decodeId(orderId)));        }    };    return actionHandler.handle();}  按照 请求参数说明 包装请求参数，并建立请求          建立请求的操作支付宝已在AlipaySubmit.java中实现，只需要调用其中buildRequest()方法并传入参数即可      public String aliPay(Long orderId) {    // 获取订单信息    OrderDTO order = orderManageService.getOrder(orderId);    // 包装请求参数    Map&lt;String, String&gt; params = Maps.newHashMap();    // 调用接口    params.put("service", AlipayConfig.service);    // 签约账号id    params.put("partner", AlipayConfig.partner);    // 收款支付账号，默认与签约账号相同    params.put("seller_id", AlipayConfig.seller_id);    // 编码格式，支付GBK和UTF-8    params.put("_input_charset", AlipayConfig.input_charset);    // 支付类型    params.put("payment_type", AlipayConfig.payment_type);    // 异步通知回调地址    params.put("notify_url", AlipayConfig.notify_url);    // 同步通知跳转地址    params.put("return_url", AlipayConfig.return_url);    // 防钓鱼时间戳    params.put("anti_phishing_key", AlipayConfig.anti_phishing_key);    // 客户端IP    params.put("exter_invoke_ip", super.getClientIP());    // 订单号    params.put("out_trade_no", order.getCode());    // 标题    params.put("subject", "轻实训-" + order.getName());    // 金额    params.put("total_fee", String.valueOf(order.getPrice()));    // 建立请求    return AlipaySubmit.buildRequest(params, "get", "确认");}  由于调用即时到账接口返回的表单数据会自动提交，而接收表单数据的div是在订单提交页面，因此按照表单提交默认方式，会导致订单提交页面被替换成支付宝扫码页面  所以需要修改AlipaySubmit.java中的buildRequest()方法，在其拼接的表单中加入target=“_blank”，让表单提交时在新页面打开public static String buildRequest(Map&lt;String, String&gt; sParaTemp, String strMethod, String strButtonName) {    //待请求参数数组    Map&lt;String, String&gt; sPara = buildRequestPara(sParaTemp);    List&lt;String&gt; keys = new ArrayList&lt;String&gt;(sPara.keySet());    StringBuffer sbHtml = new StringBuffer();    sbHtml.append("&lt;form id=\"alipaysubmit\" name=\"alipaysubmit\" action=\"" + ALIPAY_GATEWAY_NEW                  + "_input_charset=" + AlipayConfig.input_charset + "\" method=\"" + strMethod                  + "\" target=\"_blank\"&gt;");    for (int i = 0; i &lt; keys.size(); i++) {        String name = (String) keys.get(i);        String value = (String) sPara.get(name);        sbHtml.append("&lt;input type=\"hidden\" name=\"" + name + "\" value=\"" + value + "\"/&gt;");    }    //submit按钮控件请不要含有name属性    sbHtml.append("&lt;input type=\"submit\" value=\"" + strButtonName + "\" style=\"display:none;\"&gt;&lt;/form&gt;");    sbHtml.append("&lt;script&gt;document.forms['alipaysubmit'].submit();&lt;/script&gt;");    return sbHtml.toString();}  用户通过支付宝扫描二维码完成支付后，支付宝会主动调用notify_url进行回执          由于回执时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该回执地址一个访问许可，否则会被安全框架屏蔽      @RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic String aliNotify(HttpServletRequest request) {    return orderPayService.aliNotify(request);}  接收并处理支付回执后，必须通知支付宝回执接收成功，否则支付宝会认为回执发送失败，并发送数次通知  支付宝发送异步通知后，如果没有获取到成功回执（返回success），则会按一定规律重发（4m,10m,10m,1h,2h,6h,15h）  接收支付宝的回执信息时，必须进行验签，改操作支付宝已实现，我们只需要调用AlipayNotify.java中的verify()方法即可  验签成功后需要判断操作状态，从回执参数中获取trade_status，参数值为TRADE_SUCCESS即为支付成功  还有一个订单状态是TRADE_FINISHED，该状态表示订单已完成，即超过三个月的退款期限，一旦订单到达这个状态，支付宝会再次调用notify_url进行回执，若业务系统没有退款流程，则无需处理该状态public String aliNotify(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 交易状态    String tradeStatus = request.getParameter("trade_status");    // 验签    if (AlipayNotify.verify(getNotifyData(request))) {        // 交易成功        if (tradeStatus.equals("TRADE_SUCCESS")) {            // 更新订单信息            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());        }        return "success";    } else {        return "fail";    }}  处理回执内容，用于验签private Map&lt;String, String&gt; getNotifyData(HttpServletRequest request, String method) throws Exception {    // 获取回执内容    Map requestParams = request.getParameterMap();    // 过滤回执内容    Map&lt;String, String&gt; params = Maps.newHashMap();    for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) {        String name = (String) iter.next();        String[] values = (String[]) requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        if (method.equals("notify")) {            params.put(name, valueStr);        } else {            params.put(name, new String(valueStr.getBytes("ISO-8859-1"), "utf-8"));        }    }    return params;}  用户通过支付宝扫描二维码完成支付后，在新打开的支付宝窗口会执行return_url进行跳转          由于跳转时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该跳转地址一个访问许可，否则会被安全框架屏蔽      public String aliReturn(HttpServletResponse response, HttpServletRequest request) throws Exception {    orderPayService.aliReturn(response, request);           // 跳转地址会通过输出流的方式关闭新窗口，所以无需返回任何内容    return null;}  接收跳转通知时，同样需要验签，以确保内容的安全性  为防止网络等不可预测原因导致异步回执没能成功接收，所以在接收跳转通知并验签通过以及状态判断成功后，同样需要对订单状态进行更新  如果用户完成支付后立即关闭页面，会导致同步跳转通知无法执行，所以不能完全依赖该通知确认订单状态  如果用户在支付页面扫码生成预下单订单，但并未直接付款，而是前往支付宝订单页重新付款，即使网页端支付页面未关闭，也无法执行该同步跳转通知  通过同步跳转通知更新订单状态，只是一种辅助措施，主要手段还是通过接受异步回执来处理订单状态  由于支付宝的扫码页面是在新窗口打开，在支付完成后并没有存在的必要，即可以通过输出流的方式关闭该窗口public void aliReturn(HttpServletResponse response, HttpServletRequest request) throws IOException {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 交易状态    String tradeStatus = request.getParameter("trade_status");    // 验签    if (AlipayNotify.verify(getNotifyData(request))) {        if (tradeStatus.equals("TRADE_FINISHED") || tradeStatus.equals("TRADE_SUCCESS")) {            // 更新订单信息            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());            // 页面跳转            response.setContentType("text/html;charset=gb2312");     // 通过输出流关闭窗口            PrintWriter writer = response.getWriter();            writer.println("&lt;html&gt;&lt;head&gt;&lt;title&gt; CLOSE &lt;/title&gt;&lt;/head&gt;");            writer.println("&lt;body&gt;");            writer.println("&lt;script type=\"text/javascript\"&gt;window.close();&lt;/script&gt;");            writer.println("&lt;/body&gt;&lt;/html&gt;");        }    }}  轮询订单状态，实现支付完成后页面自动跳转          由于支付回执是异步的，所以即使捕获到异步回执也无法实现支付页面的自动跳转      所以需要在支付页面打开时设置一个ajax轮询订单状态，一旦订单状态更新，则进行页面跳转      // 页面关闭$(“.modal-header button.close:last”).click(function () {    // 停止轮询    clearInterval(checkTimer);});// 轮询订单状态checkTimer = setInterval(function () {    // 窗口是否打开    if ($(“.order-pay-panel”).length &lt;= 0) {        clearInterval(checkTimer);    }    // 获取订单状态    $.ts.doAction(“/api/order/review/check/“, {        orderId: orderId    }, function () {        // 订单已支付        if (!this.data) {            $.ts.closeWindow();            g_index.loadMainContentWithState(“/order/manage”);        $.ts.toastr.success(“订单已支付成功！”);        }    }, “”, “”, “”);}, 3000);]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java微信扫码支付]]></title>
      <url>/java/pay/2017/02/11/Java%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/</url>
      <content type="text"><![CDATA[  以下内容是基于模式二开发在开发之前需要先到微信支付官网注册账号，并获取到以下信息appid:wx1137939101111111公众账号idmch_id:1438111111 商户号key:4Inn0va1eSxOnl1neqsxwuhan1111111密钥send_url:https://api.mch.weixin.qq.com/pay/unifiedorder统一下单APInotify_url:http://127.0.0.1:8080/sop/order/notify/wechat支付成功回调地址官网  微信支付官网  扫码支付开发者文档模式  需要在公众平台后台设置支付回调URL ，用于接收用户扫码后微信支付系统回调的productid和openid  直接调用统一下单API 即可，相对于模式一更为简洁定义接口对象  根据 统一下单接口API 定义四个对象，用于发送和接收数据UnifiedOrderRequest.java 统一下单请求参数-必填项public class UnifiedOrderRequest {    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 随机字符串，32位以内    private String nonce_str;    // 签名，遵循签名算法    private String sign;    // 商品描述，浏览器打开的网站主页title名称-商品概述    private String body;    // 商户订单号，32位以内，不重复    private String out_trade_no;    // 标价金额，单位分    private Integer total_fee;    // 终端ip，填写调用端的ip    private String spbill_create_ip;    // 通知地址，接收支付结果的会掉地址，必须外网可访问    private String notify_url;    // 交易类型，JSAPI--公众号支付、NATIVE--原生扫码支付、APP--app支付    private String trade_type;}UnifiedOrderRequestExt.java 统一下单请求参数-非必填项public class UnifiedOrderRequestExt extends UnifiedOrderRequest {    // 设备号，网页端填写WEB    private String device_info;    // 签名类型，默认MD5    private String sign_type;    // 商品详情，JSON格式    private String detail;    // 附加数据，可作为自定义参数使用    private String attach;    // 标价币种，默认CNY    private String fee_type;    // 交易起始时间，格式为yyyyMMddHHmmss    private String time_start;    // 交易结束时间，最短失效时间必须间隔5分钟    private String time_expire;    // 商品id，trade_type=NATIVE时，必填    private String product_id;    // 指定支付方式，no_credit可限制使用信用卡    private String limit_pay;    // 用户标识,trade_type=JSAPI时，必填    private String openid;}UnifiedOrderResponse.java 统一下单返回参数-必填项public class UnifiedOrderResponse {    // 返回状态码，通信标识，SUCCESS/FAIL    private String return_code;    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 随机字符串    private String nonce_str;    // 签名    private String sign;    // 业务结果，交易标识，SUCCESS/FAIL    private String result_code;    // 交易类型，JSAPI，NATIVE，APP    private String trade_type;    // 预支付交易会话标识，有效值2小时    private String prepay_id;}UnifiedOrderResponseExt.java 统一下单返回参数-非必填项public class UnifiedOrderResponseExt extends UnifiedOrderResponse {    // 返回信息，非空则表示返回了错误信息    private String return_msg;    // 设备号    private String device_info;    // 错误代码    private String err_code;    // 错误代码描述    private String err_code_des;    // 二维码连接，trade_type=NATIVE时返回    private String code_url;}定义一个标签用于显示二维码  调用统一下单API成功后，会返回一系列XML数据，其中code_url表示返回的预支付交易链接，可将其生成二维码图片&lt;div class="order-pay-panel order-wechat-panel"&gt;    &lt;div class="modal-header"&gt;        &lt;button type="button" class="close" data-dismiss="modal" aria-hidden="true"&gt;×&lt;/button&gt;        &lt;h4 class="modal-title"&gt;            &lt;i class="icon-th-large"&gt;&lt;/i&gt; 微信支付        &lt;/h4&gt;    &lt;/div&gt;    &lt;div class="modal-body"&gt;        &lt;div class="wechat-qrcode-panel margin-bottom-10"&gt;            &lt;img src="${ctx}/api/order/pay/wechat/qrcode?orderId=${order.hexId}"&gt;        &lt;/div&gt;        &lt;div class="wechat-description-panel"&gt;            &lt;p class="text-muted"&gt;使用微信扫描二维码完成支付&lt;/p&gt;            &lt;p class="text-danger"&gt;￥${order.price}&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;根据统一下单API的要求生成订单  将系统内部订单号传入请求参数的out_trade_no中，用于后续操作的唯一标识符  请求参数中的sign是验证参数合法性的唯一标识，需要根据 微信支付签名算法 来生成  使用XStream将对象转换为XML，由于微信的请求参数中大量使用下划线，但下划线在XStream中是关键字，因此需要把下划线转换为双下划线，避免报错private String generateOrderInfo(Long orderId) throws Exception {    // 获取订单信息    OrderDTO order = orderManageService.getOrder(orderId);    // 生成订单    UnifiedOrderRequestExt ext = new UnifiedOrderRequestExt();    ext.setAppid(SOPConstants.WECHAT_PAY_APP_ID);    ext.setMch_id(SOPConstants.WECHAT_PAY_MCH_ID);    ext.setBody("轻实训-" + order.getName());    ext.setOut_trade_no(order.getCode());    ext.setTotal_fee(order.getPrice() * 100);    ext.setSpbill_create_ip(super.getClientIP());    ext.setNotify_url(SOPConstants.WECHAT_PAY_NOTIFY_URL);    ext.setTrade_type("NATIVE");    ext.setProduct_id(order.getHexId());  // 生成32位随机数    ext.setNonce_str(makeNonceStr());  // 签名，按照指定签名算法生成    ext.setSign(makeSign(ext));    // 格式转换为XML    XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));    xStream.alias("xml", UnifiedOrderRequestExt.class);    return xStream.toXML(ext);}  生成32位随机数，方式为当前时间加随机数private String makeNonceStr() {    StringBuffer str = new StringBuffer(DateUtil.getSysDateString("yyyyMMddHHmmssS"));    str.append((new Random().nextInt(900) + 100));    return str.toString();}  拼接签名数据private String makeSign(UnifiedOrderRequestExt ext) throws Exception {    // 根据规则创建可排序的map集合    SortedMap&lt;String, String&gt; signMaps = Maps.newTreeMap();    signMaps.put("appid", ext.getAppid());    signMaps.put("body", ext.getBody());    signMaps.put("mch_id", ext.getMch_id());    signMaps.put("nonce_str", ext.getNonce_str());    signMaps.put("notify_url", ext.getNotify_url());    signMaps.put("out_trade_no", ext.getOut_trade_no());    signMaps.put("spbill_create_ip", ext.getSpbill_create_ip());    signMaps.put("trade_type", ext.getTrade_type());    signMaps.put("total_fee", ext.getTotal_fee().toString());    signMaps.put("product_id", ext.getProduct_id());    // 生成签名    return generateSign(signMaps);}  按照签名算法生成签名private String generateSign(SortedMap&lt;String, String&gt; signMaps) throws Exception {    StringBuffer sb = new StringBuffer();    // 字典序    for (Map.Entry signMap : signMaps.entrySet()) {        String key = (String) signMap.getKey();        String value = (String) signMap.getValue();        // 为空不参与签名、参数名区分大小写        if (null != value &amp;&amp; !"".equals(value) &amp;&amp; !"sign".equals(key) &amp;&amp; !"key".equals(key)) {            sb.append(key + "=" + value + "&amp;");        }    }    // 拼接key    sb.append("key=" + SOPConstants.WECHAT_PAY_KEY);    // MD5加密    return encoderByMd5(sb.toString()).toUpperCase();}调用统一下单API  将生成的订单发送给微信，同时接收微信的返回参数，读取其中的code_url  如果发送的订单信息不符合要求，则会在返回参数中告知问题  订单合法，返回参数中return_code=SUCCESS return_msg=OK result_code=SUCCESS  订单不合法，返回参数中return_code=FAIL return_msg=具体错误原因private String sendHttpRequest(String orderInfo) throws IOException {    // 建立连接    HttpURLConnection conn = (HttpURLConnection) new URL(SOPConstants.WECHAT_PAY_SEND_URL).openConnection();    conn.setRequestMethod("POST");    conn.setDoOutput(true);    // 发送数据    BufferedOutputStream bos = new BufferedOutputStream(conn.getOutputStream());    bos.write(orderInfo.getBytes());    bos.flush();    bos.close();    // 获取数据    BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));    // 接收数据    String line;    StringBuffer str = new StringBuffer();    while ((line = reader.readLine()) != null) {        str.append(line);    }    // XML数据转换为对象    XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));    xStream.alias("xml", UnifiedOrderResponseExt.class);    UnifiedOrderResponseExt ext = (UnifiedOrderResponseExt) xStream.fromXML(str.toString());    // 判断数据有效性    if (null != ext &amp;&amp; "SUCCESS".equals(ext.getReturn_code()) &amp;&amp; "SUCCESS".equals(ext.getResult_code())) {        return ext.getCode_url();    }    return null;}根据返回的code_url生成二维码图片  二维码的生成采用的是Google的 GitHub - zxing/zxing at zxing-3.0.0@RequestMapping(value = “/wechat/qrcode”, method = RequestMethod.GET)public void wechatQRCode(HttpServletResponse response, @RequestParam("orderId") String orderId) {    try {        // 初始化数据        int width = 240;        int height = 240;        String format = "png";  // 获取二维码链接        String codeUrl = orderPayService.getQRCodeUrl(IdEncoder.decodeId(orderId));        Hashtable htable = new Hashtable();        htable.put(EncodeHintType.CHARACTER_SET, "UTF-8");        // 生成图片        BitMatrix matrix = new MultiFormatWriter().encode(codeUrl, BarcodeFormat.QR_CODE, width, height, htable);        OutputStream out = response.getOutputStream();        // 输出图片        MatrixToImageWriter.writeToStream(matrix, format, out);        out.flush();        out.close();    } catch (Exception e) {        logger.error(e.getMessage(), e);    }}  需要准备的包信息&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;core&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;javase&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;接收回调  用户通过微信扫描二维码并支付成功后，微信会根据之前订单中的notify_url回调地址进行回执  此处提供给微信的回调地址必须是外网可访问的，否则无法正常接收回执信息  由于回执时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该回执地址一个访问许可，否则会被安全框架屏蔽  发送回执是异步进行，由于网络等不确定因素，微信不保证回执一定成功  微信会通过一定的策略定期重启发送通知，通知频率为15/15/30/180/1800/1800/1800/1800/3600，单位：秒  虽然是异步回执，但并不需要采用ajax异步接收的方式来接收数据@RequestMapping(value = "/wechat")public String wechatNotify(HttpServletResponse response, HttpServletRequest request) throws Exception {    orderPayService.notify(response, request);  // 此处的返回值无效，需要在支付页面通过轮询获取支付结果，微信支付本身无法实现自动跳转    return "/redirect:/login";}处理回执内容  数据是通过IO流发送，所以也需要通过IO流接收  微信发送回执用户接收后，需要通过IO流的方式告知微信接收成功，否则微信认为回执失败  接收到回执信息后，最关键是验证签名来确保信息的有效性和安全性，验签的方式和发送订单签名的方式一致  验签成功，且回执信息中result_code=SUCCESS，则表示回执信息有效  从回执信息中可获取到out_trade_no，这是之前发送的用户订单唯一标识符，通过该信息可以继续处理用户订单  所有流程处理完毕后，必须以XML格式编写回执信息，并通过IO流的方式告知微信回执接收成功public void notify(HttpServletResponse response, HttpServletRequest request) throws Exception {    // 读取回执数据    HashMap&lt;String, String&gt; notifyMaps = readNotify(request);    // 回执数据验证    if (notifyMaps == null || notifyMaps.isEmpty()) {        logger.error("未收到回执数据！");        throw new TSharkException("未收到回执数据！");    }    // 挑选数据    SortedMap&lt;String, String&gt; notifySorts = sortNotify(notifyMaps);    // 重新签名    String sign = generateSign(notifySorts);    // 获取回执签名    String notifySign = notifySorts.get("sign").toUpperCase();    // 验证签名    if (!sign.equals(notifySign)) {        logger.error("签名验证失败！");        throw new TSharkException("签名验证失败！");    }    String resXml;    // 验证回执    if ("SUCCESS".equals(notifySorts.get("result_code"))) {        // 更新订单信息        updateOrderInfo(notifySorts.get("out_trade_no"));        // 微信回执        resXml = "&lt;xml&gt;" +                "&lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;" +                "&lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;" +                "&lt;/xml&gt; ";    } else {        resXml = "&lt;xml&gt;" +                "&lt;return_code&gt;&lt;![CDATA[FAIL]]&gt;&lt;/return_code&gt;" +                "&lt;return_msg&gt;&lt;![CDATA[报文为空]]&gt;&lt;/return_msg&gt;" +                "&lt;/xml&gt; ";    }    BufferedOutputStream out = new BufferedOutputStream(response.getOutputStream());    out.write(resXml.getBytes());    out.flush();    out.close();}  从IO流中读取回执信息private HashMap&lt;String, String&gt; readNotify(HttpServletRequest request) throws Exception {    // 读取参数    InputStream inputStream = request.getInputStream();    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, "UTF-8"));    // 接收数据    String line;    StringBuffer str = new StringBuffer();    while ((line = reader.readLine()) != null) {        str.append(line);    }    reader.close();    inputStream.close();    // XML转换Map    return fromXml(str.toString());}  读取的回执信息时XML格式，需要通过jDom的SAXBuilder解析为Mapprivate HashMap&lt;String, String&gt; fromXml(String xml) throws Exception {    xml = xml.replaceFirst("encoding=\".*\"", "encoding=\"UTF-8\"");    if (null == xml || "".equals(xml)) {        return null;    }    HashMap&lt;String, String&gt; m = Maps.newHashMap();    InputStream in = new ByteArrayInputStream(xml.getBytes("UTF-8"));    SAXBuilder builder = new SAXBuilder();    Document doc = builder.build(in);    Element root = doc.getRootElement();    List list = root.getChildren();    Iterator it = list.iterator();    while (it.hasNext()) {        Element e = (Element) it.next();        String k = e.getName();        String v = "";        List children = e.getChildren();        if (children.isEmpty()) {            v = e.getTextNormalize();        } else {            v = getXmlChildren(children);        }        m.put(k, v);    }    //关闭流    in.close();    return m;}private String getXmlChildren(List children) {    StringBuffer sb = new StringBuffer();    if (!children.isEmpty()) {        Iterator it = children.iterator();        while (it.hasNext()) {            Element e = (Element) it.next();            String name = e.getName();            String value = e.getTextNormalize();            List list = e.getChildren();            sb.append("&lt;" + name + "&gt;");            if (!list.isEmpty()) {                sb.append(getXmlChildren(list));            }            sb.append(value);            sb.append("&lt;/" + name + "&gt;");        }    }    return sb.toString();}轮询订单状态，实现支付完成后页面自动跳转  由于支付回执是异步的，所以即使捕获到异步回执也无法实现支付页面的自动跳转  所以需要在支付页面打开时设置一个ajax轮询订单状态，一旦订单状态更新，则进行页面跳转// 页面关闭$(".modal-header button.close:last").click(function () {    // 停止轮询    clearInterval(checkTimer);});// 轮询订单状态checkTimer = setInterval(function () {    // 窗口是否打开    if ($(".order-pay-panel").length &lt;= 0) {        clearInterval(checkTimer);    }    // 获取订单状态    $.ts.doAction("/api/order/review/check/", {        orderId: orderId    }, function () {        // 订单已支付        if (!this.data) {            $.ts.closeWindow();            g_index.loadMainContentWithState("/order/manage");      $.ts.toastr.success("订单已支付成功！");        }    }, "", "", "");}, 3000);]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> wechatpay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java MD5加密]]></title>
      <url>/java/2017/02/09/Java-MD5%E5%8A%A0%E5%AF%86/</url>
      <content type="text"><![CDATA[  md5加密简要算法生成 16 位加密串/** * 利用MD5进行加密 * * @param str 待加密的字符串 * @return 加密后的字符串 */private String EncoderByMd5(String str) throws Exception {	// 生成一个MD5加密计算摘要	MessageDigest md = MessageDigest.getInstance("MD5");	// 计算md5函数	md.update(str.getBytes());	// digest()最后确定返回md5 hash值，返回值为8为字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符	// BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值	return new BigInteger(1, md.digest()).toString(16);}生成 32 位加密串private String md5(String input) {    MessageDigest md = null;    try {        md = MessageDigest.getInstance("MD5");        md.update(input.getBytes());        String md5 = new BigInteger(1, md.digest()).toString(16);        return fillMD5(md5);    } catch (NoSuchAlgorithmException e) {        logger.error("字串加密失败！", e);    }    return null;}/** * 加密串补齐32位 */private String fillMD5(String md5) {    return md5.length() == 32 ? md5 : fillMD5("0" + md5);}]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> md5 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis新增返回id]]></title>
      <url>/java/mybatis/2017/02/08/MyBatis%E6%96%B0%E5%A2%9E%E8%BF%94%E5%9B%9Eid/</url>
      <content type="text"><![CDATA[  新增一条数据到数据库，并返回该数据的id&lt;insert id="saveSendMessage" keyColumn="id" keyProperty="id" useGeneratedKeys="true" parameterType="SendMessageDTO"&gt;	...&lt;/insert&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[正则表达式]]></title>
      <url>/validate/2017/01/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="text"><![CDATA[  正则表达式的一些基础语法介绍  正则表达式是一种字符串查找以及替换的操作方式。被广泛用于：          检查文本中是否含有指定的特征词      找出文中匹配特征词的位置      从文本中提取信息，比如：字符串的子串      修改文本      语法  字符：a b c d 1 2 3 4 etc.  字符类： . [abc] [a-z] \d \w \s          . 任何字符      \d 数字      \w 字母[0-9A-Za-z_]      \s 空格、制表符、回车、换行符      否定字符类： [^abc] \D \W \S        重复：{4} {3,16} {1,} ? * +          ? 零次或一次      * 大于零次      + 表示一次或一次以上      如果不加上 ? ，所有的重复都是最长匹配        分组：(Septem|Octo|Novem|Decem)ber  词，行以及文本的分隔：\b ^ $ \A \z  转义字符： \1 \2 \3 etc. (在匹配表达式和替换表达式中都可用)  元字符：. \ [ ] { } ? * + | ( ) ^ $  在字符类中使用元字符：[ ] \ - ^  使用反斜杠可以忽略元字符：\]]></content>
      <categories>
        
          <category> validate </category>
        
      </categories>
      <tags>
        
          <tag> validate </tag>
        
          <tag> regular </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[对象反射赋值]]></title>
      <url>/java/relfect/2017/01/20/%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%B0%84%E8%B5%8B%E5%80%BC/</url>
      <content type="text"><![CDATA[  在不确定对象字段及内容的前提下，为对象赋值的解决方案通常是反射赋值实现方式// 获取当前会员对象Class&lt;MemberDTO&gt; member = (Class&lt;MemberDTO&gt;) super.getMember().getClass();// 获取所有字段Field[] fileds = member.getDeclaredFields();// 遍历字段找到与当前修改字段相符合的字段for (Field field : fileds) {	// ** 获取私有字段的操作权限	field.setAccessible(true);	if (field.getName().equals(name)) {		// 找到字段对应 set 方法		PropertyDescriptor pd = new PropertyDescriptor(field.getName(), member);		Method method = pd.getWriteMethod();		// 传入当前对象，并赋值		method.invoke(super.getMember(), value);		break;	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> relfect </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> relfect </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java实现颜色随机]]></title>
      <url>/java/2017/01/20/Java%E5%AE%9E%E7%8E%B0%E9%A2%9C%E8%89%B2%E9%9A%8F%E6%9C%BA/</url>
      <content type="text"><![CDATA[  通过随机拼接rgb编码的方式，获取随机的颜色码实现方式String r, g, b;// 定义随机数	Random random = new Random();	// 获取编码r = Integer.toHexString(random.nextInt(256)).toUpperCase();g = Integer.toHexString(random.nextInt(256)).toUpperCase();b = Integer.toHexString(random.nextInt(256)).toUpperCase();	// 编码有效性控制r = r.length() == 1 ? "0" + r : r;g = g.length() == 1 ? "0" + g : g;b = b.length() == 1 ? "0" + b : b;	// 拼接return r + g + b;]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> color </tag>
        
          <tag> random </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java实现不重复随机数]]></title>
      <url>/java/2017/01/20/Java%E5%AE%9E%E7%8E%B0%E4%B8%8D%E9%87%8D%E5%A4%8D%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      <content type="text"><![CDATA[  随机指定范围内生成N个不重复的数具体实现/** * @param min 指定范围最小值 * @param max 指定范围最大值 * @param n 随机数个数*/private int[] randomCommon(int min, int max, int n){	// 有效性判断	if (n &gt; (max - min + 1) || max &lt; min) {		return null;	}	// 按随机个数声明存放数组	int[] result = new int[n];	// 统计生成个数	int count = 0;	// 生成个数小于n之前，一直生成	while(count &lt; n) {		// 在指定范围内生成随机数		int num = (int) (Math.random() * (max - min)) + min;		// 重复标记		boolean flag = true;		// 将生成的随机数与数组中已生成的数作比较		for (int j = 0; j &lt; n; j++) {			// 重复则标记			if(num == result[j]){				flag = false;				break;			}		}		// 不重复则加入数组		if(flag) {			result[count] = num;			// 生成个数累加			count++;		}	}	return result;}]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> random </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript 跳出循环]]></title>
      <url>/javascript/2017/01/20/Javascript-%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF/</url>
      <content type="text"><![CDATA[  对于不同的循环方式，javascript需要采用不同的方式跳出for循环依然使用continue和breakfor (var i = 0; i &lt; length; i++) {	if (i === 1) {		break;	} else {		continue;	}}each循环则使用return true和return false$.each(arr, function (index, value) {	if (index == 1) {		return false;	} else {		return true;	}});]]></content>
      <categories>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> for </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript replace()实现全局替换]]></title>
      <url>/javascript/2017/01/20/Javascript-replace()%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E6%9B%BF%E6%8D%A2/</url>
      <content type="text"><![CDATA[  第一个参数需要用到正则表达式，/g 表示全局替换，否则只能替换第一个匹配项实现方式skill.replace(/a/g, "A");]]></content>
      <categories>
        
          <category> javascript </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript JSON 转换]]></title>
      <url>/javascript/json/2017/01/20/Javascript-JSON-%E8%BD%AC%E6%8D%A2/</url>
      <content type="text"><![CDATA[  javascript的JSON格式相互转换JSON 转字符串JSON.stringify(strJson);字符串转 JSON$.parseJSON(jsonStr);]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> json </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> json </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[HashMap和TreeMap]]></title>
      <url>/java/2017/01/17/HashMap%E5%92%8CTreeMap/</url>
      <content type="text"><![CDATA[介绍  Map是key-value的集合接口，其实现类包括：          HashMap - 值没有顺序      TreeMap - key值默认升序      LinkedHashMap - 值没有顺序      key排序Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(	new Comparator&lt;String&gt;() {		public int compare(String obj1, String obj2) {			// 降序排序			return obj2.compareTo(obj1);		}	});value排序// 这里将map.entrySet()转换成listList&lt;Map.Entry&lt;String,String&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet());	// 然后通过比较器来实现排序	Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,String&gt;&gt;() {		// 升序排序		public int compare(Entry&lt;String, String&gt; o1, Entry&lt;String, String&gt; o2) {			return o1.getValue().compareTo(o2.getValue());		}            	});]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> map </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[判断String是否为数字]]></title>
      <url>/java/2017/01/12/%E5%88%A4%E6%96%ADString%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E5%AD%97/</url>
      <content type="text"><![CDATA[  解决思路是通过正则表达式匹配字符串内容是否全部为数字实现方式// 数字0-9出现零到多次Pattern pattern = Pattern.compile("[0-9]*");Matcher isNum = pattern.matcher(str);if (isNum.matches()) {	// 数字} else {	// 非数字}]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> string </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Javascript数组去重]]></title>
      <url>/javascript/array/2017/01/09/Javascript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      <content type="text"><![CDATA[  Set是ES2015引入的数据类型，意为集合其不允许重复元素出现的特性，对于NaN、undefined、null都适用实现方式function unique(arr) {	var set = new Set(arr);		return Array.from(set);}var arr = [1,1,'1','1',0,0,'0','0',undefined,undefined,null,null,NaN,NaN,{},{},[],[],/a/,/a/];console.log(unique(arr));]]></content>
      <categories>
        
          <category> javascript </category>
        
          <category> array </category>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
          <tag> array </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Zip4j解压文件]]></title>
      <url>/java/2017/01/04/Zip4j%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6/</url>
      <content type="text"><![CDATA[  使用 zip4j 可以快速对文件进行解压缩处理官网zip4j特性  支持Zip文件的创建、添加、解压、更新、移除  可读写有密码保护的Zip文件  支持AES 128/256算法加密  支持标准Zip算法加密  支持Zip64格式  支持分块Zip文件的创建和解压  支持Unicode编码的文件名  支持进度监控添加Maven依赖&lt;dependency&gt;    &lt;groupId&gt;net.lingala.zip4j&lt;/groupId&gt;    &lt;artifactId&gt;zip4j&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;解压实现// 获取Zip文件ZipFile zipFile = new ZipFile(file);// 指定文件名编码zipFile.setFileNameCharset("GBK");// 验证文件有效性if (!zipFile.isValidZipFile()) {    responseData.setError("压缩文件已损坏！");    return;}// 解压目录File fileDir = new File(newFile);// 目录不存在则创建if (fileDir.isDirectory() &amp;&amp; !fileDir.exists()) {    fileDir.mkdir();}// 解压zipFile.extractAll(newFile);]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> zip </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[web.xml组件加载顺序]]></title>
      <url>/java/springmvc/tomcat/2016/12/29/web.xml%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
      <content type="text"><![CDATA[  context-param &gt; listener &gt; filter &gt; servlet 其中同类则按编写顺序执行常用组件解析&lt;web-app xmlns="" version=""&gt;	&lt;!-- 应用名称 --&gt;	&lt;display-name&gt;Bear&lt;/display-name&gt;	&lt;!-- 应用描述 --&gt;	&lt;description&gt;&lt;/description&gt;	&lt;!-- 应用范围内的初始化参数 --&gt;	&lt;context-param&gt;		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;		&lt;!-- 加载多个spring配置文件 --&gt;		&lt;param-value&gt;classpath*:/applicationContext.xml&lt;/param-value&gt;	&lt;/context-param&gt;	&lt;!-- 加载事件监听器，在建立、修改、删除会话或servlet环境时得到通知 --&gt;	&lt;listener&gt;		&lt;!-- 定义Spring监听器 --&gt;		&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;	&lt;/listener&gt;	&lt;!-- 加载过滤器，将一个名字与一个实现了javax.servlet.Filter接口的类关联 --&gt;	&lt;filter&gt;		&lt;!-- 过滤器名称 --&gt;		&lt;filter-name&gt;&lt;/filter-name&gt;		&lt;!-- 过滤器路径 --&gt;		&lt;filter-class&gt;&lt;/filter-class&gt;		&lt;!-- 初始化参数 --&gt;		&lt;init-param&gt;			&lt;!-- 参数名称 --&gt;			&lt;param-name&gt;&lt;/param-name&gt;			&lt;!-- 参数值 --&gt;			&lt;param-value&gt;&lt;/param-value&gt;		&lt;/init-param&gt;	&lt;/filter&gt;	&lt;!-- 如果命名了过滤器，则需要将其与一个或多个servlet或jsp页面关联 --&gt;	&lt;filter-mapping&gt;		&lt;!-- 过滤器名称 --&gt;		&lt;filter-name&gt;&lt;/filter-name&gt;		&lt;!-- 应用范围，所有 --&gt;		&lt;url-pattern&gt;/*&lt;/ulr-pattern&gt;	&lt;/filter-mapping&gt;	&lt;!-- 加载servlet，在向servlet或jsp页面指定初始化参数或URL时，必须先命名servlet或jsp页面 --&gt;	&lt;servlet&gt;		&lt;!-- servlet名称 --&gt;		&lt;servlet-name&gt;springServlet&lt;/servlet-name&gt;		&lt;!-- servlet路径 --&gt;		&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;		&lt;!-- 初始化参数 --&gt;		&lt;init-param&gt;			&lt;!-- 参数名称 --&gt;			&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;			&lt;!-- 参数值 --&gt;			&lt;param-value&gt;classpath*:spring-mvc.xml&lt;/param-value&gt;		&lt;/init-param&gt;		&lt;!-- 加载优先级 --&gt;		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;	&lt;/servlet&gt;	&lt;!-- 为指定的servlet提供缺省URL --&gt;	&lt;servlet-mapping&gt;		&lt;!-- servlet名称 --&gt;		&lt;servlet-name&gt;springServlet&lt;/servlet-name&gt;		&lt;!-- 应用范围 --&gt;		&lt;url-pattern&gt;/*&lt;/url-pattern&gt;	&lt;/servlet-mapping&gt;	&lt;!-- 会话配置 --&gt;	&lt;session-config&gt;		&lt;!-- 定义会话超时时间，会员未访问时间达到改配置，则会被服务器抛弃以节省内存 --&gt;		&lt;session-timeout&gt;30&lt;/session-timeout&gt;	&lt;/session-config&gt;	&lt;!-- 为特殊文件分配特定mime类型 --&gt;	&lt;mime-mapping&gt;&lt;/mime-mapping&gt;	&lt;!-- 应用首页入口文件列表 --&gt;	&lt;welcome-file-list&gt;&lt;/welcome-file-list&gt;	&lt;!-- 在返回特定http状态码或特定类型的异常抛出时，显示的页面 --&gt;	&lt;error-page&gt;		&lt;!-- 状态码 --&gt;		&lt;error-code&gt;404&lt;/error-code&gt;		&lt;!-- 显示页面 --&gt;		&lt;location&gt;404.jsp&lt;/location&gt;	&lt;/error-page&gt;	&lt;!-- 为标记库描述文件指定别名，可更改TLD文件的位置 ——&gt;	&lt;taglib&gt;&lt;/taglib&gt;	&lt;!-- 声明与资源相关的管理对象 --&gt; 	&lt;resource-env-ref&gt;&lt;/resource-env-ref&gt;	&lt;!-- 声明资源工厂使用的外部资源 --&gt;	&lt;resource-ref&gt;&lt;/resource-ref&gt;	&lt;!-- 指定待保护的URL，与location-config联合使用 --&gt;	&lt;security-constraint&gt;&lt;/security-constraint&gt;	&lt;!-- 指定服务器如何给试图访问受保护页面的用户授权，与security-constraint联合使用 --&gt;	&lt;login-config&gt;&lt;/login-config&gt;	&lt;!-- 安全角色列表 --&gt;	&lt;security-role&gt;&lt;/security-role&gt;	&lt;!-- 声明应用环境项 --&gt;	&lt;env-entry&gt;&lt;/env-entry&gt;&lt;/web-app&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> tomcat </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> tomcat </tag>
        
          <tag> server </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
