<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[SpringMVC多环境配置]]></title>
      <url>/java/springmvc/2018/07/23/SpringMVC%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  SpringMVC 可以使用 Spring 本身提供的 profile 特性对多环境配置文件进行统一集成，自动切换存在的必要  日常开发中，一般都存在多个环境，开发、测试、生产  上述环境对应的数据库及配置文件都会存在不同，所以为项目集成多环境配置很有必要实现方式  集成方式有多种，网上介绍的大多是使用 &lt;beans profile="dev"&gt; 去区分不同的 *.properties 文件  还可以使用 @Profile 进行不同环境代码加载  本文介绍的是使用 &lt;beans profile="dev"&gt; 直接在同一个 xml 文件中区分不同环境需要的不同配置项XML配置  注意如果使用了多环境的配置的 xml 文件中存在其他公有属性，这些属性需要放在最前面，否则会报错&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:p="http://www.springframework.org/schema/p"       xsi:schemaLocation="http://www.springframework.org/schema/beans            http://www.springframework.org/schema/beans/spring-beans-4.0.xsd"&gt;  &lt;description&gt;spring-data-redis-cluster&lt;/description&gt;  &lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt;    &lt;property name="maxIdle" value="${redis.pool.maxIdle}"/&gt;    &lt;property name="maxTotal" value="${redis.pool.maxActive}"/&gt;    &lt;property name="maxWaitMillis" value="${redis.pool.maxWait}"/&gt;    &lt;property name="testOnBorrow" value="${redis.pool.testOnBorrow}"/&gt;  &lt;/bean&gt;  ...  &lt;beans profile="dev"&gt;    &lt;bean id="jedisPool" class="redis.clients.jedis.JedisPool"&gt;      &lt;constructor-arg index="0" ref="jedisPoolConfig"/&gt;      &lt;constructor-arg index="1" value="${redis.server.url}"/&gt;      &lt;constructor-arg index="2" value="${redis.server.port}" type="int"/&gt;      &lt;constructor-arg index="3" value="${redis.server.timeout}" type="int"/&gt;      &lt;constructor-arg index="4" value="${redis.server.password}"/&gt;    &lt;/bean&gt;    &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt;      &lt;property name="hostName" value="${redis.server.url}"/&gt;      &lt;property name="port" value="${redis.server.port}"/&gt;      &lt;property name="password" value="${redis.server.password}"/&gt;      &lt;property name="poolConfig" ref="jedisPoolConfig"/&gt;    &lt;/bean&gt;  &lt;/beans&gt;  &lt;beans profile="prod"&gt;    &lt;bean id="redisClusterConfiguration" class="org.springframework.data.redis.connection.RedisClusterConfiguration"&gt;      ...    &lt;/bean&gt;    &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt;      &lt;constructor-arg ref="redisClusterConfiguration"/&gt;      &lt;constructor-arg ref="jedisPoolConfig"/&gt;    &lt;/bean&gt;  &lt;/beans&gt;&lt;/beans&gt;开发环境启动方式  IDEA 需要在启动时添加脚本 -Dspring.profiles.active="dev" 以确保使用开发环境启动生产环境启动方式  Linux 环境需要前往 Tomcat 的 /bin 目录下，需要 ./catalina.sh 中的 JAVA_OPTS 内容如下  JAVA_OPTS="$JAVA_OPTS -Dspring.profiles.active=prod"]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> profile </tag>
        
          <tag> spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot前后分离项目实现自定义登录拦截]]></title>
      <url>/java/springboot/shiro/2018/06/24/SpringBoot%E5%89%8D%E5%90%8E%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA/</url>
      <content type="text"><![CDATA[  通常的 shiro 登录拦截对于 /login 操作可设置为 authc 模式，但前后分离的项目直接设置会导致无法获取登录信息自定义登录拦截的实现  要实现自定义的登录拦截是继承 FormAuthenticationFilter 接口  对接口中的 onLoginSuccess 和 onLoginFailure 重写          从而根据登录成功和失败进行不同的操作记录      public class LoginFormAuthenticationFilter extends FormAuthenticationFilter {  // springBoot中存在与配置类的service类需要提供get/set方法手动收入，如果使用@Autowired会导致报错    private MemberLoginRecordServiceImpl memberLoginRecordService;    @Override    protected boolean onLoginSuccess(AuthenticationToken token, Subject subject, ServletRequest request, ServletResponse response) throws Exception {        // 处理会员登录成功操作        memberLoginRecordService.doAfterSuccessfullyLogin(request, subject);        return super.onLoginSuccess(token, subject, request, response);    }    @Override    protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) {        return super.onLoginFailure(token, e, request, response);    }    public MemberLoginRecordServiceImpl getMemberLoginRecordService() {        return memberLoginRecordService;    }    public void setMemberLoginRecordService(MemberLoginRecordServiceImpl memberLoginRecordService) {        this.memberLoginRecordService = memberLoginRecordService;    }}将重写的拦截器注入到 shiro 配置中@Configuration@ConditionalOnWebApplicationpublic class ShiroConfiguration extends BaseShiroConfiguration {  ...  	// 手动注入自定义拦截器需要用到的service  	// 注入该service即可，service内部的其他类可实现自动注入    @Bean    public MemberLoginRecordServiceImpl memberLoginRecordService() {        return new MemberLoginRecordServiceImpl();    }    public ShiroFilterFactoryBean shiroFilterFactoryBean(DefaultWebSecurityManager securityManager) throws Exception {        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();        shiroFilterFactoryBean.setSecurityManager(securityManager);  		// 指定登录链接        shiroFilterFactoryBean.setLoginUrl("/login");        Map&lt;String, Filter&gt; filters = new LinkedHashMap&lt;String, Filter&gt;();          		// 配置自定义表单拦截器        LoginFormAuthenticationFilter authcFilter = new LoginFormAuthenticationFilter();        authcFilter.setRememberMeParam("rememberMe");  		// 注入上述引用的service类        authcFilter.setMemberLoginRecordService(memberLoginRecordService());  		// 选择指定拦截器的规则        filters.put("authc", authcFilter);        shiroFilterFactoryBean.setFilters(filters);  		// 配置不同接口规则        Map&lt;String, String&gt; filterChainDefinitionMap = new LinkedHashMap&lt;String, String&gt;();  		// 登出操作由shiro管理        filterChainDefinitionMap.put("/logout", "anon");  		// 以下规则可直接访问        filterChainDefinitionMap.put("/api/portals/**", "anon");  		// 以下规则需要认证访问        filterChainDefinitionMap.put("/login", "authc");        filterChainDefinitionMap.put("/api/**", "authc");        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);        return shiroFilterFactoryBean;    }}以上方式在前后分离项目中会出现的问题  由于项目是前后分离的，前端发起的直接是访问 loginController 的请求  该请求由于配置了 authc 规则，则需要认证才能访问  所以就导致以上配置方式会直接报错  而如果将 /login 请求配置为 anon 规则，则会导致登录操作无法被自定义表单拦截器拦截解决方式  重写 FormAuthenticationFilter 接口的 onAccessDenied 方法  判断当前访问该规则的请求是否为登录请求  如果是登录请求则再次判断是否为登录提交请求 this.isLoginRequest          因为正常的登录请求中会存在一个访问登录页面和提交登录表单两个操作      而前后分离项目发起的必然是提交登录表单 this.isLoginSubmission        如果不是登录请求则返回 false@Overrideprotected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {    if (this.isLoginRequest(request, response) &amp;&amp; this.isLoginSubmission(request, response)) {        return true;    }    return false;}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> shiro </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> shiro </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot实现全局异常捕获]]></title>
      <url>/java/springboot/2018/06/07/SpringBoot%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</url>
      <content type="text"><![CDATA[  SpringBoot 对异常可以进行全局捕获，按照如下操作即可创建全局异常捕获器  @RestControllerAdvice 是对 @RestController 的加强          该注解是 Spring2.3 之后提供的新功能，主要用于对原生 Controller 做一些低侵入性的增加辅助      被该注解标注的类，其中的方法会被应用到 @RestController 中      作用与 @RestController 中被标注 @RequestMapping 的方法        @ExceptionHandler 是自定义错误处理器，使用时可以注明具体需要处理的错误类型          一般需要标注默认异常和自定义异常即可        该错误捕获方式是将所有错误向上一直抛出至 Spring 容器，由 Spring 自行处理          所以如果在之前进行了 try-catch 操作，会导致 Spring 无法捕获到该异常      @RestControllerAdvicepublic class GlobalExceptionHandler {    public Logger log = LoggerFactory.getLogger(getClass());    @ExceptionHandler(TSharkException.class)    public ResponseData handleTSharkException(TSharkException e) {        log.error(e.getMessage());        ResponseData responseData = new ResponseData();        responseData.setError(e.getMessage());        return responseData;    }    @ExceptionHandler(Exception.class)    public ResponseData handleException(Exception e) {        log.error(e.getMessage());        String exceptionMessage = "";        ResponseData responseData = new ResponseData();        if (e.getMessage().contains("rollback")) {            exceptionMessage = "数据已被关联或使用，无法删除！";        }        responseData.setError(exceptionMessage);        return responseData;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> exception </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate 双向关联转换 JSON 防止死循环]]></title>
      <url>/java/hibernate/2018/05/17/Hibernate-%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94%E8%BD%AC%E6%8D%A2-JSON-%E9%98%B2%E6%AD%A2%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
      <content type="text"><![CDATA[  Hibernate 中经常存在双向关联的情况，此处将数据转换为 JSON 格式则可能导致死循环获取数据时只需要单向关联  这种情况下父类需要子类数据，而子类不需要父类数据@Entity@Table(name = "ht_feedback_template")public class FeedbackTemplate extends BaseModel {    @OneToMany(mappedBy = "feedbackTemplate", cascade = {CascadeType.ALL}, fetch = FetchType.LAZY)    @OrderBy("indexNo asc")    private Set&lt;FeedbackQuestion&gt; questions;    public Set&lt;FeedbackQuestion&gt; getQuestions() {        return questions;    }    public void setQuestions(Set&lt;FeedbackQuestion&gt; questions) {        this.questions = questions;    }}  在子类中对父类的引用字段加上 @JsonIgnore 即可@Entity@Table(name = "ht_feedback_question")public class FeedbackQuestion extends BaseModel {    @ManyToOne    @JsonIgnore    private FeedbackTemplate feedbackTemplate;    public FeedbackTemplate getFeedbackTemplate() {        return feedbackTemplate;    }    public void setFeedbackTemplate(FeedbackTemplate feedbackTemplate) {        this.feedbackTemplate = feedbackTemplate;    }}获取数据时确实需要双向关联  在父类对子类的引用字段加上 @JsonManagedReference@Entity@Table(name = "ht_feedback_template")public class FeedbackTemplate extends BaseModel {    @OneToMany(mappedBy = "feedbackTemplate", cascade = {CascadeType.ALL}, fetch = FetchType.LAZY)    @OrderBy("indexNo asc")  @JsonManagedReference    private Set&lt;FeedbackQuestion&gt; questions;    public Set&lt;FeedbackQuestion&gt; getQuestions() {        return questions;    }    public void setQuestions(Set&lt;FeedbackQuestion&gt; questions) {        this.questions = questions;    }}  在子类中对父类的引用字段加上 @JsonBackReference 即可@Entity@Table(name = "ht_feedback_question")public class FeedbackQuestion extends BaseModel {    @ManyToOne  @JsonBackReference    private FeedbackTemplate feedbackTemplate;    public FeedbackTemplate getFeedbackTemplate() {        return feedbackTemplate;    }    public void setFeedbackTemplate(FeedbackTemplate feedbackTemplate) {        this.feedbackTemplate = feedbackTemplate;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate Criteria 模糊查询]]></title>
      <url>/java/hibernate/2018/05/14/Hibernate-Criteria-%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  使用 Hibernate 的 Criteria 可以快速进行模糊查询实现方式  进行模糊查询时需要指定匹配模式，否则会出现无搜索结果的情况，例如 MatchMode.ANYWHERE  如果匹配的条件设置到类的属性，需要使用 createAlias() 指定别名，否则会抛出无法找到 user.name 属性Criterion userCri = Restrictions.like("user.name", username, MatchMode.ANYWHERE);Criteria criteria = getSession().createCriteria(trainingCri, userCri);criteria.createAlias("user", "user", JoinType.LEFT_OUTER_JOIN);criteria.list();]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
          <tag> criteria </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate 执行 SQL 查询]]></title>
      <url>/java/hibernate/2018/05/12/Hibernate-%E6%89%A7%E8%A1%8C-SQL-%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  Hibernate 支持执行原生 SQL 查询实现方式  通过 Session 对象可以使用 createSQLQuery() 方法，传入原生 SQL 语句即可  参数格式为 paramName = :paramCodepublic List&lt;Dictionary&gt; getDictionaries(String categoryCode) {    SQLQuery sqlQuery = getSession().createSQLQuery("SELECT * FROM sys_dictionary WHERE CategoryCode = :categoryCode");    sqlQuery.addEntity(Dictionary.class);    sqlQuery.setParameter("categoryCode", categoryCode);    return sqlQuery.list();}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot通过jar包启动时MyBatis无法定位实体类]]></title>
      <url>/java/springboot/mybatis/error/2018/05/09/SpringBoot%E9%80%9A%E8%BF%87jar%E5%8C%85%E5%90%AF%E5%8A%A8%E6%97%B6MyBatis%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8D%E5%AE%9E%E4%BD%93%E7%B1%BB/</url>
      <content type="text"><![CDATA[  SpringBoot 通过 jar 包启动项目时，MyBatis 无法定位实体类，但通过 IDE 启动时没问题出现问题的原因  通过 jar 启动时，MyBatis 内部获得的路径不同，会导致无法根据配置文件指定的路径扫描到实体类  项目不是通过自动注入方式配置 MyBatis ，而是通过手动注入解决办法  在手动注入并指定实体类扫描路径之前，将 Spring 已经实例化的 VFS 提前指定@Bean@ConditionalOnMissingBean(SqlSessionFactoryBean.class)public SqlSessionFactory sqlSessionFactory(@Qualifier("druidDataSource") DataSource dataSource) throws Exception {    SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();    sqlSessionFactoryBean.setDataSource(dataSource);    sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(mapperLocations));  // 指定VFS确保可以扫描到实体类    sqlSessionFactoryBean.setVfs(SpringBootVFS.class);    sqlSessionFactoryBean.setTypeAliasesPackage(typeAliasesPackage);    return sqlSessionFactoryBean.getObject();}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> mybatis </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> mybatis </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot多环境配置]]></title>
      <url>/java/springboot/2018/05/09/SpringBoot%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  SpringBoot 在开发时可以配置多个环境进行便捷切换创建多个环境配置文件  首先需要创建多个对应的配置文件，如上图  然后在 application.yml 中通过如下语法进行匹配          项目启动时会根据指定的尾缀自动去匹配对应的配置文件      spring:  profiles:    active: dev项目打包实现动态指定配置文件  执行 java -jar xxx.jar  会直接按照默认配置进行打包  执行 java -jar xxx.jar --spring.profiles.active=test 则可以动态指定配置文件]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Maven打包时抛出should not point at files within the project directory …异常]]></title>
      <url>/java/maven/error/2018/05/09/Maven%E6%89%93%E5%8C%85%E6%97%B6%E6%8A%9B%E5%87%BAshould-not-point-at-files-within-the-project-directory-%E5%BC%82%E5%B8%B8/</url>
      <content type="text"><![CDATA[  项目中通过 Maven 引入本地包后打包时抛出 should not point at files within the project directory … 警告具体问题  在项目中引入本地包&lt;dependency&gt;    &lt;groupId&gt;ppts.model&lt;/groupId&gt;    &lt;artifactId&gt;ppts-model&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;scope&gt;system&lt;/scope&gt;    &lt;systemPath&gt;${basedir}/../lib/ppts-model-1.0-SNAPSHOT.jar&lt;/systemPath&gt;&lt;/dependency&gt;  在项目进行 package 打包时，抛出以下异常，且并没有引入对应 jar 包[WARNING] 'dependencies.dependency.systemPath' for ts.core:ts-core:jar should not point at files within the project directory, ${basedir}/../lib/ts-core-1.0.jar will be unresolvable by dependent projects @ line 97, column 19解决方式  移除本地包依赖中的 &lt;scope/&gt; 和 &lt;systemPath/&gt;&lt;dependency&gt;  &lt;groupId&gt;ppts.model&lt;/groupId&gt;  &lt;artifactId&gt;ppts-model&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;  通过 maven-install-plugin 插件对 jar 包进行安装          &lt;phase&gt;clean&lt;/phase&gt; 表示该 jar 包会在执行 clean 操作时引入      &lt;plugin&gt;  &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;  &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;  &lt;version&gt;2.5.2&lt;/version&gt;  &lt;executions&gt;    &lt;execution&gt;      &lt;id&gt;install-ppts-model&lt;/id&gt;      &lt;phase&gt;clean&lt;/phase&gt;      &lt;configuration&gt;        &lt;file&gt;${basedir}/../lib/ppts-model-1.0-SNAPSHOT.jar&lt;/file&gt;        &lt;repositoryLayout&gt;default&lt;/repositoryLayout&gt;        &lt;groupId&gt;ppts.model&lt;/groupId&gt;        &lt;artifactId&gt;ppts-model&lt;/artifactId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;packaging&gt;jar&lt;/packaging&gt;        &lt;generatePom&gt;true&lt;/generatePom&gt;      &lt;/configuration&gt;      &lt;goals&gt;        &lt;goal&gt;install-file&lt;/goal&gt;      &lt;/goals&gt;    &lt;/execution&gt;  &lt;/executions&gt;&lt;/plugin&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> maven </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> maven </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot集成ActiveMQ抛出java.lang.NoClassDefFoundError异常]]></title>
      <url>/java/springboot/springmvc/maven/error/2018/05/08/SpringBoot%E9%9B%86%E6%88%90ActiveMQ%E6%8A%9B%E5%87%BANoClassDefFoundError/</url>
      <content type="text"><![CDATA[  SpringBoot 在集成 JMS 及 ActiveMQ 时抛出 java.lang.NoClassDefFoundError: javax/jms/JMSContext 异常出现问题的原因  spring 5.0 以上版本不会自动导入 JMS 2.0 的依赖  但是 activemq-core 5.7  版本需要 JMS 2.0 的依赖解决办法  手动加入 JMS 2.0 依赖&lt;dependency&gt;    &lt;groupId&gt;javax.jms&lt;/groupId&gt;    &lt;artifactId&gt;javax.jms-api&lt;/artifactId&gt;    &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;  在 activemq-core 5.7 中移除低版本的默认引入&lt;dependency&gt;    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;    &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;    &lt;version&gt;5.7.0&lt;/version&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;/exclusion&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.apache.geronimo.specs&lt;/groupId&gt;            &lt;artifactId&gt;geronimo-jms_1.1_spec&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> springmvc </category>
        
          <category> maven </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> springmvc </tag>
        
          <tag> maven </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot+IDEA热部署]]></title>
      <url>/java/springboot/software/2018/04/18/SpringBoot+IDEA%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      <content type="text"><![CDATA[  SpringBoot 自身有提供插件可实现代码热部署IDEA 相关配置  开启项目自动构建代码相关配置  pom 中加入以下依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;  扩展 spring-boot-maven-plugin 的插件配置项&lt;build&gt;    &lt;finalName&gt;mop&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;configuration&gt;                &lt;!-- 如果没有该项配置devtools不会起作用，即应用不会restart --&gt;                &lt;fork&gt;true&lt;/fork&gt;                &lt;!-- 支持静态文件热部署 --&gt;                &lt;addResources&gt;true&lt;/addResources&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> software </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> intellij </tag>
        
          <tag> idea </tag>
        
          <tag> software </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot集成Swagger]]></title>
      <url>/java/springboot/swagger/2018/04/17/SpringBoot%E9%9B%86%E6%88%90Swagger/</url>
      <content type="text"><![CDATA[  Swagger 是一款目前世界最流行的API管理工具官网  Swagger  Swagger Annotation集成步骤  在项目 pom 中引入以下依赖&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.springfox&lt;/groupId&gt;    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;  在项目中配置 Swagger@Configuration@EnableSwagger2public class SwaggerConfig {    @Bean    public Docket api() {        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()).select().apis(RequestHandlerSelectors.any()).paths(or(regex("/api/.*"))).build();    }    private ApiInfo apiInfo() {        return new ApiInfoBuilder().title("轻实训-移动端 API").version("1.0").build();    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> swagger </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> swagger </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot抛出ContextPath must start with xx and not end with xx异常]]></title>
      <url>/java/springboot/error/2018/04/17/SpringBoot%E6%8A%9B%E5%87%BAContextPath-must-start-with-xx-and-not-end-with-xx/</url>
      <content type="text"><![CDATA[  该异常属于项目配置的根路径出错解决问题的办法  在 application.yml 中将 server.servlet.context-path 设置的路径前加一个 /server:  servlet:    context-path: /api]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot启动抛出Unregistering JMX-exposed beans on shutdown异常]]></title>
      <url>/java/springboot/error/2018/04/16/SpringBoot%E5%90%AF%E5%8A%A8%E6%8A%9B%E5%87%BAUnregistering-JMX-exposed-beans-on-shutdown/</url>
      <content type="text"><![CDATA[  在配置 SpringBoot 项目时可能会抛出 Unregistering JMX-exposed beans on shutdown异常抛出错误的原因  是因为以下依赖的 scope 为 provided 导致的&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;解决的办法  将 provided 改为 compile 即可&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;    &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 实现阿里云直播推流在线列表查询]]></title>
      <url>/java/aliyun/2018/04/12/Java-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%9C%A8%E7%BA%BF%E5%88%97%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  阿里云直播推流在线列表可以通过 API 的方式进行查询获取官网查询推流在线列表初始化配置  Constants.ALI_ACCESS_KEY_ID 是阿里云服务密钥 id ，所有服务共用  Constants.ALI_ACCESS_SECRET 是阿里云服务密钥，所有服务共用  将客户端的初始化放置在静态块中可以保证配置只初始化一次private static IAcsClient iAcsClient;static {    // 初始化配置    String regionId = "cn-shanghai";    DefaultProfile profile = DefaultProfile.getProfile(regionId, Constants.ALI_ACCESS_KEY_ID, Constants.ALI_ACCESS_SECRET);    iAcsClient = new DefaultAcsClient(profile);    // 本地调试    // System.setProperty("http.proxyHost", "127.0.0.1");    // System.setProperty("http.proxyPort", "8080");}查询推流在线列表  Constants.ALI_LIVE_PULL_URL 是阿里云直播的推流地址  Constants.ALI_LIVE_APP_NAME 是阿流云直播的应用名称          如果不指定，则会查询出所有的应用的推流列表      只能是单纯的应用名称，和阿里云直播控制台设置的保持一直        获取到推流在线列表后，只需要进行流名称的匹配即可public Boolean checkLiveBegin(String streamName) {    // 查询推流在线列表    DescribeLiveStreamsOnlineListRequest listRequest = new DescribeLiveStreamsOnlineListRequest();    listRequest.setDomainName(Constants.ALI_LIVE_PULL_URL);    listRequest.setAppName(Constants.ALI_LIVE_APP_NAME.replace("/", ""));    try {        DescribeLiveStreamsOnlineListResponse response = iAcsClient.getAcsResponse(listRequest);        // 获取当前推流列表        List&lt;LiveStreamOnlineInfo&gt; onlineInfos = response.getOnlineInfo();        for (LiveStreamOnlineInfo onlineInfo : onlineInfos) {            if (onlineInfo.getStreamName().equals(streamName)) {                return true;            }        }    } catch (ClientException e) {        logger.error("获取拉流信息失败！", e);    }    return false;}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> aliyun </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> aliyun </tag>
        
          <tag> live </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java支付宝订单查询]]></title>
      <url>/java/pay/2018/04/01/Java-%E6%94%AF%E4%BB%98%E5%AE%9D%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  电脑网站支付成功后可通过支付宝接口主动查询订单结果前置条件  该方法基于 Java 支付宝扫码支付 (新) 实现调用查询接口进行订单查询public class AliQueryServiceImpl extends AliCoreServiceImpl {    public Boolean getPayResult(Long orderId) {        AlipayTradeQueryRequest queryRequest = new AlipayTradeQueryRequest();        queryRequest.setBizModel(generateOrderInfo(orderId));        AlipayTradeQueryResponse response = null;        try {            response = alipayClient.execute(queryRequest);        } catch (AlipayApiException e) {            logger.error("支付宝查询订单" + orderId + "失败！", e);        }        if (response == null) {            logger.error("支付宝未获取订单" + orderId + "详情！");            return false;        }        if (response.isSuccess()) {            if (response.getTradeStatus().equals(TRADE_STATUS_SUCCESS) || response.getTradeStatus().equals(TRADE_STATUS_FINISHED)) {                // 更新订单状态                updateOrderInfo(response.getOutTradeNo(), OrderPay.aliPay.getCode());                return true;            }            logger.error("支付宝订单" + orderId + "交易失败，交易状态：" + response.getTradeStatus());            return false;        } else {            logger.error("支付宝订单" + orderId + "查询失败！");            return false;        }    }    private AlipayTradeQueryModel generateOrderInfo(Long orderId) {        OrderDTO order = orderManageService.getOrder(orderId);        AlipayTradeQueryModel model = new AlipayTradeQueryModel();        model.setOutTradeNo(order.getCode());        return model;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java支付宝扫码支付[新]]]></title>
      <url>/java/pay/2018/03/31/Java-%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98-%E6%96%B0/</url>
      <content type="text"><![CDATA[  支付宝老版本的 Web 端扫码支付产品为即时到账，更新到新版后现在的产品为电脑网站支付官网电脑网站支付快速接入准备数据  电脑网站支付 应用需要在开发者页面端进行申请和签约  应用签约成功之后需要获取以下信息          app_id: 签约成功的应用唯一标识      app_private_key: 通过 RSA 密钥生成的应用私钥，由开发者自己通过签名软件生成[支付宝提供]      alipay_public_key: 通过应用私钥和公钥生成的支付宝公钥，由支付宝自动生成      下载 Java 版 SDK  前往 电脑网站支付 SDK 获取 下载 Java 的 SDK  该 SDK 目前不支持 Maven 方式引入，只能通过本地引入  正常开发模式只需要引入 alipay-sdk-java-3.0.0.jar 即可获取支付宝客户端  支付宝客户端是调用所有接口的前置条件，所以应该放置在顶层父类做一次初始化  SOPConstants.ALI_PAY_SEND_URL 是该支付方式的统一请求接口，值为 https://openapi.alipay.com/gateway.dopublic class AliCoreServiceImpl extends OrderCoreServiceImpl {    // 参数返回格式    private static final String ALI_PAY_FORMAT = "json";    // 编码集，支持 GBK/UTF-8    protected static final String ALI_PAY_CHARSET = "utf-8";    // 商户生成签名字符串所使用的签名算法类型，目前支持 RSA2/RSA ，推荐使用 RSA2    protected static final String ALI_PAY_SIGN_TYPE = "RSA2";    // 订单支付成功状态    protected static final String TRADE_STATUS_SUCCESS = "TRADE_SUCCESS";    // 订单支付结束状态    protected static final String TRADE_STATUS_FINISHED = "TRADE_FINISHED";    // 支付宝客户端    protected static AlipayClient alipayClient;    static {        // 初始化支付宝客户端        alipayClient = new DefaultAlipayClient(                SOPConstants.ALI_PAY_SEND_URL,                SOPConstants.ALI_PAY_APP_ID,                SOPConstants.ALI_PAY_PRIVATE_KEY,                ALI_PAY_FORMAT,                ALI_PAY_CHARSET,                SOPConstants.ALI_PAY_PUBLIC_KEY,                ALI_PAY_SIGN_TYPE);    }}发起支付宝付款页面请求  新版的扫码支付对请求参数和响应参数都做了封装，只需要传入对应参数值即可  SOPConstants.ALI_PAY_RETURN_URL 是支付宝付款成功需要的同步回执地址  SOPConstants.ALI_PAY_NOTIFY_URL 是支付宝付款成功需要的异步回执地址  以上两个地址都需要能够外网访问  该请求方式是通过拼接请求使用 iframe 获取支付宝的付款二维码          通过客户端发起请求时不使用一般的 pageExecute() 而使用 sdkExecute()      sdkExecute() 获取的是请求之后的参数值，所以还需要拼接请求地址      SOPConstants.ALI_PAY_SEND_URL 是支付请求地址      public class AliPayServiceImpl extends AliCoreServiceImpl {    public String aliPay(Long orderId) {        // 创建统一下单请求        AlipayTradePagePayRequest payRequest = new AlipayTradePagePayRequest();        payRequest.setReturnUrl(SOPConstants.ALI_PAY_RETURN_URL);        payRequest.setNotifyUrl(SOPConstants.ALI_PAY_NOTIFY_URL);        // 将订单详情传入业务请求参数中        payRequest.setBizModel(generateOrderInfo(orderId));        String body = null;        try {            body = alipayClient.sdkExecute(payRequest).getBody();        } catch (AlipayApiException e) {            logger.error("订单" + orderId + "获取支付宝付款界面失败！");        }        if (body == null) {            logger.error("订单" + orderId + "未成功获取支付宝付款界面！");        }        return SOPConstants.ALI_PAY_SEND_URL + "?" + body;    }    private AlipayTradePagePayModel generateOrderInfo(Long orderId) {        // 获取订单信息        OrderDTO order = orderManageService.getOrder(orderId);        AlipayTradePagePayModel model = new AlipayTradePagePayModel();        model.setOutTradeNo(order.getCode());        model.setProductCode("FAST_INSTANT_TRADE_PAY");        model.setTotalAmount(String.valueOf(order.getPrice()));        model.setSubject("实训在线-" + order.getName());        model.setBody("实训在线-" + order.getName());        // 二维码获取方式为模式4，最简洁模式，只有二维码        model.setQrPayMode("4");        model.setQrcodeWidth(240L);        return model;    }}  控制层调用请求接口获取完整请求地址@RequestMapping("/ali/{orderId}")public String ali(Model model, @PathVariable String orderId) {    model.addAttribute("order", orderManageService.getOrder(IdEncoder.decodeId(orderId)));    model.addAttribute("orderType", OrderPay.aliPay.getCode());    model.addAttribute("aliPayUrl", aliPayService.aliPay(IdEncoder.decodeId(orderId)));    return "/order/pay/ali";}  上述方法中拼接完整的二维码请求地址可以直接放置到 iframe 的 src 属性中          如果页面没有成功获取，可根据报错信息前往 验签失败错误排查 进行解决      &lt;iframe id="aliPayFrame" src="${aliPayUrl}" frameborder="0"&gt;&lt;/iframe&gt;接收同步回执  该地址需要与之前初始化客户端时提交给支付宝的同步回执地址保持一致  回执地址不能有任何多余参数@RequestMapping("/ali/return")public String aliReturn(HttpServletRequest request) {    aliNotifyService.aliReturn(request);    return null;}  新版的同步回执中不会携带订单的状态信息，所以只能用做一般的信息接收，不能做为交易成功的依据          同步回执需要验签，但验签的方法支付宝已提供，即 AlipaySignature.rsaCheckV2()      public void aliReturn(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    Boolean result = false;    try {        // 回执验签        result = AlipaySignature.rsaCheckV2(parameterToMap(request, false), SOPConstants.ALI_PAY_PUBLIC_KEY, ALI_PAY_CHARSET, ALI_PAY_SIGN_TYPE);    } catch (AlipayApiException e) {        logger.error("支付宝订单" + orderCode + "同步回执验签失败！", e);    }    if (result) {        logger.info("支付宝订单" + orderCode + "同步回执接收成功！");    } else {        logger.error("支付宝订单" + orderCode + "同步回执无效！");    }}  对同步回执中的响应参数验签之前，需要先将参数转化为 map 形式private Map&lt;String, String&gt; parameterToMap(HttpServletRequest request, Boolean isNotify) {    // 获取回执内容    Map requestParams = request.getParameterMap();    // 过滤回执内容    Map&lt;String, String&gt; params = Maps.newHashMap();    for (Object o : requestParams.keySet()) {        String name = (String) o;        String[] values = (String[]) requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        if (isNotify) {            params.put(name, valueStr);        } else {            try {                params.put(name, new String(valueStr.getBytes("ISO-8859-1"), "utf-8"));            } catch (UnsupportedEncodingException e) {                logger.error("支付宝订单同步回执转码失败！", e);            }        }    }    return params;}接收异步回执  该地址需要与之前初始化客户端时提交给支付宝的异步回执地址保持一致  回执地址不能携带任何参数@RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic String aliNotify(HttpServletRequest request) {    return aliNotifyService.aliNotify(request);}  异步回执作为支付成功的依据，支付宝成功通知到本地后，需要明确告知支付宝交易已成功          交易成功后返回 success 即可      当订单支付成功后订单可以展现两种状态，TRADE_SUCCESS 或 TRADE_FINISHED      public String aliNotify(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 订单状态    String orderStatus = request.getParameter("trade_status");    boolean result = false;    try {        result = AlipaySignature.rsaCheckV2(parameterToMap(request, true), SOPConstants.ALI_PAY_PUBLIC_KEY, ALI_PAY_CHARSET, ALI_PAY_SIGN_TYPE);    } catch (AlipayApiException e) {        logger.error("支付宝订单" + orderCode + "异步回执验签失败，订单状态为：" + orderStatus + "！", e);    }    // 验签成功    if (result) {        // 订单已支付        if (orderStatus.equals(TRADE_STATUS_SUCCESS) || orderStatus.equals(TRADE_STATUS_FINISHED)) {            // 更新订单状态            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());            return "success";        } else {            logger.error("支付宝订单" + orderCode + "未支付，订单状态为：" + orderStatus + "！");            return "fail";        }    } else {        logger.error("支付宝订单" + orderCode + "异步回执接收失败，订单状态为：" + orderStatus + "！");        return "fail";    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java微信订单查询]]></title>
      <url>/java/pay/2018/03/31/Java-%E5%BE%AE%E4%BF%A1%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2/</url>
      <content type="text"><![CDATA[  Java 通过统一下单 API 进行订单支付后，除等待微信通过 notify_url 进行回调通知外，还可以主动查询订单状态前置条件可参考 Java 微信扫码支付 如果实现微信支付官网【微信支付】扫码支付开发者文档定义请求参数对象  订单查询请求参数（必填）public class QueryOrderRequest {    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 商户订单号，32位以内，不重复    private String out_trade_no;    // 随机字符串，32位以内    private String nonce_str;    // 签名，遵循签名算法    private String sign;}  查询订单请求参数（非必填）public class QueryOrderRequestExt extends QueryOrderRequest {    // 签名类型，默认MD5    private String sign_type;}定义接收参数对象  查询订单接收参数（必填）public class QueryOrderResponse {    // 返回状态码，通信标识，SUCCESS/FAIL    private String return_code;    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 随机字符串    private String nonce_str;    // 签名    private String sign;    // 业务结果，交易标识，SUCCESS/FAIL    private String result_code;    // 用户标识    private String openid;    // 交易类型，JSAPI，NATIVE，APP    private String trade_type;    // 交易状态，SUCCESS-成功 USERPAYING-支付中    private String trade_state;    // 付款银行    private String bank_type;    // 标价金额，单位分    private int total_fee;    // 现金支付金额    private int cash_fee;    // 微信支付订单号    private String transaction_id;    // 商户订单号    private String out_trade_no;    // 支付完成时间    private String time_end;    // 交易状态描述    private String trade_state_desc;}  查询订单接收参数（非必填）public class QueryOrderResponseExt extends QueryOrderResponse {    // 返回信息，非空则表示返回了错误信息    private String return_msg;    // 错误代码    private String err_code;    // 错误代码描述    private String err_code_des;    // 设备号    private String device_info;    // 是否关注公众号    private String is_subscribe;    // 应结订单金额    private String settlement_total_fee;    // 标价币种    private String fee_type;    // 现金支付币种    private String cash_fee_type;    // 附加数据    private String attach;}生成订单信息  SOPConstants.WECHAT_PAY_APP_ID 是公众账号 id  SOPConstants.WECHAT_PAY_MCH_ID 是商户id  WechatUtil.makeNonceStr() 是生成的随机字符串  WechatUtil.makeSign(BeanMap.create(ext)) 是根据请求参数制作签名  WechatUtil.truncateDataToXML(QueryOrderRequestExt.class, ext) 是将数据转换为 XML 形式private String generateOrderInfo(Long orderId) {    OrderDTO order = orderManageService.getOrder(orderId);    QueryOrderRequestExt ext = new QueryOrderRequestExt();    ext.setAppid(SOPConstants.WECHAT_PAY_APP_ID);    ext.setMch_id(SOPConstants.WECHAT_PAY_MCH_ID);    ext.setOut_trade_no(order.getCode());    ext.setNonce_str(WechatUtil.makeNonceStr());    ext.setSign(WechatUtil.makeSign(BeanMap.create(ext)));    return WechatUtil.truncateDataToXML(QueryOrderRequestExt.class, ext);}向微信发起订单查询请求  SOPConstants.WECHAT_PAY_QUERY_URL 是微信订单查询的请求 URL  WechatConnection.connect() 是向微信发起请求的通用方法  只有 ext.getResult_code() ext.getResult_code()  ext.getTrade_state() 的值都是 SUCCESS 才能确定订单支付成功public Boolean getPayResult(Long orderId) {    String orderInfo = generateOrderInfo(orderId);    QueryOrderResponseExt ext = null;    try {        ext = (QueryOrderResponseExt) WechatConnection.connect(SOPConstants.WECHAT_PAY_QUERY_URL, orderInfo, QueryOrderResponseExt.class);    } catch (IOException e) {        logger.error("微信查询订单" + orderId + "失败！", e);    }    if (ext == null) {        return false;    }    if (WechatConnection.SUCCESS_CODE.equals(ext.getResult_code())) {        if (WechatConnection.SUCCESS_CODE.equals(ext.getResult_code()) &amp;&amp; WechatConnection.SUCCESS_CODE.equals(ext.getTrade_state())) {            // 更新订单状态            orderPayService.updateOrderInfo(ext.getOut_trade_no(), OrderPay.wchatPay.getCode());            return true;        } else {            logger.error("订单" + orderId + "交易失败，交易状态：" + ext.getTrade_state());            return false;        }    } else {        logger.error("订单" + orderId + "查询失败！");        return false;    }}微信支付相关操作工具类  该工具类目前提供了数据转换、签名生成、随机数生成的通用方法public class WechatUtil {    private static Logger logger = LoggerFactory.getLogger(WechatUtil.class);    /**     * 数据转换为xml格式     *     * @param object     * @param obj     * @return     */    public static String truncateDataToXML(Class&lt;?&gt; object, Object obj) {        XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));        xStream.alias("xml", object);        return xStream.toXML(obj);    }    /**     * 数据转换为对象     *     * @param object     * @param str     * @return     */    public static Object truncateDataFromXML(Class&lt;?&gt; object, String str) {        XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));        xStream.alias("xml", object);        return xStream.fromXML(str);    }    /**     * 生成随机字符串     *     * @return     */    public static String makeNonceStr() {        StringBuffer str = new StringBuffer(DateUtil.getSysDateString("yyyyMMddHHmmssS"));        str.append((new Random().nextInt(900) + 100));        return str.toString();    }    /**     * 拼接签名数据     *     * @return     */    public static String makeSign(BeanMap beanMap) {        SortedMap&lt;String, String&gt; signMaps = Maps.newTreeMap();        for (Object key : beanMap.keySet()) {            Object value = beanMap.get(key);            // 排除空数据            if (value == null) {                continue;            }            signMaps.put(key + "", String.valueOf(value));        }        // 生成签名        return generateSign(signMaps);    }    /**     * 生成签名     *     * @param signMaps     * @return     * @throws Exception     */    public static String generateSign(SortedMap&lt;String, String&gt; signMaps) {        StringBuffer sb = new StringBuffer();        // 字典序        for (Map.Entry signMap : signMaps.entrySet()) {            String key = (String) signMap.getKey();            String value = (String) signMap.getValue();            // 为空不参与签名、参数名区分大小写            if (null != value &amp;&amp; !"".equals(value) &amp;&amp; !"sign".equals(key) &amp;&amp; !"key".equals(key)) {                sb.append(key).append("=").append(value).append("&amp;");            }        }        // 拼接key        sb.append("key=").append(SOPConstants.WECHAT_PAY_KEY);        // MD5加密        return Objects.requireNonNull(encoderByMd5(sb.toString())).toUpperCase();    }    /**     * 利用MD5进行加密     *     * @param str 待加密的字符串     * @return 加密后的字符串     */    private static String encoderByMd5(String str) {        // 生成一个MD5加密计算摘要        MessageDigest md = null;        try {            md = MessageDigest.getInstance("MD5");        } catch (NoSuchAlgorithmException e) {            logger.error("MD5加密失败！", e);        }        if (md == null) {            return null;        }        // 计算md5函数        md.update(str.getBytes());        // digest()最后确定返回md5 hash值，返回值为8为字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符        // BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值        return new BigInteger(1, md.digest()).toString(16);    }}微信支付请求建立类public class WechatConnection {    // 成功标志    public static final String SUCCESS_CODE = "SUCCESS";    /**     * 建立微信连接，并返回结果     *     * @param url     * @param info     * @param object     * @return     * @throws IOException     */    public static Object connect(String url, String info, Class&lt;?&gt; object) throws IOException {        // 建立连接        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();        conn.setConnectTimeout(8000);        conn.setRequestMethod("POST");        conn.setDoOutput(true);        // 发送数据        BufferedOutputStream bos = new BufferedOutputStream(conn.getOutputStream());        bos.write(info.getBytes());        bos.flush();        bos.close();        // 获取数据        BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));        // 接收数据        String line;        StringBuffer str = new StringBuffer();        while ((line = reader.readLine()) != null) {            str.append(line);        }        return WechatUtil.truncateDataFromXML(object, str.toString());    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> wechatpay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[BeanMap 实现对象转换 Map]]></title>
      <url>/java/map/2018/03/31/BeanMap-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2-Map/</url>
      <content type="text"><![CDATA[  通过 org.springframework.cglib.beans 的 BeanMap 可以实现对象将字段和字段值直接转换为 Map 的 key-value 形式实现方式SortedMap&lt;String, String&gt; signMaps = Maps.newTreeMap();BeanMap beanMap = BeanMap.create(ext);for (Object key : beanMap.keySet()) {    Object value = beanMap.get(key);    // 排除空数据    if (value == null) {        continue;    }    signMaps.put(key + "", String.valueOf(value));}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> map </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> map </tag>
        
          <tag> spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 实现阿里云直播]]></title>
      <url>/java/jquery/aliyun/2018/03/19/Java-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%B4%E6%92%AD/</url>
      <content type="text"><![CDATA[  阿里云播放器直接在线点播视频以及直播技术，此处记录直播实现过程官网阿里云直播-快速入门 准备步骤  创建 阿里云账号  根据 流程 完成实名认证，以确保可以使用阿里云相应服务  在密钥管理页面获取阿里云访问密钥，AccessKeyId 和 AccessKeySecret  开通阿里云直播服务关键点  阿里云直播服务端提供了 一系列 API ，但如果只是单纯的直播[推流和拉流] ，实际不需要使用这些 API推流准备  推流即直播人员进行视频播放的操作，这需要使用推流客户端 第三方推流工具 OBS  在推流工具中需要指定推流地址、流名称、鉴权密钥  如果上述信息阿里云验证合法，既可以开始直播，在阿里云后端可以看到正在直播的流信息拉流准备  拉流即直播观众通过视频播放器在线获取直播信息，播放器使用 阿里云播放器 即可，该播放器目前只是阿里云的点播和直播服务  获取拉流地址后传入播放器，即可开始观看直播Java 开发注意点  在阿里云直播的文档中有提供 Java SDK          目前 SDK 中推荐引入的版本号是 2.3.0 ，但其实所有 API 参照的都是最新版 SDK ，最新的版本号可在 阿里云SDK频道 找到        但如果只是单纯的直播[推流和拉流] ，则不需要进行以上操作  推流的关键点在于 直播鉴权          此处介绍的直播鉴权只是说的 auth_key 的拼接和验证规则      完整的推流和拉流地址并不知这些，需要依旧案例参考      获取推流地址  此处获取的只是推流地址的房间号及其他请求参数  完整的推流地址需要加上阿里云直播中心地址和用户的产品名称          直播中心地址 http://video-center.alivecdn.com      产品名称[支持自定义] /appName/        vhost 用于接收拉流地址，即申请阿里云直播时准备的直播域名  此处使用 Java MD5加密 实现字串加密，加密后长度需要是 32 位  加密串中的 Constants.ALI_LIVE_PRIVATE_KEY  可在阿里云后端的直播鉴权处获取// 获取推流地址public String getPushUri(String roomName, Long endTime) {    return getRoomName(roomName) + "vhost=" + Constants.ALI_LIVE_PULL_URL + "&amp;" + generateAuthKey(roomName, endTime);}// 房间号private String getRoomName(String roomName) {    return roomName + "?";}// 完整验签串private String generateAuthKey(String roomName, Long endTime) {    return "auth_key=" + endTime + generateUuid() + generateEncryptStr(roomName, endTime);}// 唯一标识private String generateUuid() {    String uuid = "0";    String uid = "0";    return "-" + uuid + "-" + uid + "-";}// 验签密钥private String generateEncryptStr(String roomName, Long endTime) {    String uri = Constants.ALI_LIVE_APP_NAME + roomName;    return md5(uri + "-" + endTime + generateUuid() + Constants.ALI_LIVE_PRIVATE_KEY);}获取拉流地址  此处获取的拉流地址是完整的，因为拉流地址是直接获取后传入前端的阿里云播放器中  注意房间名后面加的后缀 .m3u8 用于表示接受的直播视频类型，阿里云官方还提供其他几种类型，可在文档中查看  拉流地址和推流地址最大的区别在于请求地址的不同，拉流是请求自己提供给阿里云的直播域名，而拉流是请求阿里云的直播中心  而且推流时需要指定 vhost 告知阿里云直播域名，但拉流时不需要  获取到拉流地址后可直接参照 Java + jQuery 实现阿里云播放器接口 实现播放器的对接          在播放器的的配置中指明 isLive: true 表名是直播操作      上述笔记中实现的是点播接口，利用的通过 vid 获取 playAuth 的方式，这不适用于直播      直播需要直接指定 source: url 即可      public String getPullUrl(String roomName, Long endTime) {    roomName += ".m3u8";    return "http://" + Constants.ALI_LIVE_PULL_URL + generateUri(roomName) + generateAuthKey(roomName, endTime);}// 获取请求参数private String generateUri(String roomName) {	return Constants.ALI_LIVE_APP_NAME + getRoomName(roomName);}// 房间号private String getRoomName(String roomName) {    return roomName + "?";}// 完整验签串private String generateAuthKey(String roomName, Long endTime) {    return "auth_key=" + endTime + generateUuid() + generateEncryptStr(roomName, endTime);}// 唯一标识private String generateUuid() {    String uuid = "0";    String uid = "0";    return "-" + uuid + "-" + uid + "-";}// 验签密钥private String generateEncryptStr(String roomName, Long endTime) {    String uri = Constants.ALI_LIVE_APP_NAME + roomName;    return md5(uri + "-" + endTime + generateUuid() + Constants.ALI_LIVE_PRIVATE_KEY);}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> jquery </category>
        
          <category> aliyun </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> jquery </tag>
        
          <tag> aliyun </tag>
        
          <tag> player </tag>
        
          <tag> live </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 实现阿里云短信]]></title>
      <url>/java/aliyun/2018/03/11/Java-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1/</url>
      <content type="text"><![CDATA[  阿里云提供一套短信发送的服务可通过 Java 进行对接官网短信发送API(SendSms)—阿里云准备步骤  创建 阿里云账号  根据 流程 完成实名认证，以确保可以使用阿里云相应服务  在密钥管理页面获取阿里云访问密钥，AccessKeyId 和 AccessKeySecret  想要成功发送一条短信需要获取 短信签名 和 短信模版在项目 pom 中引入对接所需要的 jar 包&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;    &lt;version&gt;3.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt;    &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;获取对接需要的数据  将 AccessKeyId 、AccessKeySecret 、SignName 、TemplateCode 进行相应存储新建 MessageServiceImpl 类用于和阿里云短信接口对接@Servicepublic class MessageServiceImpl extends AbstractBaseService {		...}在上述类中生成一个静态块用于在初始化对接信息  Constants.ALI_ACCESS_KEY_ID 和 Constants.ALI_ACCESS_SECRET 是密钥，成对生成和使用  其他参数信息按照阿里云开发手册说明，均不需要改变// 用于从阿里云获取数据的权限客户端private static IAcsClient iAcsClient;static {    // 超时时间    System.setProperty("sun.net.client.defaultConnectTimeout", "10000");    System.setProperty("sun.net.client.defaultReadTimeout", "10000");    // 初始化配置    String regionId = "cn-hangzhou";    DefaultProfile profile = DefaultProfile.getProfile(regionId, Constants.ALI_ACCESS_KEY_ID, Constants.ALI_ACCESS_SECRET);    try {        String productId = "Dysmsapi";        String domain = "dysmsapi.aliyuncs.com";        DefaultProfile.addEndpoint(regionId, regionId, productId, domain);    } catch (ClientException e) {        throw new TSharkException("初始化短信接口配置失败！", e);    }    // 初始化权限客户端    iAcsClient = new DefaultAcsClient(profile);}创建用于发送短信的 sendMessage 方法  发送短信之前通常需要验证短信是否已发送，防止重复发送  为了验证短信是否发送可将通过短信发送的验证码存放于 Redis 中  Constants.ALI_MESSAGE_SIGN_NAME 是从阿里云获取的短信签名  为提高公用性，发送短信的方法支持从外部调用时传入具体模版编号  短信接口调用时如果出现异常反馈，请参照 短信接口调用错误码@Autowiredprivate RedisHelper redisHelper;public Boolean sendMessage(String mobile, String template) {    // 有效性验证    if (checkMobile(mobile)) {        throw new TSharkException("验证码已发送，请稍后再试！");    }    SendSmsRequest request = new SendSmsRequest();    SendSmsResponse response = null;    // 生成随机数    String random = String.valueOf(new Random().nextInt(999999));    request.setMethod(MethodType.POST);    request.setPhoneNumbers(mobile);    request.setSignName(Constants.ALI_MESSAGE_SIGN_NAME);    request.setTemplateCode(template);    request.setTemplateParam("{\"name\":\"" + mobile + "\", \"code\":\"" + random + "\"}");    try {        response = iAcsClient.getAcsResponse(request);    } catch (ClientException e) {        throw new TSharkException("接收短信回执失败！", e);    }    boolean result = response.getCode() != null &amp;&amp; response.getCode().equals("OK");    if (result) {        // 保存随机数        saveRandom(mobile, random);    }    return result;}通过 Redis 验证短信是否发送private Boolean checkMobile(String mobile) {    String randomKey = "random:" + mobile;    return redisHelper.get(randomKey) != null;}短信发送成功后需要将手机号和验证码成对存储于 Redis 中，以供之后使用private void saveRandom(String mobile, String random) {    String randomKey = "random:" + mobile;    if (checkMobile(mobile)) {        return;    }    redisHelper.set(randomKey, random);    // 5分钟失效    redisHelper.expire(randomKey, 5, TimeUnit.MINUTES);}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> aliyun </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> aliyun </tag>
        
          <tag> message </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java + jQuery 实现阿里云点播]]></title>
      <url>/java/jquery/aliyun/2018/03/11/Java-+-jQuery-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91%E7%82%B9%E6%92%AD/</url>
      <content type="text"><![CDATA[  阿里云播放器直接在线点播视频以及直播技术，此处记录点播实现过程官网获取阿里云视频播放凭证阿里云Aliplayer播放器准备步骤  创建 阿里云账号  根据 流程 完成实名认证，以确保可以使用阿里云相应服务  在密钥管理页面获取阿里云访问密钥，AccessKeyId 和 AccessKeySecret后端相关操作在项目 pom 中引入所需 jar 包&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;    &lt;version&gt;3.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt;    &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt;获取对接需要的数据  将 AccessKeyId 、AccessKeySecret 进行相应存储新建 VideoController 用于接收前端获取视频播放凭证的请求@Controller@RequestMapping("/api/video")public class VideoController extends AbstractBaseController {    @Autowired    private VideoServiceImpl videoServiceImpl;    /**     * 获取播放凭证     *     * @param videoId     * @return     */    @RequestMapping(value = "/auth", method = RequestMethod.POST)    @ResponseBody    public ResponseData playAuth(@RequestParam final String videoId) {        return new SimpleActionHandler(request) {            @Override            protected void doHandle(ResponseData responseData) throws Exception {                responseData.setData(videoServiceImpl.getVideoPlayAuth(videoId));            }        }.handle();    }}新建 VideoServiceImpl 用于和阿里云播放器接口对接@Servicepublic class VideoServiceImpl extends AbstractBaseService {	...}在 VideoServiceImpl 中添加获取客户端的 getClient() 方法  Constants.ALI_ACCESS_KEY_ID 和 Constants.ALI_ACCESS_SECRET 是密钥，成对生成和使用  其他参数信息按照阿里云开发手册说明，均不需要改变private DefaultAcsClient getClient() {    // 初始化配置    DefaultProfile profile = DefaultProfile.getProfile("cn-shanghai", Constants.ALI_ACCESS_KEY_ID, Constants.ALI_ACCESS_SECRET);    // 获取客户端    return new DefaultAcsClient(profile);}通过外部传入的视频 id 从客户端获取视频播放凭证public String getVideoPlayAuth(String videoId) {    GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest();    GetVideoPlayAuthResponse response = null;    // 播放id    request.setVideoId(videoId);    try {        response = getClient().getAcsResponse(request);    } catch (ClientException e) {        logger.error("视频客户端获取失败！", e);    }    if (response != null) {        return response.getPlayAuth();    }    return null;}前端相关操作引入播放器所需要的 css/js 文件  以下引入的 js 文件为通用版本，包括了 flash 和 h5 的播放器  如果只想单独引入 flash 或 h5 ，只需要将名称中间加上对应标识即可，例如 aliplayer-h5-min.js  css 文件为公有版本，无需区分类型&lt;link rel="stylesheet" href="//g.alicdn.com/de/prismplayer/2.5.1/skins/default/aliplayer-min.css"/&gt;&lt;script charset="utf-8" type="text/javascript" src="//g.alicdn.com/de/prismplayer/2.5.1/aliplayer-min.js"&gt;&lt;/script&gt;准备待转化为播放器的标签内容  标签中的 data-id 是将视频传入到阿里云播放器后端之后返回的一个 vid  该 vid 可以通过 接口上传 也可以通过阿里云后端上传，此处不做介绍&lt;div class="prism-player" id="prismPlayer" data-id="281fc1687cb245658dc5e7462e54bc66"&gt;&lt;/div&gt;初始化视频播放器  $.ts.doAction 是经过封装后的 ajax 操作  Aliplayer({...}) 则是具体的播放器初始化操作var playerTag = target.find("#prismPlayer");var videoId = playerTag.data("id");// 移除文字标识playerTag.empty();// 非空验证if (videoId === undefined) {    return;}$.ts.doAction("/api/video/auth", {    videoId: videoId}, function () {    Aliplayer({        id: "prismPlayer",        autoplay: true,        width: "100%",        vid: videoId,        playauth: this.data    });}, '', '', '');]]></content>
      <categories>
        
          <category> java </category>
        
          <category> jquery </category>
        
          <category> aliyun </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> jquery </tag>
        
          <tag> aliyun </tag>
        
          <tag> player </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis抛出You can't operate on a closed Connection!!!]]></title>
      <url>/java/mybatis/error/2018/03/08/MyBatis%E6%8A%9B%E5%87%BAYou-can't-operate-on-a-closed-Connection!!!/</url>
      <content type="text"><![CDATA[  有时候通过 Session 获取数据库连接时为空碰到的问题  一般通过以下方式获取数据库连接  但有时候会出现获取不到连接，从而抛出 You can’t operate on a closed Connection!!! 的异常Connection connection = this.SqlSession().getConnection();解决的方式  使用以下方式获取数据库连接可保证获取的连接存在与事务中不会莫名丢失SqlSessionTemplate st = (SqlSessionTemplate) this.getSqlSession();SqlSession session = SqlSessionUtils.getSqlSession(st.getSqlSessionFactory(), st.getExecutorType(), st.getPersistenceExceptionTranslator());Connection connection = session.getConnection();]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[List抛出ConcurrentModificationException]]></title>
      <url>/java/list/error/2018/03/01/List%E6%8A%9B%E5%87%BAConcurrentModificationException/</url>
      <content type="text"><![CDATA[  在对 List 进行遍历的同时进行 remove 元素操作，可能会抛出 java.util.ConcurrentModificationException 异常错误示范  在遍历 List 时获取元素实际上通过迭代器在进行，迭代器在获取下一个元素时会对 modCount 和 expectedCount 进行匹配  遍历的同时直接对 List 进行 remove 操作，会导致只有 modCount 发生变化，而expectedCount 未发生变化  所以迭代器在获取下一个元素会发现两个值不匹配则抛出 java.util.ConcurrentModificationException 异常for (CourseDTO course : courses) {    for (MemberCourseDTO memberCourse : memberCourses) {        if (course.getId().equals(memberCourse.getCourse().getId())) {            courses.remove(course);        }    }}正确处理  使用迭代器原生的 remove 方法去操作 List 元素即可for (Iterator&lt;CourseDTO&gt; it = courses.iterator(); it.hasNext(); ) {    CourseDTO course = it.next();    for (MemberCourseDTO memberCourse : memberCourses) {        if (course.getId().equals(memberCourse.getCourse().getId())) {            // 移除当前元素            it.remove();        }    }}Java 8 的处理方式question.getOptions().removeIf(option -&gt; option.getContent().trim().equals(""));]]></content>
      <categories>
        
          <category> java </category>
        
          <category> list </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> list </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate防止setter()方法更新数据库]]></title>
      <url>/java/hibernate/2018/02/05/Hibernate%E9%98%B2%E6%AD%A2setter()%E6%96%B9%E6%B3%95%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="text"><![CDATA[  Hibernate从数据库获取到对象后直接调用其setter()方法对内部数据做更改，可能会导致直接将数据更新至数据库产生问题的原因  Hibernate分为三种基本状态：游离态，自由态，持久态  从数据库中获取到对象属于持久态，直接进行操作会导致处于Session中的数据发生改变，从而触发数据库更新解决办法  获取到当前的Session对象，将该对象从Session中清除super.getEntityDao().getSession().evict(userWork);]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate @OneToOne 自动新增和删除]]></title>
      <url>/java/hibernate/2018/01/12/Hibernate-@OneToOne-%E8%87%AA%E5%8A%A8%E6%96%B0%E5%A2%9E%E5%92%8C%E5%88%A0%E9%99%A4/</url>
      <content type="text"><![CDATA[  Hibernate创建一对一关系时两张表主表保持一致则可以实现自动新增和删除主表配置  主表对应类中需要通过@OneToOne来表示其与从表的关系@Entity@Table(name = "sys_user")public class User {    @Id    @GeneratedValue(strategy = IDENTITY)    private Long id = new Long(0);    @OneToOne(cascade = {CascadeType.ALL}, mappedBy = "user", fetch = FetchType.LAZY)    @JsonIgnore    private UserAccount userAccount;    public UserAccount getUserAccount() {        return userAccount;    }    public void setUserAccount(UserAccount userAccount) {        this.userAccount = userAccount;    }}从表配置  从表中的id需要通过@GeneratedValue和@GenericGenerator来指明该值从主表中获取  从表中同时需要通过@OneToOne来表示其与主表的关系          在维护与主表关系中需要通过@PrimaryKeyJoinColumn来表示两个表是主键关联，不存在多余外键      @Entity@Table(name = "sys_user_account")public class UserAccount {    @Id    @GeneratedValue(generator = "generator")    @GenericGenerator(name = "generator", strategy = "foreign", parameters = @Parameter(name = "property", value = "user"))    private Long id = 0L;    @OneToOne(fetch = FetchType.LAZY)    @PrimaryKeyJoinColumn    private User user;    public UserAccount() {    }    public UserAccount(User user) {        this.user = user;    }    public Long getId() {        return id;    }    public void setId(Long id) {        this.id = id;    }    public User getUser() {        return user;    }    public void setUser(User user) {        this.user = user;    }}保存操作  主表在执行保存操作时，需要将从表注入其中，同时将主表的引入也注入到从表，才能实现两个对象的双向关联  当主表的id自增成功时，由于从表保有对主表的引用，所以也可以得到主表的idpublic void save(User user) {    if (user.isNew()) {        user.setUserAccount(new UserAccount(user));        super.save(user);    } else {        super.save(userModel);    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot从数据库加载配置信息]]></title>
      <url>/java/springboot/hibernate/2017/12/31/SpringBoot%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
      <content type="text"><![CDATA[  Spring Boot 通过@Value注解可实现获取配置文件中的数据，而配置文件中的数据可以通过修改MutablePropertySources从数据库注入该示例基于Hibernate实现实体类  根据Hibernate的配置，实体类对应数据库中的表即可@Entity@Table(name = "sys_config")@Inheritance(strategy = InheritanceType.SINGLE_TABLE)public class Config implements Serializable {    @Id    private Long id;    @Column    private String code;    @Column    private String value;    @Column    private String name;    @Column    private String description;  ...}服务类  服务类用于从数据库中获取列表信息@Servicepublic class SystemConfigService extends SimpleHibernateService&lt;Config, Long&gt; {   ...}配置类  该配置类会在系统启动时自动加载  根据内部逻辑会将从数据库取出的列表信息注入到MutablePropertySources属性集合中  动态注入的属性集合无需有对应的 .properties 文件存在@Configurationpublic class SystemConfig {    @Autowired    private ConfigurableEnvironment environment;    @Autowired    private SystemConfigService service;    @PostConstruct    public void initDatabasePropertySourceUsage() {        // 获取系统属性集合        MutablePropertySources propertySources = environment.getPropertySources();        try {            // 从数据库获取自定义变量列表            Map&lt;String, String&gt; collect = service.getAll().stream().collect(Collectors.toMap(Config::getCode, Config::getValue));            // 将转换后的列表加入属性中            Properties properties = new Properties();            properties.putAll(collect);            // 将属性转换为属性集合，并指定名称            PropertiesPropertySource constants = new PropertiesPropertySource("system-config", properties);            // 定义寻找属性的正则，该正则为系统默认属性集合的前缀            Pattern p = Pattern.compile("^applicationConfig.*");            // 接收系统默认属性集合的名称            String name = null;            // 标识是否找到系统默认属性集合            boolean flag = false;            // 遍历属性集合            for (PropertySource&lt;?&gt; source : propertySources) {                // 正则匹配                if (p.matcher(source.getName()).matches()) {                    // 接收名称                    name = source.getName();                    // 变更标识                    flag = true;                    break;                }            }            if (flag) {                // 找到则将自定义属性添加到该属性之前                propertySources.addBefore(name, constants);            } else {                // 没找到默认添加到第一位                propertySources.addFirst(constants);            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }}工具类  由于Spring Boot不支持静态变量的自动注入，所以需要使用一个非静态的setter方法将通过@Value注解获取到的属性信息赋值给对应静态变量  @DependsOn({"systemConfig"}) 的意思是说 Constants 依赖于 SystemConfig ，所以需要确保 SystemConfig 在 Constants 之前加载@Configuration@DependsOn({"systemConfig"})public class Constants {    // 资源服务器地址    public static String RESOURCE_SERVER_URL;    @Value("${resource.server.url}")    public void setResourceServerUrl(String resourceServerUrl) {        RESOURCE_SERVER_URL = resourceServerUrl;    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringBoot+Vue表单文件上传]]></title>
      <url>/java/springboot/vue/2017/12/31/SpringBoot+Vue%E8%A1%A8%E5%8D%95%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      <content type="text"><![CDATA[  Spring Boot + Vue 的文件上传本身没有什么难点，但如果涉及到是一个表单对象中存在文件，则会比较繁琐后端实体类  Spring Boot中对于文件的接收类型和Spring MVC保持一致，使用MultipartFile  与Spring MVC不同的是Spring Boot进行文件上传操作不需要添加配置信息，Spring Boot自身已经默认开启了文件上传功能...public class Work {  ...    @Transient    private MultipartFile referenceFile;  ...}后端接收请求的接口  SpringBoot与Vue进行集成，使用axios进行异步请求发送，对于接收对象类型的数据一般使用@RequestBody的注解将对象解析为JSON格式  但是MultipartFile类型的文件无法转换为JSON格式，所以此处需要使用@ModelAttribute的注解接收对象信息...@RestController@RequestMapping("/${contextPath}/works")public class WorkController extends SimpleController&lt;Work, WorkService&gt; {  ...    @ApiOperation("保存作业")    @PostMapping("")    public ResponseData saveRule(@ModelAttribute Work work) {  return workService.save(work);    }  ...}前端对文件数据的处理  使用默认的文件输入框进行文件上传会影响美观，所以通常将输入框隐藏后通过点击按钮进行调用  由于文件格式的input属性是只读的，所以无法使用v-model对其数据的更改进行实时获取  所以需要通过@change对其数据的更改进行监听，并赋值给表单的对应属性&lt;template&gt;  &lt;in-form ref="inForm" :form="work" :rules="rules" :is-file="true"&gt;    ...    &lt;el-button type="success" v-else @click="uploadReferenceFile"&gt;    上传答案 &lt;span v-text="work.reference"&gt;&lt;/span&gt;    &lt;input type="file" class="upload-file" ref="referenceFile" @change="setReferenceFile"&gt;    &lt;/el-button&gt;    ...  &lt;/in-form&gt;&lt;/template&gt;&lt;script type="text/ecmascript-6"&gt;...  export default {    ...    methods: {...      // 上传参考答案      uploadReferenceFile () {        this.$refs.referenceFile.click()      },      // 设置参考答案      setReferenceFile (item) {        let currentFile = item.target.files[0]        this.work.reference = currentFile.name        this.work.referenceFile = currentFile      }...  }&lt;/script&gt;&lt;style scoped lang="stylus" rel="stylesheet/stylus"&gt;  .upload-file    display none&lt;/style&gt;前端发起请求的方式  文件格式的数据无法通过JSON格式进行传递，所以需要使用FormData对表单数据进行转换  但FormData只能接受String和File格式的数据，对应Object格式的数据无法处理  如果涉及到Object格式的数据则需要前后端配合进行数据转换  通常情况下对象中关联的对象只涉及到其中的某一个值，所以前端在处理时可以单独将该值进行传递  后端在接收到该值后，可以在其Setter方法中将数据赋予对应的对象即可export function save ({url, data}, isFile) {  // 带文件的上传功能  if (isFile) {    let formData = new FormData()        // 遍历传入的数据    for (let key in data) {      // 获取当前值      let currentData = data[key]        // 对于空值进行过滤      if (currentData === '') {        continue      }            // 将对象中的键值对传入formData中      formData.append(key, currentData)    }        data = formData  }    return fetch({    url: url,    method: config.POST,    data  })}限制文件大小  只需要在::application.properties::中添加如下配置即可spring.http.multipart.max-file-size=10MBspring.http.multipart.max-request-size=10MB]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> vue </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> vue </tag>
        
          <tag> form </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Maven针对SpringBoot的多项目依赖配置]]></title>
      <url>/java/maven/springboot/2017/12/16/Maven%E9%92%88%E5%AF%B9Spring-Boot%E7%9A%84%E5%A4%9A%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  在Spring Boot中对于多项目依赖配置，可通过Maven实现创建一个父级的pom文件  在该pom中指定其 &lt;groupId/&gt;、&lt;artifactId/&gt; 、&lt;version/&gt;  &lt;packaging/&gt; 必须是pom  &lt;parent/&gt; 需要引入 spring-boot-starter-parent 表示继承Spring Boot的父级配置  &lt;modules/&gt; 中依次引入后续需要相互依赖的项目  &lt;dependencyManagement/&gt; 中对上述引入的项目进行完成依赖配置&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;        &lt;groupId&gt;com.innovaee.hts.parent&lt;/groupId&gt;    &lt;artifactId&gt;innovaee-hts-parent&lt;/artifactId&gt;    &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;    &lt;packaging&gt;pom&lt;/packaging&gt;    &lt;name&gt;innovaee-hts-parent&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;1.5.8.RELEASE&lt;/version&gt;    &lt;/parent&gt;    &lt;modules&gt;        &lt;module&gt;hts-admin-backend&lt;/module&gt;  ...    &lt;/modules&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.innovaee.hts&lt;/groupId&gt;                &lt;artifactId&gt;hts-admin-backend&lt;/artifactId&gt;                &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;            &lt;/dependency&gt;  ...        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;&lt;/project&gt;在各个子项目的pom中对依赖关系进行配置  父级不再指向Spring Boot的父级，而是上述自定义父级&lt;parent&gt;    &lt;groupId&gt;com.innovaee.hts.parent&lt;/groupId&gt;    &lt;artifactId&gt;innovaee-hts-parent&lt;/artifactId&gt;    &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt;  从父级中获取需要的依赖配置&lt;dependency&gt;    &lt;groupId&gt;org.tshark.core&lt;/groupId&gt;    &lt;artifactId&gt;tshark-core&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  ...&lt;/dependency&gt;在需要被打包成jar包的项目中引入Spring Boot的编译插件&lt;build&gt;    &lt;finalName&gt;hts-admin&lt;/finalName&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;在父级pom所在的目录中执行打包命令对项目进行打包mvn clean package -Dmaven.test.skip=true]]></content>
      <categories>
        
          <category> java </category>
        
          <category> maven </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> maven </tag>
        
          <tag> springboot </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC配置i18n]]></title>
      <url>/java/springmvc/i18n/2017/11/14/SpringMVC%E9%85%8D%E7%BD%AEi18n/</url>
      <content type="text"><![CDATA[  i18n是internationalization首字母i和末尾字母n以及中间18个字母的简称，意于国际化在/src/main/resources下新建messages文件夹  新增以下文件          message.properties用于默认资源      message_zh_CN.properties用于中文资源      message_en_US.properties用于英文资源      spring-config.xml添加配置信息&lt;!-- 配置i18n资源文件 --&gt;&lt;bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;  &lt;!-- 资源文件路径 --&gt;  &lt;property name="basename" value="classpath:messages/message"/&gt;  &lt;!-- 默认编码 --&gt;  &lt;property name="defaultEncoding" value="UTF-8"/&gt;  &lt;!-- 指定默认资源文件 --&gt;  &lt;property name="useCodeAsDefaultMessage" value="true"/&gt;&lt;/bean&gt;spring-mvc.xml添加配置信息&lt;!-- 将Locale信息存放于Session中 --&gt;&lt;!-- id必须是localeResolver，否则会报cannot change HTTP Head ... --&gt;&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.SessionLocaleResolver"/&gt;&lt;!-- 配置拦截器获取Locale信息 --&gt;&lt;mvc:interceptors&gt;  &lt;bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/&gt;&lt;/mvc:interceptors&gt;IndexControler.java中的添加获取Locale信息方法public class IndexController {    @Autowired  private MessageSource messageSource;  @RequestMapping("")  public String main(Model model, HttpServletRequest request, HttpServletResponse response) {    // 设置语言格式    setLanguage(model, request, response, Locale.getDefault());        return "/index";  }    @RequestMapping("/{language}")  public String main(Model model, HttpServletRequest request, HttpServletResponse response, @PathVariable String language) {    // 分割参数    String[] languages = language.split("_");        // 设置系统语言    setLanguage(model, request, response, new Locale(languages[0], languages[1]));        return "/index";  }    /**   * 设定语言格式   */  private void setLanguage(Model model, HttpServletRequest request, HttpServletResponse response, Locale locale) {    // 获取LocaleResolver    LocaleResolver localeResolver = RequestContextUtils.getLocaleResolver(request);        // 设置Locale信息    localeResolver.setLocale(request, response, locale);        // 传递正确的Locale信息到页面    model.addAttribute("encoding", messageSource.getMessage("encoding", new Object[0], locale));  }  }页面中添加spring的tag用于使用message.properties中的标签信息&lt;%@ taglib uri="http://www.springframework.org/tags" prefix="spring" %&gt;页面上使用spring标签获取标签信息&lt;spring:message code="title" /&gt;首页提供一个下拉框用于手动切换语言&lt;div class="form select-langugae-panel"&gt;  &lt;div class="form-group"&gt;    &lt;select class="select-content select-content-btn"&gt;      &lt;option value="zh_CN" &lt;c:if test="${encoding eq 'zh_CN' }"&gt;selected&lt;/c:if&gt;&gt;中文&lt;/option&gt;      &lt;option value="en_US" &lt;c:if test="${encoding eq 'en_US' }"&gt;selected&lt;/c:if&gt;&gt;English&lt;/option&gt;    &lt;/select&gt; &lt;i class="select-arrow"&gt;&lt;/i&gt;  &lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> i18n </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> i18n </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC+MyBatis项目搭建]]></title>
      <url>/java/springmvc/mybatis/2017/11/12/SpringMVC+MyBatis%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      <content type="text"><![CDATA[  SpringMVC作为一个敏捷开发的常用框架，和MyBatis进行集成需要如下步骤构建项目  创建一个Maven Project，并添加web.xml  在pom.xml中引入以下依赖包  为保证项目编译的JDK版本统一，需要加入以下配置&lt;build&gt;  &lt;plugins&gt;    &lt;plugin&gt;      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;      &lt;version&gt;3.1&lt;/version&gt;      &lt;configuration&gt;        &lt;source&gt;1.8&lt;/source&gt;        &lt;target&gt;1.8&lt;/target&gt;      &lt;/configuration&gt;    &lt;/plugin&gt;  &lt;/plugins&gt;&lt;/build&gt;添加Spring依赖包&lt;!-- Spring核心包 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-core&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring IoC --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring包扫描 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring数据库连接 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring事务管理器 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring Web --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-web&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Spring WebMVC --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;添加MyBatis依赖包&lt;!-- MyBatis核心包 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.2.7&lt;/version&gt;&lt;/dependency&gt;&lt;!-- MyBatis Spring依赖包 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;  &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;添加数据库依赖包&lt;!-- MySQL连接 --&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;5.1.18&lt;/version&gt;&lt;/dependency&gt;&lt;!-- c3p0 --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.mchange&lt;/groupId&gt;  &lt;artifactId&gt;c3p0&lt;/artifactId&gt;  &lt;version&gt;0.9.5.1&lt;/version&gt;&lt;/dependency&gt;添加视图层依赖包&lt;!-- 视图层的核心包 --&gt;&lt;dependency&gt;  &lt;groupId&gt;taglibs&lt;/groupId&gt;  &lt;artifactId&gt;standard&lt;/artifactId&gt;  &lt;version&gt;1.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- JSTL --&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;jstl&lt;/artifactId&gt;  &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Servlet容器 --&gt;&lt;dependency&gt;  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;  &lt;version&gt;3.0.1&lt;/version&gt;&lt;/dependency&gt;在web.xml中添加配置  配置 DispatcherServlet&lt;!-- 配置DispatcherServlet --&gt;&lt;servlet&gt;  &lt;servlet-name&gt;asl-ums-dispatcher&lt;/servlet-name&gt;  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  &lt;!-- 加载Spring配置文件 --&gt;  &lt;init-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt;  &lt;/init-param&gt;  &lt;!-- 项目启动时加载文件 --&gt;  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;  映射路径规则```xml  asl-ums-dispatcher  /## 创建**spring-mvc.xml**并添加配置```xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc"xsi:schemaLocation="                http://www.springframework.org/schema/beans                http://www.springframework.org/schema/beans/spring-beans.xsd                http://www.springframework.org/schema/mvc                http://www.springframework.org/schema/mvc/spring-mvc.xsdhttp://www.springframework.org/schema/context                http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 自动注入 --&gt;&lt;!-- 用于提供数据绑定、数字@NumberFormat和日期格式化@DateTimeFormat以及xml和json的默认读写支持 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 配置静态资源 --&gt;&lt;!-- 加入对js/gif/png等静态资源的处理 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 指定默认路径 --&gt;&lt;mvc:view-controller path="/" view-name="redirect:/index"/&gt;&lt;!-- 配置JSP显示 --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;  &lt;property name="prefix" value="/WEB-INF/views"/&gt;  &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt;&lt;!-- 扫描指定路径下的类 --&gt;&lt;context:component-scan base-package="online.shixun.asl.module"&gt;  &lt;!-- 扫描带有@Controller注解的类 --&gt;  &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt;  &lt;!-- 扫描带有@Service注解的类 --&gt;  &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/&gt;&lt;/context:component-scan&gt;&lt;/beans&gt;创建spring-config.xml并添加配置&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;&lt;!-- 指定数据库文件 --&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;&lt;!-- 配置c3p0连接池 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;  &lt;!-- 数据库连接信息 --&gt;  &lt;property name="driverClass" value="${driver}"/&gt;  &lt;property name="jdbcUrl" value="${url}"/&gt;  &lt;property name="user" value="${username}"/&gt;  &lt;property name="password" value="${password}"/&gt;  &lt;!-- 最大连接数 --&gt;  &lt;property name="maxPoolSize" value="30"/&gt;  &lt;!-- 最小连接数 --&gt;  &lt;property name="minPoolSize" value="10"/&gt;  &lt;!-- 获取连接的超时时间，毫秒 --&gt;  &lt;property name="checkoutTimeout" value="5000"/&gt;  &lt;!-- 连接失败后的重连次数 --&gt;  &lt;property name="acquireRetryAttempts" value="1"/&gt;&lt;/bean&gt;&lt;!-- 配置事务管理器，MyBatis采用jdbc的事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;  &lt;!-- 指定数据源 --&gt;  &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;!-- 配置声明式事务 --&gt;&lt;tx:annotation-driven/&gt;&lt;!-- 配置SqlSessionFactory --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;  &lt;!-- 指定数据源 --&gt;  &lt;property name="dataSource" ref="dataSource"/&gt;  &lt;!-- 指定MyBatis全局配置文件 --&gt;  &lt;property name="configLocation" value="classpath:spring-mybatis.xml"/&gt;  &lt;!-- 指定实体类扫描路径 --&gt;  &lt;property name="typeAliasesPackage" value="online.shixun.asl.dto"/&gt;  &lt;!-- 指定映射文件的扫描路径 --&gt;  &lt;property name="mapperLocations" value="classpath:mapper/*Mapper.xml"/&gt;&lt;/bean&gt;&lt;!-- 将Dao注入Spring容器中 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;  &lt;!-- 指定扫描路径 --&gt;  &lt;property name="basePackage" value="online.shixun.asl.module"/&gt;  &lt;!-- 扫描带有@MyBatisRepository --&gt;  &lt;property name="annotationClass" value="online.shixun.asl.core.MyBatisRepository"/&gt;&lt;/bean&gt;&lt;/beans&gt;创建spring-mybatis.xml并添加配置&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;!-- 配置全局属性 --&gt;    &lt;settings&gt;        &lt;!-- 使用数据库自增主键 --&gt;        &lt;setting name="useGeneratedKeys" value="true"/&gt;        &lt;!-- 显示SQL语句 --&gt;        &lt;setting name="logImpl" value="STDOUT_LOGGING"/&gt;    &lt;/settings&gt;&lt;/configuration&gt;项目配置完毕后，想要启动项目，则需要在Mapper映射路径下至少存在一个mapper.xml]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis二级缓存]]></title>
      <url>/java/mybatis/2017/11/12/MyBatis%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      <content type="text"><![CDATA[  MyBatis的二级缓存可以通过极少的配置项实现对数据库查询数据的缓存规则  映射文件中所有的 &lt;select/&gt; 语句都会被缓存  映射文件中所有的 &lt;insert/&gt; &lt;update/&gt; &lt;delete/&gt; 语句都会刷新缓存  基于以上两点，需要被缓存的数据库表的所有操作都应该放在同一个Mapper文件中在MyBatis的配置文件中添加以下配置  实际上即时不在配置文件中显式的声明该配置项，MyBatis的二级缓存也是默认开启的，因为该配置项的默认值就是true          &lt;setting name="cacheEnabled" value="true" /&gt;        在需要进行缓存的Mapper文件中添加以下配置          &lt;cache eviction="FIFO" flushInterval="60000" size="512" readOnly="true" /&gt;      可选配置  eviction 回收策略          LRU [default] 移除最长时间不被使用的对象      FIFO 按对象进入缓存的顺序进行移除      SOFT 移除基于垃圾回收器状态和软引用规则的对象      WEAK 更积极的移除基于垃圾回收器状态和弱引用规则的对象        flushInterval 刷新间隔，毫秒          没有默认值，表明没有刷新间隔，缓存只有在调用刷新语句时刷新        size 引用数目          1024 [default] 存储列表集合和对象的1024个引用        readOnly  只读          false [default] 可读写的缓存会返回缓存对象的拷贝，性能稍差，但安全性更高      true 只读的缓存会给所有调用者返回缓存对象的相同实例，所以该对象无法被修改，性能更高      可选属性  useCache 让单个 &lt;select/&gt; 语句自行选择是否被缓存  flushCache 让单个 &lt;select/&gt; 语句自行选择是否被刷新缓存]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
          <tag> cache </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate项目搭建]]></title>
      <url>/java/hibernate/2017/09/21/Hibernate%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      <content type="text"><![CDATA[  Hibernate 作为一个全自动的持久层[ORM]框架，在项目中引入需要以下步骤基础步骤  进入 Hibernate官网 下载 Hibernate 源码包  解压源码包后进入下图中的目录，将目录中的所有 jar 包复制到项目的 lib 目录中  在项目 src 目录下新建 hibernate.cfg.xml 文件          若实体类使用注解，则需要在最后加入对实体类的映射      若实体类使用配置文件，则需要在最后引入对应配置文件      &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN"  "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;&lt;hibernate-configuration&gt;&lt;session-factory&gt;  &lt;!-- 数据库配置信息 --&gt;  &lt;property name="hibernate.connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;  &lt;property name="hibernate.connection.url"&gt;jdbc:mysql:///asl_dev&lt;/property&gt;  &lt;property name="hibernate.connection.username"&gt;root&lt;/property&gt;  &lt;property name="hibernate.connection.password"&gt;root&lt;/property&gt;  &lt;!-- Hibernate 方言 --&gt;  &lt;property name="hibernate.dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;  &lt;!-- 是否显示 sql --&gt;  &lt;property name="hibernate.show_sql"&gt;true&lt;/property&gt;  &lt;!-- 是否格式化 sql --&gt;  &lt;property name="hibernate.format_sql"&gt;true&lt;/property&gt;    &lt;!-- 注解实体类映射 --&gt;  &lt;mapping class="online.shixun.hpeu.model.GoodsModel"/&gt;  &lt;!-- 配置实体类映射 --&gt;  &lt;mapping resource="com/qingshixun/model/User.hbm.xml"/&gt;&lt;/session-factory&gt;&lt;/hibernate-configuration&gt;制作 Hibernate 工具类  通过该工具类可以便捷的重复调用 Session 对象  但如果涉及到 CUD 操作，则需要另外开启事务，并管理事务的提交或回滚public class HibernateUtil {    private static SessionFactory sessionFactory;    static {        Configuration configuration = new Configuration().configure();        StandardServiceRegistryBuilder ssrb = new StandardServiceRegistryBuilder();        StandardServiceRegistry serviceRegistry = ssrb.applySettings(configuration.getProperties()).build();        sessionFactory = configuration.buildSessionFactory(serviceRegistry);    }    public static Session getSession() {        return sessionFactory.openSession();    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring事务隔离级别]]></title>
      <url>/java/springmvc/springboot/2017/09/14/Spring%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      <content type="text"><![CDATA[  Spring 事务隔离级别是指 Spring 如何去处理每个事务之间的关联，可用于防止一些数据错误隔离级别  TransactionDefinition.ISOLATION_DEFAULT [默认值]          表示使用底层数据库的默认隔离级别，通常为 TransactionDefinition.ISOLATION_READ_COMMITTED      数据库的隔离级别参见 MySQL 数据库隔离级别        TransactionDefinition.ISOLATION_READ_UNCOMMITTED          表示一个事务可以读取到另一个事务修改但还未提交的数据      无法防止脏读、不可重复读、幻读      不推荐使用        TransactionDefinition.ISOLATION_READ_COMMITTED          表示一个事务只能读取到另一个事务已经提交的数据      可防止脏读      推荐使用        TransactionDefinition.ISOLATION_REPEATABLE_READ          表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同      可防止脏读、不可重复读        TransactionDefinition.ISOLATION_SERIALIZABLE          表示所有事务一次逐个执行，事务之间完全不可能产生干扰      可防止脏读、不可重复读、幻读      过于严密的隔离级别会严重影响系统性能      不推荐使用      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> springboot </tag>
        
          <tag> spring </tag>
        
          <tag> transaction </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring事务传播行为]]></title>
      <url>/java/springmvc/springboot/2017/09/14/Spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA/</url>
      <content type="text"><![CDATA[  Spring 事务的传播行为是指当存在多个事务同时存在的时候，Spring 应该如何处理这些这些事务传播行为  TransactionDefinition.PROPAGATION_REQUIRED [默认值]          如果当前存在事务，则加入该事务      如果当前不存在事务，则创建一个新的事务        TransactionDefinition.PROPAGATION_REQUIRES_NEW          创建一个新的事务      如果当前存在事务，则将当前事务挂起        TransactionDefinition.PROPAGATION_SUPPORTS          如果当前存在事务，则加入该事务      如果当前没有事务，则以非事务的方式继续执行        TransactionDefinition.PROPAGATION_NOT_SUPPORTED          以非事务方式运行      如果当前存在事务，则将当前事务挂起        TransactionDefinition.PROPAGATION_NEVER          以非事务方式运行      如果当前存在事务，则抛出异常        TransactionDefinition.PROPAGATION_MANDATORY          如果当前存在事务，则加入该事务      如果当前没有事务，则抛出异常        TransactionDefinition.PROPAGATION_NESTED          如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行      如果当前没有事务，则根据 TransactionDefinition.PROPAGATION_REQUIRED 决定      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> springboot </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> springboot </tag>
        
          <tag> spring </tag>
        
          <tag> transaction </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL数据库隔离级别]]></title>
      <url>/database/mysql/2017/09/14/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      <content type="text"><![CDATA[  数据库隔离级别用于处理数据库中的数据读写规则定义  脏读          事务 A 对数据进行了增删改，但未提交事务，事务 B 可读取到该数据      如果事务 A 进行回滚，则事务 B 读取到的数据是脏数据        不可重复读          事务 A 中发生了两次读操作      在第一次读操作和第二次读操作之间，事务 B 对该数据进行了修改      导致事务 A 两次读取的数据是不一致的        幻读          事务 A 对一定范围内的数据进行了修改      事务 B 在这个范围内新增了一条数据      这时事务 A 对这些数据进行的修改会丢失      隔离级别  Read-Uncommitted - Level 0          导致脏读        Read-Committed - Level 1          避免脏读      允许不可重复读和幻读        Repeatable-Read - Level 2          避免脏读      避免不可重复读和幻读        Serializable - Level 3          串行化读，事务只能依次执行      避免脏读      避免不可重复读和幻读      执行效率慢，慎重使用      总结  隔离级别越高，越能保证数据安全，但对并发性能的影响越大  Oracle 、SqlServer 的默认隔离级别是 Read-Committed  MySQL 的默认隔离级别是 Repeatable-Read]]></content>
      <categories>
        
          <category> database </category>
        
          <category> mysql </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread.wait()]]></title>
      <url>/java/multithreading/2017/05/05/Java-Thread.wait()/</url>
      <content type="text"><![CDATA[  wait() 和 notify() 必须在 synchronized 语句块中使用wait() 是强迫一个线程等待notify() 是通知一个线程继续运行功能  wait() 是针对已经获取对象锁的线程进行操作  当线程获取对象锁后，调用 wait() 主动释放对象锁，同时该线程休眠  直到其他线程调用 notify() 唤醒该线程，才继续获取对象锁，并执行  调用 notify() 唤醒线程并不是实时的，而是等相应的 synchronized 语句块执行结束，自动释放对象锁  再由 JVM 选取休眠的线程赋予对象锁，并执行，从而实现线程间同步、唤醒的操作对比  wait() 和 sleep() 都可以通过 interrupt() 打断线程的暂停状态，从而使线程立刻抛出 InterruptedException          通过 interrupt() 打断线程时，只需在 catch() 中捕获到异常即可安全结束线程      InterruptedException 是线程内部抛出，并不是 interrupt() 抛出      当线程执行普通代码时调用 interrupt() 并不会抛出异常，只有当线程进入 wait() / sleep() / join() 后才会立即抛出        wait() 和 sleep() 都可以暂定当前线程，其区别在于 wait() 在暂定的同时释放了对象锁  sleep() 是 Thread 的静态方法，wait() 是 Object 的一般方法实现public class WaitTest extends Thread {    private final Object self;    private final Object last;    public WaitTest(String name, Object self, Object last) {        super(name);        this.self = self;        this.last = last;    }    public void run() {        for (int i = 0; i &lt; 10; i++) {            // 锁住下一个对象            synchronized (last) {                // 锁住当前对象                synchronized (self) {                    if (super.getName().equals("A")) {                        System.out.println("第 " + (i + 1) + " 次运行！");                    }                    System.out.println(super.getName());                    // 等待一轮循环结束后唤醒当前线程                    self.notify();                }                try {                    // 释放下一个线程的对象锁                    last.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    public static void main(String[] args) {        Object a = new Object();        Object b = new Object();        Object c = new Object();        WaitTest waitA = new WaitTest("A", a, b);        WaitTest waitB = new WaitTest("B", b, c);        WaitTest waitC = new WaitTest("C", c, a);        waitA.start();        waitB.start();        waitC.start();    }}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC使用MultipartFile实现文件上传]]></title>
      <url>/java/springmvc/2017/04/26/SpringMVC%E4%BD%BF%E7%94%A8MultipartFile%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      <content type="text"><![CDATA[  SpringMVC 接收 MultipartFile 需要在 spring-mvc.xml 中配置文件解析器配置&lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;    &lt;property name="maxUploadSize" value="20971520"/&gt;    &lt;property name="defaultEncoding" value="UTF-8"/&gt;&lt;/bean&gt;依赖&lt;dependency&gt;	&lt;groupId&gt;commons-fileupload&lt;/groupId&gt;	&lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;	&lt;groupId&gt;commons-io&lt;/groupId&gt;	&lt;artifactId&gt;commons-io&lt;/artifactId&gt;&lt;/dependency&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> fileupload </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread.yield()]]></title>
      <url>/java/multithreading/2017/04/21/Java-Thread.yield()/</url>
      <content type="text"><![CDATA[  yield() 是 Thread 提供的一个静态方法，可直接通过 Thread 调用yield() 是提醒线程暂停功能  暂停当前正在执行的线程对象，并执行其他线程特点  让当前运行线程回到可运行状态，从而让拥有相同优先级的线程获取运行机会  其目的是让拥有相同优先级的线程之前能适当的轮转运行  实际上 yeld() 的可行性无法得到保证，因为回到可运行状态的线程依旧有可能有限被调度程序选中  yeld() 不会导致线程回到等待/睡眠/阻塞状态，所以对线程执行该方法后可能没有效果对比  sleep() 放线程进行停滞状态，导致线程在指定时间内停止运行  yield() 只是让线程回到可运行状态，但重新获取运行权的可能还是这个线程  sleep() 允许优先级较低线程在当前线程停滞后获取运行权  yield() 不可能让比当前线程优先级低的线程获取运行权实现public YieldTest extends Thread {	public YieldTest (String name) {		super(name);	}	public void run() {		for (int i = 1; i &lt;= 5; i++) {			System.out.println(this.getName() + " 运行 " + i + " 次");			if (i == 3) {				this.yield();			}		}	}	public static void main(String[] args) {		YieldTest tom = new YieldTest("tom");		YieldTest jerry = new YieldTest("jerry");		tom.start();		jerry.start();	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread 调度]]></title>
      <url>/java/multithreading/2017/04/21/Java-Thread-%E8%B0%83%E5%BA%A6/</url>
      <content type="text"><![CDATA[  Thread 调整线程优先级，称为线程调度线程优先级越高，则会获得更多的运行机会级别  优先级的取值范围是 1-10 ，但只提供 3 个常量          Thread.MAX_PRIORITY - 最高优先级，取值 10      Thread.MIN_PRIORITY - 最低优先级，取值 1      Thread.NORM_PRIORITY - 默认优先级，取值 5        虽然 JVM 提供了 10 个优先级，但不推荐使用常量以外的其他优先级，因为其一致性不佳  线程的优先级拥有继承关系，子类默认和父类拥有相同优先级方法  setPriority() 设置优先级  getPriority() 获取优先级]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread join()]]></title>
      <url>/java/multithreading/2017/04/21/Java-Thread-join()/</url>
      <content type="text"><![CDATA[  join() 是 Thread 提供的一个方法，线程启动后可直接调用join() 是等待线程终止功能  线程调用 join() 后，主线程必须等待该线程终止后，主线程才能终止场景  当主线程调用子线程后，子线程需要大量的耗时运算  由于多线程的特性，往往导致主线程会在子线程之前结束  那么主线程结束之前就无法获取到子线程的运算结果  当子线程调用 join() 后，会强制主线程必须等待子线程终止后，主线程才能终止  从而主线程就可以获取到子线程的运算结果实现  主线程的结束语句一定会等两个子线程都结束后才会运行public JoinTest implements Runnable {	private String name;	public JoinTest(String name) {		this.name = name;	}	public void run() {		System.out.println(name = " 线程开始运行！");		for (int i = 1; i &lt;= 5; i++) {			System.out.println(name = " 线程运行 " + i + " 次！");			try {				Thread.sleep(500);			} catch (InterruptedException e) {				e.printStackTrace();			}		}				System.out.println(name = " 线程运行结束！");	}	public static void main(String[] args) {		System.out.println("主线程开始运行！\n");		JoinTest tom = new JoinTest("tom");		JoinTest jerry = new JoinTest("jerry");		Thread tomThread = new Thread(tom);		Thread jerryThread = new Thread(jerry);		tomThread.start();		jerryThread.start();		try {			tomThread.join();			jerryThread.join();		} catch (InterruptedException e) {			e.printStackTrace();		}		System.out.println("\n主线程运行结束！");	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java Thread 状态转换]]></title>
      <url>/java/multithreading/2017/04/18/Java-Thread-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</url>
      <content type="text"><![CDATA[  下图对 Thread 的所有状态进行流程描述分解  初始 - 新创建一个线程对象  就绪- 对象的 start() 被调用          处于该状态的线程位于可运行线程池中，等待获取 CPU 使用权        运行 - 执行程序代码  阻塞 - 因为某种原因放弃 CPU 使用权，暂时停止运行          处于该状态的线程直到重新进入就绪状态，才有机会回到运行状态      该状态具体分为三种                  等待 - 该线程执行 wait() ，JVM 将该线程放入等待池中，并释放持有的锁          同步 - 该线程在获取对象同步锁时，发现该同步锁被占用，JVM 则将该线程放入锁池中          其他 - 该线程执行 sleep() 或 join() 或发出 I/O 请求，JVM 将该线程改为阻塞状态                      死亡 - 线程执行结束或因抛出异常导致退出 run()]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 继承 Thread 类]]></title>
      <url>/java/multithreading/2017/04/17/Java-%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB/</url>
      <content type="text"><![CDATA[  如果只是启动一个线程，则可通过继承 Thread 类来实现但一般推荐使用 Runnable - Java 实现 Runnable 接口Thread 类实际上也是实现了 Runnable 接口注意  程序运行时，Java 虚拟机启动一个进程，主线程在 main() 调用时被创建  在 main() 中调用 ThreadTest 的两个对象，则启动两个线程  start() 的调用不会立即执行多线程代码，而是促使该线程变为可运行态，具体运行时间由操作系统决定  多线程是乱序执行的，每次执行的结果都不确定  在多线程中调用 sleep() 的目的是不让当前线程占用全部系统资源  如果一个对象的 start() 被重复调用，则会抛出 java.lang.IllegalThreadStateException 异常实现public class ThreadTest extends Thread {	private String name;	public ThreadTest (String name) {		this.name = name;	}	public void run() {		for (int i = 1; i &lt;= 5; i++) {			System.out.println(name + " 运行 " + i + " 次");			try {					// 单位毫秒				sleep(1000);			} catch (InterruptedException e) {				e.printStackTrace();			}		}	}	public static void main(String[] args) {		ThreadTest tom = new ThreadTest("tom");		ThreadTest jerry = new ThreadTest("jerry");		tom.start();		jerry.start();	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java 实现 Runnable 接口]]></title>
      <url>/java/multithreading/2017/04/17/Java-%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3/</url>
      <content type="text"><![CDATA[  与 Java 继承 Thread 类 一样，实现 Runnable 接口也是启动 Java 线程的一种方式通过继承 Thread 类实现多线程的对象，不适合资源共享，而实现 Runnable 接口，则适合资源共享不论是通过继承 Thread 类或者实现 Runnable 接口来实现多线程，最终都是通过 Thread 的 API 控制线程注意  run() 是多线程程序的一个约定，所有的多线程代码都在其中执行  在启动多线程时，首先需要通过 Thread(Runnable target) 构造出线程对象，再调用 start() 运行多线程  所有的多线程代码都是通过 Thread 的 start() 来运行优势 - Runnable 相较于 Thread  适合拥有多个相同程序代码的线程去处理同一资源  可以避免 Java 中的单继承限制  代码可以被多个线程共享  代码和数据实现独立  增加程序的健壮性  线程池只能放入实现 Runnable 或 Callable 的类，不能直接放入继承 Thread 的类实现public class RunnableTest implements Runnable {	private String name;	public RunnableTest(String name) {		this.name = name;	}	public void run() {		for (int i = 1; i &lt;= 5; i++) {			System.out.println(name + " 运行 " + i + " 次");			try {				Thread.sleep(1000);			} catch (InerruptedException e) {				e.printStackTrace();			}		}	}	public static void main(String[] args) {		RunnableTest tom = new RunnableTest("tom");		RunnableTest jerry = new RunnableTest("jerry");		new Thread(tom).start();		new Thread(jerry).start();	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> multithreading </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> multithreading </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring的@Transactional详解]]></title>
      <url>/java/springboot/springmvc/2017/04/05/Spring%E7%9A%84@Transactional%E8%AF%A6%E8%A7%A3/</url>
      <content type="text"><![CDATA[  Spring 提供的事务管理机制为不同的事务 API 提供一致的编程模型管理方式  编程式事务          TransactionTemplate [推荐]      PlatformTransactionManager [基于底层]        声明式事务 [推荐]          基于 &lt;tx/&gt; 和 &lt;aop/&gt; 的 xml 配置文件      使用 @Transactional 注解 [推荐]      配置方式  使用 @Transactional 注解的声明式配置参见 SpringMVC声明式事务配置注意点  默认情况下，数据库处于紫铜提交模式，每个语句处于单独的事务中  对于正常的事务管理，应当是一组相关操作处于同一个事务中  Spring 默认将底层连接的自动提交设置为 false  有些数据连接池提供自动提交的开关设置，但 c3p0 未提供  JDBC 规范明文指出当连接对象建立时应该处理自动提交模式，对于自动提交的开关应该进行显示处理  当一个连接关闭时，未提交的事务应该回滚，虽然 JDBC 规范未明确指出，但 c3p0 默认将 autoCommitOnClose 设置为 false  MyBatis 会自动参与到 Spring 的事务管理中，只要二者引用的数据源一致@Transactional 属性  value - String          限定描述符，用于指定使用的事务管理器        isolation - enum          事务隔离级别，参见 Spring 事务隔离级别        propagation - enum          事务传播行为，参见 Spring 事务传播行为        readOnly - boolean          事务只读属性，默认读写      false = 读写，true = 只读      只读属性用于特殊情景优化，例如在使用 Hibernate 时，默认使用读写事务        timeout - int          事务超时时间，单位秒      如果超过该时间事务还没完成，则自动回滚事务      默认设置为底层事务系统的超时值，如果底层未设置，则为 none        rollbackFor - Class 对象数组，必须继承自 Throwable          导致事务回滚的异常类数组        rollbackForClassName - 类名数组，必须继承自 Throwable          导致事务回滚的异常类名称数组        noRollbackFor - Class 对象数组，必须继承自 Throwable          不会导致事务回滚的异常类数组        noRollbackForClassName - 类名数组，必须继承自 Throwable          不会导致事务回滚的异常类名称数组      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springboot </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springboot </tag>
        
          <tag> springmvc </tag>
        
          <tag> spring </tag>
        
          <tag> transaction </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis批量新增]]></title>
      <url>/java/mybatis/2017/03/31/MyBatis%E6%89%B9%E9%87%8F%E6%96%B0%E5%A2%9E/</url>
      <content type="text"><![CDATA[  通过循环 values 语句实现批量新增数据&lt;insert id="saveTimetables"&gt; INSERT INTO pt_timetable (  id,  lessonNo ) VALUES  &lt;foreach collection="list" item="item" separator=","&gt;   (    #{item.id},              #{item.lessonNo}          )  &lt;/foreach&gt;&lt;/insert&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC的CacheManager配置]]></title>
      <url>/java/springmvc/2017/03/27/SpringMVC%E7%9A%84CacheManager%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  Spring 3.1 后提供一个新特性 基于注释驱动的缓存可以通过在方法上加入注解，从而缓存该方法返回的数据编写配置文件&lt;!-- 使用缺省名称为 cacheManager 的缓存管理器，其缺省实现为 org.springframework.cache.support.SimpleCacheManager --&gt;&lt;cache:annotation-driven/&gt;&lt;!-- 配置 cacheManager --&gt;&lt;bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager"&gt;&lt;!-- 配置缓存集合 --&gt;&lt;property name="caches"&gt;&lt;set&gt;&lt;!-- 缺省方案 --&gt;&lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="default"/&gt;&lt;!-- 自定义方案 --&gt;&lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean" p:name="dictionaryCache"/&gt;&lt;/set&gt;&lt;/property&gt;&lt;/bean&gt;在需要缓存的方法上加缓存注释，并指定自定义名称@Cacheable(value = "dictionaryCache")public List&lt;DictionaryDTO&gt; getDictionaries(String className) {return dictionaryDao.getDictionaries(className);}清空缓存  allEntries = true 表示清空所有缓存  key = "#dictionary.getName()" 表示只清空方法参数中带有指定key的缓存@CacheEvict(value = "departmentService", allEntries = true)public ResponseData removeDictionary(Long id) {...}@CacheEvict(value = "departmentService", key = "#dictionary.getName()")public void addDictionary(DictionaryDTO dictionary) {...}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> cache </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringMVC声明式事务配置]]></title>
      <url>/java/springmvc/2017/03/25/SpringMVC%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE/</url>
      <content type="text"><![CDATA[  Spring 的事务管理机制用处在于保证数据统一性在事务执行过程中如果出现报错，Spring 的事务管理机制会回滚事务，保证数据库的数据不会出现只更改一部分的情况但触发事务回滚的报错必须是 RuntimeExpection，只有这种异常可以被 Spring 事务捕获到如果随意使用 try-catch 对报错进行包裹，会导致报错在方法体内被处理报错信息不再向上抛出，即 Spring 捕获不到关键的 RuntimeExpection根据持久层类型选择正确的事务管理器进行配置  MyBatis 采用的是 JDBC 的事务管理器  Hibernate 采用的是 Hibernate 自己的事务管理器  dataSource 是数据源&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;&lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;配置声明式事务  默认使用注解管理事务行为，注解也是管理实务的最佳行为&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;通过 @Transactional 指定需要事务管理的方法体  事务注解最好是打到具体的方法体上，如果打到类名上则意味着整个类都需要进行事务控制，多余的事务控制会影响事务的执行时间  方法体中存在增删改操作才需要事务控制  只读操作不需要事务控制@Transactionalpublic void executeSkill() { ... }]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> transaction </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis集成到Spring之生成Session工厂]]></title>
      <url>/java/springmvc/mybatis/2017/03/24/MyBatis%E9%9B%86%E6%88%90%E5%88%B0Spring%E4%B9%8B%E7%94%9F%E6%88%90Session%E5%B7%A5%E5%8E%82/</url>
      <content type="text"><![CDATA[  虽然 Spring 自身没有对 MyBatis 提供支持但 MyBatis 主动对 Spring 进行了整合依赖依赖&lt;dependency&gt;&lt;groupId&gt;org.mybatis&lt;/groupId&gt;&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;&lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;配置  在 Spring 中集成 MyBatis 需要使用 SqlSessionFactoryBean 来生成 MyBatis 所需的 Session 工厂&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;...&lt;/bean&gt;  SqlSessionFactoryBean 实际上并不是真正的 Session 工厂，其经历了如下转换SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();SqlSessionFactory sessionFactory = factoryBean.getObject();属性  指定数据源          该数据源通常引用的是一个数据库连接池的配置项别名      &lt;property name="dataSource" ref="dataSource" /&gt;        MyBatis 全局配置文件          mybatis-config.xml 中的内容是 MyBatis settings 配置表      &lt;property name="configLocation" value="classpath:mybatis-config.xml" /&gt;        自动扫描 Mapper 文件          &lt;property name="mapperLocations" value="classpath:mapper/*Mapper.xml" /&gt;      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis集成到Spring之注入Dao接口]]></title>
      <url>/java/springmvc/mybatis/2017/03/24/MyBatis%E9%9B%86%E6%88%90%E5%88%B0Spring%E4%B9%8B%E6%B3%A8%E5%85%A5Dao%E6%8E%A5%E5%8F%A3/</url>
      <content type="text"><![CDATA[  MyBatis 的 MapperScannerConfigurer 可以将 Dao 接口和 Mapper 文件注入到 Spring 容器中配置&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;...&lt;/bean&gt;属性  指定 Session 工厂          通常情况下系统只会存在一个 DataSource ，这时 MapperScannerConfigurer 会自动装配 Session 工厂，无需手动指定      必须使用 value 注入 Bean 的名称，而不是使用 ref 对 Bean 进行引用      sqlSessionFactory 的实例在 MyBatis 集成到 Spring 之生成 Session 工厂      &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt;        指定 Dao 接口的扫描路径          同时指定多个路径只需要通过逗号分隔即可      &lt;property name="basePackage" value="org.seckill.module" /&gt;      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis的settings配置表]]></title>
      <url>/java/mybatis/2017/03/22/MyBatis%E7%9A%84settings%E9%85%8D%E7%BD%AE%E8%A1%A8/</url>
      <content type="text"><![CDATA[  &lt;settings/&gt; 标签是 MyBatis 中的属性配置项，可以改变 MyBatis 的运行时行为规则  标签中的 value 为该设置的默认值  缓存全局开关          &lt;setting name="cacheEnabled" value="true" /&gt;        延迟加载全局开关          值为 true 时所有对象延迟加载      可通过在具体的查询中设置 fetchType 来覆盖该设置      &lt;setting name="lazyLoadingEnabled" value="false" /&gt;        所有对象直接加载          &lt;setting name="aggressiveLazyLoading" value="true" /&gt;        允许单一语句返回多个结果集，需要兼容驱动          &lt;setting name="multipleResultSetsEnabled" value="true" /&gt;        使用列标签代替类名          &lt;setting name="useColumnLabel" value="true" /&gt;        允许 JDBC 使用数据库自增主键          &lt;setting name="useGeneratedKeys" value="true" /&gt;        指定自动映射到字段的规则          NONE 取消自动映射      PARTIAL 只映射没有定义嵌套结果集映射的结果集      FULL 自动映射任何结果集      &lt;setting name="autoMappingBehavior" value="PARTIAL" /&gt;        指定当自动映射碰到未知列的处理规则          NONE 不做任何处理      WARNING 输入警告日志      FAILING 抛出 SqlSessionException 异常      &lt;setting name="autoMappingUnknownColumnBehavior" value="NONE" /&gt;        配置默认执行器          SIMPLE 普通执行器      REUSE 重用预处理语句      BATCH 重用语句并执行批量更新      &lt;setting name="defaultExecutorType" value="SIMPLE" /&gt;        设置驱动等待数据库响应的超时时间          该设置项默认没有值      值的范围是任意正整数      值的单位是秒      &lt;setting name="defaultStatementTimeout" value="" /&gt;        为驱动的结果集数量设置提示值          该设置项默认没有值      值的范围是任意正整数      可在具体查询中通过 fetchSize 覆盖该设置项      &lt;setting name="defaultFetchSize" value="" /&gt;        允许在嵌套语句中使用分页 RowBounds          &lt;setting name="safeRowBoundsEnabled" value="false" /&gt;        允许在嵌套语句中使用分页 RowHandler          &lt;setting name="safeRowHandlerEnabled" value="true" /&gt;        开启驼峰命令规则自动转换功能          例如：create_time &gt; createTime      &lt;setting name="mapUnderscoreToCameCase" value="false" /&gt;        利用本地缓存机制防止循环引用和加速重复嵌套查询          SESSION 缓存一个会话中执行的所有查询      STATEMENT 本地会员只用在语句执行中，对相同 SqlSession 的不同调用不会共享数据      &lt;setting name="localCacheScope" value="SESSION" /&gt;        当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型          OTHER 一般类型      NULL 空值      VARCHAR 字符串      &lt;setting name="jdbcTypeForNull" value="OTHER" /&gt;        指定某个对象的方法触发一次延迟加载          多个方法名称通过逗号划分      &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString /&gt;"        指定动态 SQL 生成的默认语言          &lt;setting name="defaultScriptingLanguage" value="org.apache.ibatis.scripting.xmltags.XMLLanguageDriver" /&gt;        当结果集为 NULL 时，调用映射对象的 setter 方法为结果赋值          结果集类型是 List 时，调用 setter 方法      结果集类型是 Map 时，调用 put 方法      该属性对于基本类型无效      &lt;setting name="callSetterOnNulls" value="false" /&gt;        当对象所有列都返回 NULL 时，将整个对象设置为 NULL          &lt;setting name="returnInstanceForEmptyRow" value="false" /&gt;        指定日志名称的前缀          该设置项没有默认值      值可以是任何字符串      &lt;setting name="logPrefix" value="" /&gt;        指定日志的具体实现方式          该设置项没有默认值      值可以是 slf4j / log4j / log4j2 / jdk_logging / commons_logging / stdout_logging / no_loggging      未指定值的时候会在上述支持列表中自动查找      &lt;setting name="logImpl" value="" /&gt;        指定创建具有延迟加载能力的对象所用到的代理工具          值可以是 CGLIB / JAVASSIST      &lt;setting name="proxyFactory" value="JAVASSIST" /&gt;        指定 VFS 的实现          该设置项没有默认值      值可以是自定义 VFS 的实现类全名      多个 VFS 可以通过逗号划分      &lt;setting name="vfsImpl" value="" /&gt;        允许使用方法签名中的名称作为语句参数名称          仅在 Java 8 环境中生效，并且需要在环境变量中加上 -parameters      &lt;setting name="useActualParamName" value="true" /&gt;      完整配置示例&lt;settings&gt;  &lt;setting name="cacheEnabled" value="true"/&gt;  &lt;setting name="lazyLoadingEnabled" value="true"/&gt;  &lt;setting name="multipleResultSetsEnabled" value="true"/&gt;  &lt;setting name="useColumnLabel" value="true"/&gt;  &lt;setting name="useGeneratedKeys" value="false"/&gt;  &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt;  &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt;  &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt;  &lt;setting name="defaultStatementTimeout" value="25"/&gt;  &lt;setting name="defaultFetchSize" value="100"/&gt;  &lt;setting name="safeRowBoundsEnabled" value="false"/&gt;  &lt;setting name="mapUnderscoreToCamelCase" value="false"/&gt;  &lt;setting name="localCacheScope" value="SESSION"/&gt;  &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt;  &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt;&lt;/settings&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis防止死循环]]></title>
      <url>/java/mybatis/error/2017/02/18/MyBatis%E9%98%B2%E6%AD%A2%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
      <content type="text"><![CDATA[  mybatis的mapper文件中如果存在错误，会导致项目启动时加载mapper进入死循环，却不输出错误重新buildSqlSessionFactory()  重写org.mybatis.spring.SqlSessionFactoryBean的buildSqlSessionFactory()方法public class FixedSqlSessionFactory extends SqlSessionFactoryBean {    @Override    protected SqlSessionFactory buildSqlSessionFactory() throws IOException {        try {            return super.buildSqlSessionFactory();        }catch (Exception e){            e.printStackTrace();        }finally {            ErrorContext.instance().reset();        }        return null;    }}修改配置文件中的引用为上述包装类&lt;bean id="sqlSessionFactory" class="com.innovaee.hts.sop.web.FixedSqlSessionFactory"&gt;    &lt;property name="dataSource" ref="dataSource"/&gt;    ...&lt;/bean&gt;启动项目，则会在控制台输出具体错误信息]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
          <category> error </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
          <tag> error </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate枚举映射策略]]></title>
      <url>/java/hibernate/2017/02/15/Hibernate%E6%9E%9A%E4%B8%BE%E6%98%A0%E5%B0%84%E7%AD%96%E7%95%A5/</url>
      <content type="text"><![CDATA[  稍微解释一下Hibernate枚举策略枚举类型映射到数据库的方式  int，即获取枚举的索引值存入数据库，从0开始  String，即获取枚举的name属性存入数据库Hibernate默认把枚举类型的字段当做基本类型(int)的字段来映射  可以通过注解的方式进行控制          @Enumerated(EnumType.ORDINAL)  默认方式，int型      @Enumerated(EnumType.STRING)  String型，会获取枚举的name属性      ]]></content>
      <categories>
        
          <category> java </category>
        
          <category> hibernate </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> hibernate </tag>
        
          <tag> enum </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java支付宝扫码支付[旧]]]></title>
      <url>/java/pay/2017/02/14/Java%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98-%E6%97%A7/</url>
      <content type="text"><![CDATA[  在实际开发过程中，首先采用当面付模式进行开发，但没有成功，个人认为当面付更适合线下模式之后改用即时到账模式才成功接入支付宝扫码支付功能以下内容是基于即时到账模式开发要使用支付宝即时到账接口，首先需要签约即时到账产品， 申请地址审核进度通常需要1个工作日，但实际几小时即可之后需要获取和设置如下关键信息pid:2088621150311111          合作伙伴身份IDkey:zrqyf6dfli7dvji4mmi4sw1111111111      MD5密钥notify_url:http://127.0.0.1:8080/sop/order/notify/ali    异步通知回调地址return_url:http://127.0.0.1:8080/sop/order/notify/ali/return  同步通知回调地址官网支付宝-开放平台模式  当面付 ，消费者扫描商户二维码完成支付。并不适用于Web网页端扫码支付  即时到账 ，用户在线向开发者的支付宝账号支付资金。Web网页端扫码支付首选开发步骤  下载支付宝提供的即时到账 DEMO          按下图所示将alipay下所有文件复制到项目开发目录，支付宝已将接口的调用、请求、验签等操作完成，我们只需要包装好数据后调用即可        打开AlipayConfig.java，将其中关键信息替换成之前准备好的内容          除了下述四个信息，其他内容均不需要修改      ** partner**即pid，key即md5密钥，都可以在 mapi网关产品密钥 获取      notify_url是支付宝异步通知链接，由支付宝主动调用，一旦用户完成支付，即调用该地址      不可添加自定义参数      必须保证外网可正常访问      使用POST方式发送/接收数据      没有时间限制      如果是https，则必须安装ssl证书，并且需要正规的证书机构签发，自签名的无法识别      return_url，是支付宝同步跳转通知，用户完成支付后，在支付页面完成跳转      不可添加自定义参数      必须保证外网可正常访问，但可在本机测试      使用GET方式发送/接收数据      一分钟超时      // 合作身份者ID，签约账号，以2088开头由16位纯数字组成的字符串，查看地址：https://b.alipay.com/order/pidAndKey.htmpublic static String partner = SOPConstants.ALI_PAY_PARTNER_ID; // MD5密钥，安全检验码，由数字和字母组成的32位字符串，查看地址：https://b.alipay.com/order/pidAndKey.htmpublic static String key = SOPConstants.ALI_PAY_MD5_KEY;// 服务器异步通知页面路径  需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问public static String notify_url = SOPConstants.ALI_PAY_NOTIFY_URL;// 页面跳转同步通知页面路径 需http://格式的完整路径，不能加?id=123这类自定义参数，必须外网可以正常访问public static String return_url = SOPConstants.ALI_PAY_RETURN_URL;  在订单支付页面创建一个空的div，用于接收调用即时到账接口返回的表单数据$.ts.doAction("/api/order/pay/ali", {    orderId: orderId}, function () {    // 提交表单内容    $orderSubmitPanel.find("#returnAli").append(this.data);   // 打开订单状态轮询页面，确保支付完成后，支付页面能自动跳转    $.ts.openModalWindow("/api/order/pay/ali/tip/" + orderId, 350, 300);}, "", "", "");@RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic ResponseData ali(HttpServletRequest request, @RequestParam("orderId") final String orderId) {    SimpleActionHandler actionHandler = new SimpleActionHandler(request) {        @Override        protected void doHandle(ResponseData responseData) throws Exception {            responseData.setData(orderPayService.aliPay(IdEncoder.decodeId(orderId)));        }    };    return actionHandler.handle();}  按照 请求参数说明 包装请求参数，并建立请求          建立请求的操作支付宝已在AlipaySubmit.java中实现，只需要调用其中buildRequest()方法并传入参数即可      public String aliPay(Long orderId) {    // 获取订单信息    OrderDTO order = orderManageService.getOrder(orderId);    // 包装请求参数    Map&lt;String, String&gt; params = Maps.newHashMap();    // 调用接口    params.put("service", AlipayConfig.service);    // 签约账号id    params.put("partner", AlipayConfig.partner);    // 收款支付账号，默认与签约账号相同    params.put("seller_id", AlipayConfig.seller_id);    // 编码格式，支付GBK和UTF-8    params.put("_input_charset", AlipayConfig.input_charset);    // 支付类型    params.put("payment_type", AlipayConfig.payment_type);    // 异步通知回调地址    params.put("notify_url", AlipayConfig.notify_url);    // 同步通知跳转地址    params.put("return_url", AlipayConfig.return_url);    // 防钓鱼时间戳    params.put("anti_phishing_key", AlipayConfig.anti_phishing_key);    // 客户端IP    params.put("exter_invoke_ip", super.getClientIP());    // 订单号    params.put("out_trade_no", order.getCode());    // 标题    params.put("subject", "轻实训-" + order.getName());    // 金额    params.put("total_fee", String.valueOf(order.getPrice()));    // 建立请求    return AlipaySubmit.buildRequest(params, "get", "确认");}  由于调用即时到账接口返回的表单数据会自动提交，而接收表单数据的div是在订单提交页面，因此按照表单提交默认方式，会导致订单提交页面被替换成支付宝扫码页面  所以需要修改AlipaySubmit.java中的buildRequest()方法，在其拼接的表单中加入target=“_blank”，让表单提交时在新页面打开public static String buildRequest(Map&lt;String, String&gt; sParaTemp, String strMethod, String strButtonName) {    //待请求参数数组    Map&lt;String, String&gt; sPara = buildRequestPara(sParaTemp);    List&lt;String&gt; keys = new ArrayList&lt;String&gt;(sPara.keySet());    StringBuffer sbHtml = new StringBuffer();    sbHtml.append("&lt;form id=\"alipaysubmit\" name=\"alipaysubmit\" action=\"" + ALIPAY_GATEWAY_NEW                  + "_input_charset=" + AlipayConfig.input_charset + "\" method=\"" + strMethod                  + "\" target=\"_blank\"&gt;");    for (int i = 0; i &lt; keys.size(); i++) {        String name = (String) keys.get(i);        String value = (String) sPara.get(name);        sbHtml.append("&lt;input type=\"hidden\" name=\"" + name + "\" value=\"" + value + "\"/&gt;");    }    //submit按钮控件请不要含有name属性    sbHtml.append("&lt;input type=\"submit\" value=\"" + strButtonName + "\" style=\"display:none;\"&gt;&lt;/form&gt;");    sbHtml.append("&lt;script&gt;document.forms['alipaysubmit'].submit();&lt;/script&gt;");    return sbHtml.toString();}  用户通过支付宝扫描二维码完成支付后，支付宝会主动调用notify_url进行回执          由于回执时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该回执地址一个访问许可，否则会被安全框架屏蔽      @RequestMapping(value = "/ali", method = RequestMethod.POST)@ResponseBodypublic String aliNotify(HttpServletRequest request) {    return orderPayService.aliNotify(request);}  接收并处理支付回执后，必须通知支付宝回执接收成功，否则支付宝会认为回执发送失败，并发送数次通知  支付宝发送异步通知后，如果没有获取到成功回执（返回success），则会按一定规律重发（4m,10m,10m,1h,2h,6h,15h）  接收支付宝的回执信息时，必须进行验签，改操作支付宝已实现，我们只需要调用AlipayNotify.java中的verify()方法即可  验签成功后需要判断操作状态，从回执参数中获取trade_status，参数值为TRADE_SUCCESS即为支付成功  还有一个订单状态是TRADE_FINISHED，该状态表示订单已完成，即超过三个月的退款期限，一旦订单到达这个状态，支付宝会再次调用notify_url进行回执，若业务系统没有退款流程，则无需处理该状态public String aliNotify(HttpServletRequest request) {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 交易状态    String tradeStatus = request.getParameter("trade_status");    // 验签    if (AlipayNotify.verify(getNotifyData(request))) {        // 交易成功        if (tradeStatus.equals("TRADE_SUCCESS")) {            // 更新订单信息            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());        }        return "success";    } else {        return "fail";    }}  处理回执内容，用于验签private Map&lt;String, String&gt; getNotifyData(HttpServletRequest request, String method) throws Exception {    // 获取回执内容    Map requestParams = request.getParameterMap();    // 过滤回执内容    Map&lt;String, String&gt; params = Maps.newHashMap();    for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) {        String name = (String) iter.next();        String[] values = (String[]) requestParams.get(name);        String valueStr = "";        for (int i = 0; i &lt; values.length; i++) {            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";        }        if (method.equals("notify")) {            params.put(name, valueStr);        } else {            params.put(name, new String(valueStr.getBytes("ISO-8859-1"), "utf-8"));        }    }    return params;}  用户通过支付宝扫描二维码完成支付后，在新打开的支付宝窗口会执行return_url进行跳转          由于跳转时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该跳转地址一个访问许可，否则会被安全框架屏蔽      public String aliReturn(HttpServletResponse response, HttpServletRequest request) throws Exception {    orderPayService.aliReturn(response, request);           // 跳转地址会通过输出流的方式关闭新窗口，所以无需返回任何内容    return null;}  接收跳转通知时，同样需要验签，以确保内容的安全性  为防止网络等不可预测原因导致异步回执没能成功接收，所以在接收跳转通知并验签通过以及状态判断成功后，同样需要对订单状态进行更新  如果用户完成支付后立即关闭页面，会导致同步跳转通知无法执行，所以不能完全依赖该通知确认订单状态  如果用户在支付页面扫码生成预下单订单，但并未直接付款，而是前往支付宝订单页重新付款，即使网页端支付页面未关闭，也无法执行该同步跳转通知  通过同步跳转通知更新订单状态，只是一种辅助措施，主要手段还是通过接受异步回执来处理订单状态  由于支付宝的扫码页面是在新窗口打开，在支付完成后并没有存在的必要，即可以通过输出流的方式关闭该窗口public void aliReturn(HttpServletResponse response, HttpServletRequest request) throws IOException {    // 订单号    String orderCode = request.getParameter("out_trade_no");    // 交易状态    String tradeStatus = request.getParameter("trade_status");    // 验签    if (AlipayNotify.verify(getNotifyData(request))) {        if (tradeStatus.equals("TRADE_FINISHED") || tradeStatus.equals("TRADE_SUCCESS")) {            // 更新订单信息            updateOrderInfo(orderCode, OrderPay.aliPay.getCode());            // 页面跳转            response.setContentType("text/html;charset=gb2312");     // 通过输出流关闭窗口            PrintWriter writer = response.getWriter();            writer.println("&lt;html&gt;&lt;head&gt;&lt;title&gt; CLOSE &lt;/title&gt;&lt;/head&gt;");            writer.println("&lt;body&gt;");            writer.println("&lt;script type=\"text/javascript\"&gt;window.close();&lt;/script&gt;");            writer.println("&lt;/body&gt;&lt;/html&gt;");        }    }}  轮询订单状态，实现支付完成后页面自动跳转          由于支付回执是异步的，所以即使捕获到异步回执也无法实现支付页面的自动跳转      所以需要在支付页面打开时设置一个ajax轮询订单状态，一旦订单状态更新，则进行页面跳转      // 页面关闭$(“.modal-header button.close:last”).click(function () {    // 停止轮询    clearInterval(checkTimer);});// 轮询订单状态checkTimer = setInterval(function () {    // 窗口是否打开    if ($(“.order-pay-panel”).length &lt;= 0) {        clearInterval(checkTimer);    }    // 获取订单状态    $.ts.doAction(“/api/order/review/check/“, {        orderId: orderId    }, function () {        // 订单已支付        if (!this.data) {            $.ts.closeWindow();            g_index.loadMainContentWithState(“/order/manage”);        $.ts.toastr.success(“订单已支付成功！”);        }    }, “”, “”, “”);}, 3000);]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> alipay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java微信扫码支付]]></title>
      <url>/java/pay/2017/02/11/Java%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/</url>
      <content type="text"><![CDATA[  以下内容是基于模式二开发在开发之前需要先到微信支付官网注册账号，并获取到以下信息appid:wx1137939101111111公众账号idmch_id:1438111111 商户号key:4Inn0va1eSxOnl1neqsxwuhan1111111密钥send_url:https://api.mch.weixin.qq.com/pay/unifiedorder统一下单APInotify_url:http://127.0.0.1:8080/sop/order/notify/wechat支付成功回调地址官网  微信支付官网  扫码支付开发者文档模式  需要在公众平台后台设置支付回调URL ，用于接收用户扫码后微信支付系统回调的productid和openid  直接调用统一下单API 即可，相对于模式一更为简洁定义接口对象  根据 统一下单接口API 定义四个对象，用于发送和接收数据UnifiedOrderRequest.java 统一下单请求参数-必填项public class UnifiedOrderRequest {    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 随机字符串，32位以内    private String nonce_str;    // 签名，遵循签名算法    private String sign;    // 商品描述，浏览器打开的网站主页title名称-商品概述    private String body;    // 商户订单号，32位以内，不重复    private String out_trade_no;    // 标价金额，单位分    private Integer total_fee;    // 终端ip，填写调用端的ip    private String spbill_create_ip;    // 通知地址，接收支付结果的会掉地址，必须外网可访问    private String notify_url;    // 交易类型，JSAPI--公众号支付、NATIVE--原生扫码支付、APP--app支付    private String trade_type;}UnifiedOrderRequestExt.java 统一下单请求参数-非必填项public class UnifiedOrderRequestExt extends UnifiedOrderRequest {    // 设备号，网页端填写WEB    private String device_info;    // 签名类型，默认MD5    private String sign_type;    // 商品详情，JSON格式    private String detail;    // 附加数据，可作为自定义参数使用    private String attach;    // 标价币种，默认CNY    private String fee_type;    // 交易起始时间，格式为yyyyMMddHHmmss    private String time_start;    // 交易结束时间，最短失效时间必须间隔5分钟    private String time_expire;    // 商品id，trade_type=NATIVE时，必填    private String product_id;    // 指定支付方式，no_credit可限制使用信用卡    private String limit_pay;    // 用户标识,trade_type=JSAPI时，必填    private String openid;}UnifiedOrderResponse.java 统一下单返回参数-必填项public class UnifiedOrderResponse {    // 返回状态码，通信标识，SUCCESS/FAIL    private String return_code;    // 公众账号id    private String appid;    // 商户号    private String mch_id;    // 随机字符串    private String nonce_str;    // 签名    private String sign;    // 业务结果，交易标识，SUCCESS/FAIL    private String result_code;    // 交易类型，JSAPI，NATIVE，APP    private String trade_type;    // 预支付交易会话标识，有效值2小时    private String prepay_id;}UnifiedOrderResponseExt.java 统一下单返回参数-非必填项public class UnifiedOrderResponseExt extends UnifiedOrderResponse {    // 返回信息，非空则表示返回了错误信息    private String return_msg;    // 设备号    private String device_info;    // 错误代码    private String err_code;    // 错误代码描述    private String err_code_des;    // 二维码连接，trade_type=NATIVE时返回    private String code_url;}定义一个标签用于显示二维码  调用统一下单API成功后，会返回一系列XML数据，其中code_url表示返回的预支付交易链接，可将其生成二维码图片&lt;div class="order-pay-panel order-wechat-panel"&gt;    &lt;div class="modal-header"&gt;        &lt;button type="button" class="close" data-dismiss="modal" aria-hidden="true"&gt;×&lt;/button&gt;        &lt;h4 class="modal-title"&gt;            &lt;i class="icon-th-large"&gt;&lt;/i&gt; 微信支付        &lt;/h4&gt;    &lt;/div&gt;    &lt;div class="modal-body"&gt;        &lt;div class="wechat-qrcode-panel margin-bottom-10"&gt;            &lt;img src="${ctx}/api/order/pay/wechat/qrcode?orderId=${order.hexId}"&gt;        &lt;/div&gt;        &lt;div class="wechat-description-panel"&gt;            &lt;p class="text-muted"&gt;使用微信扫描二维码完成支付&lt;/p&gt;            &lt;p class="text-danger"&gt;￥${order.price}&lt;/p&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;根据统一下单API的要求生成订单  将系统内部订单号传入请求参数的out_trade_no中，用于后续操作的唯一标识符  请求参数中的sign是验证参数合法性的唯一标识，需要根据 微信支付签名算法 来生成  使用XStream将对象转换为XML，由于微信的请求参数中大量使用下划线，但下划线在XStream中是关键字，因此需要把下划线转换为双下划线，避免报错private String generateOrderInfo(Long orderId) throws Exception {    // 获取订单信息    OrderDTO order = orderManageService.getOrder(orderId);    // 生成订单    UnifiedOrderRequestExt ext = new UnifiedOrderRequestExt();    ext.setAppid(SOPConstants.WECHAT_PAY_APP_ID);    ext.setMch_id(SOPConstants.WECHAT_PAY_MCH_ID);    ext.setBody("轻实训-" + order.getName());    ext.setOut_trade_no(order.getCode());    ext.setTotal_fee(order.getPrice() * 100);    ext.setSpbill_create_ip(super.getClientIP());    ext.setNotify_url(SOPConstants.WECHAT_PAY_NOTIFY_URL);    ext.setTrade_type("NATIVE");    ext.setProduct_id(order.getHexId());  // 生成32位随机数    ext.setNonce_str(makeNonceStr());  // 签名，按照指定签名算法生成    ext.setSign(makeSign(ext));    // 格式转换为XML    XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));    xStream.alias("xml", UnifiedOrderRequestExt.class);    return xStream.toXML(ext);}  生成32位随机数，方式为当前时间加随机数private String makeNonceStr() {    StringBuffer str = new StringBuffer(DateUtil.getSysDateString("yyyyMMddHHmmssS"));    str.append((new Random().nextInt(900) + 100));    return str.toString();}  拼接签名数据private String makeSign(UnifiedOrderRequestExt ext) throws Exception {    // 根据规则创建可排序的map集合    SortedMap&lt;String, String&gt; signMaps = Maps.newTreeMap();    signMaps.put("appid", ext.getAppid());    signMaps.put("body", ext.getBody());    signMaps.put("mch_id", ext.getMch_id());    signMaps.put("nonce_str", ext.getNonce_str());    signMaps.put("notify_url", ext.getNotify_url());    signMaps.put("out_trade_no", ext.getOut_trade_no());    signMaps.put("spbill_create_ip", ext.getSpbill_create_ip());    signMaps.put("trade_type", ext.getTrade_type());    signMaps.put("total_fee", ext.getTotal_fee().toString());    signMaps.put("product_id", ext.getProduct_id());    // 生成签名    return generateSign(signMaps);}  按照签名算法生成签名private String generateSign(SortedMap&lt;String, String&gt; signMaps) throws Exception {    StringBuffer sb = new StringBuffer();    // 字典序    for (Map.Entry signMap : signMaps.entrySet()) {        String key = (String) signMap.getKey();        String value = (String) signMap.getValue();        // 为空不参与签名、参数名区分大小写        if (null != value &amp;&amp; !"".equals(value) &amp;&amp; !"sign".equals(key) &amp;&amp; !"key".equals(key)) {            sb.append(key + "=" + value + "&amp;");        }    }    // 拼接key    sb.append("key=" + SOPConstants.WECHAT_PAY_KEY);    // MD5加密    return encoderByMd5(sb.toString()).toUpperCase();}调用统一下单API  将生成的订单发送给微信，同时接收微信的返回参数，读取其中的code_url  如果发送的订单信息不符合要求，则会在返回参数中告知问题  订单合法，返回参数中return_code=SUCCESS return_msg=OK result_code=SUCCESS  订单不合法，返回参数中return_code=FAIL return_msg=具体错误原因private String sendHttpRequest(String orderInfo) throws IOException {    // 建立连接    HttpURLConnection conn = (HttpURLConnection) new URL(SOPConstants.WECHAT_PAY_SEND_URL).openConnection();    conn.setRequestMethod("POST");    conn.setDoOutput(true);    // 发送数据    BufferedOutputStream bos = new BufferedOutputStream(conn.getOutputStream());    bos.write(orderInfo.getBytes());    bos.flush();    bos.close();    // 获取数据    BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));    // 接收数据    String line;    StringBuffer str = new StringBuffer();    while ((line = reader.readLine()) != null) {        str.append(line);    }    // XML数据转换为对象    XStream xStream = new XStream(new XppDriver(new XmlFriendlyReplacer("_-", "_")));    xStream.alias("xml", UnifiedOrderResponseExt.class);    UnifiedOrderResponseExt ext = (UnifiedOrderResponseExt) xStream.fromXML(str.toString());    // 判断数据有效性    if (null != ext &amp;&amp; "SUCCESS".equals(ext.getReturn_code()) &amp;&amp; "SUCCESS".equals(ext.getResult_code())) {        return ext.getCode_url();    }    return null;}根据返回的code_url生成二维码图片  二维码的生成采用的是Google的 GitHub - zxing/zxing at zxing-3.0.0@RequestMapping(value = “/wechat/qrcode”, method = RequestMethod.GET)public void wechatQRCode(HttpServletResponse response, @RequestParam("orderId") String orderId) {    try {        // 初始化数据        int width = 240;        int height = 240;        String format = "png";  // 获取二维码链接        String codeUrl = orderPayService.getQRCodeUrl(IdEncoder.decodeId(orderId));        Hashtable htable = new Hashtable();        htable.put(EncodeHintType.CHARACTER_SET, "UTF-8");        // 生成图片        BitMatrix matrix = new MultiFormatWriter().encode(codeUrl, BarcodeFormat.QR_CODE, width, height, htable);        OutputStream out = response.getOutputStream();        // 输出图片        MatrixToImageWriter.writeToStream(matrix, format, out);        out.flush();        out.close();    } catch (Exception e) {        logger.error(e.getMessage(), e);    }}  需要准备的包信息&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;core&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;    &lt;artifactId&gt;javase&lt;/artifactId&gt;    &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;接收回调  用户通过微信扫描二维码并支付成功后，微信会根据之前订单中的notify_url回调地址进行回执  此处提供给微信的回调地址必须是外网可访问的，否则无法正常接收回执信息  由于回执时并没有携带用户信息，所以如果使用了诸如shiro等安全框架的，需要给予该回执地址一个访问许可，否则会被安全框架屏蔽  发送回执是异步进行，由于网络等不确定因素，微信不保证回执一定成功  微信会通过一定的策略定期重启发送通知，通知频率为15/15/30/180/1800/1800/1800/1800/3600，单位：秒  虽然是异步回执，但并不需要采用ajax异步接收的方式来接收数据@RequestMapping(value = "/wechat")public String wechatNotify(HttpServletResponse response, HttpServletRequest request) throws Exception {    orderPayService.notify(response, request);  // 此处的返回值无效，需要在支付页面通过轮询获取支付结果，微信支付本身无法实现自动跳转    return "/redirect:/login";}处理回执内容  数据是通过IO流发送，所以也需要通过IO流接收  微信发送回执用户接收后，需要通过IO流的方式告知微信接收成功，否则微信认为回执失败  接收到回执信息后，最关键是验证签名来确保信息的有效性和安全性，验签的方式和发送订单签名的方式一致  验签成功，且回执信息中result_code=SUCCESS，则表示回执信息有效  从回执信息中可获取到out_trade_no，这是之前发送的用户订单唯一标识符，通过该信息可以继续处理用户订单  所有流程处理完毕后，必须以XML格式编写回执信息，并通过IO流的方式告知微信回执接收成功public void notify(HttpServletResponse response, HttpServletRequest request) throws Exception {    // 读取回执数据    HashMap&lt;String, String&gt; notifyMaps = readNotify(request);    // 回执数据验证    if (notifyMaps == null || notifyMaps.isEmpty()) {        logger.error("未收到回执数据！");        throw new TSharkException("未收到回执数据！");    }    // 挑选数据    SortedMap&lt;String, String&gt; notifySorts = sortNotify(notifyMaps);    // 重新签名    String sign = generateSign(notifySorts);    // 获取回执签名    String notifySign = notifySorts.get("sign").toUpperCase();    // 验证签名    if (!sign.equals(notifySign)) {        logger.error("签名验证失败！");        throw new TSharkException("签名验证失败！");    }    String resXml;    // 验证回执    if ("SUCCESS".equals(notifySorts.get("result_code"))) {        // 更新订单信息        updateOrderInfo(notifySorts.get("out_trade_no"));        // 微信回执        resXml = "&lt;xml&gt;" +                "&lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;" +                "&lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;" +                "&lt;/xml&gt; ";    } else {        resXml = "&lt;xml&gt;" +                "&lt;return_code&gt;&lt;![CDATA[FAIL]]&gt;&lt;/return_code&gt;" +                "&lt;return_msg&gt;&lt;![CDATA[报文为空]]&gt;&lt;/return_msg&gt;" +                "&lt;/xml&gt; ";    }    BufferedOutputStream out = new BufferedOutputStream(response.getOutputStream());    out.write(resXml.getBytes());    out.flush();    out.close();}  从IO流中读取回执信息private HashMap&lt;String, String&gt; readNotify(HttpServletRequest request) throws Exception {    // 读取参数    InputStream inputStream = request.getInputStream();    BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, "UTF-8"));    // 接收数据    String line;    StringBuffer str = new StringBuffer();    while ((line = reader.readLine()) != null) {        str.append(line);    }    reader.close();    inputStream.close();    // XML转换Map    return fromXml(str.toString());}  读取的回执信息时XML格式，需要通过jDom的SAXBuilder解析为Mapprivate HashMap&lt;String, String&gt; fromXml(String xml) throws Exception {    xml = xml.replaceFirst("encoding=\".*\"", "encoding=\"UTF-8\"");    if (null == xml || "".equals(xml)) {        return null;    }    HashMap&lt;String, String&gt; m = Maps.newHashMap();    InputStream in = new ByteArrayInputStream(xml.getBytes("UTF-8"));    SAXBuilder builder = new SAXBuilder();    Document doc = builder.build(in);    Element root = doc.getRootElement();    List list = root.getChildren();    Iterator it = list.iterator();    while (it.hasNext()) {        Element e = (Element) it.next();        String k = e.getName();        String v = "";        List children = e.getChildren();        if (children.isEmpty()) {            v = e.getTextNormalize();        } else {            v = getXmlChildren(children);        }        m.put(k, v);    }    //关闭流    in.close();    return m;}private String getXmlChildren(List children) {    StringBuffer sb = new StringBuffer();    if (!children.isEmpty()) {        Iterator it = children.iterator();        while (it.hasNext()) {            Element e = (Element) it.next();            String name = e.getName();            String value = e.getTextNormalize();            List list = e.getChildren();            sb.append("&lt;" + name + "&gt;");            if (!list.isEmpty()) {                sb.append(getXmlChildren(list));            }            sb.append(value);            sb.append("&lt;/" + name + "&gt;");        }    }    return sb.toString();}轮询订单状态，实现支付完成后页面自动跳转  由于支付回执是异步的，所以即使捕获到异步回执也无法实现支付页面的自动跳转  所以需要在支付页面打开时设置一个ajax轮询订单状态，一旦订单状态更新，则进行页面跳转// 页面关闭$(".modal-header button.close:last").click(function () {    // 停止轮询    clearInterval(checkTimer);});// 轮询订单状态checkTimer = setInterval(function () {    // 窗口是否打开    if ($(".order-pay-panel").length &lt;= 0) {        clearInterval(checkTimer);    }    // 获取订单状态    $.ts.doAction("/api/order/review/check/", {        orderId: orderId    }, function () {        // 订单已支付        if (!this.data) {            $.ts.closeWindow();            g_index.loadMainContentWithState("/order/manage");      $.ts.toastr.success("订单已支付成功！");        }    }, "", "", "");}, 3000);]]></content>
      <categories>
        
          <category> java </category>
        
          <category> pay </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> wechatpay </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java MD5加密]]></title>
      <url>/java/2017/02/09/Java-MD5%E5%8A%A0%E5%AF%86/</url>
      <content type="text"><![CDATA[  md5加密简要算法生成 16 位加密串/** * 利用MD5进行加密 * * @param str 待加密的字符串 * @return 加密后的字符串 */private String EncoderByMd5(String str) throws Exception {	// 生成一个MD5加密计算摘要	MessageDigest md = MessageDigest.getInstance("MD5");	// 计算md5函数	md.update(str.getBytes());	// digest()最后确定返回md5 hash值，返回值为8为字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符	// BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值	return new BigInteger(1, md.digest()).toString(16);}生成 32 位加密串private String md5(String input) {    MessageDigest md = null;    try {        md = MessageDigest.getInstance("MD5");        md.update(input.getBytes());        String md5 = new BigInteger(1, md.digest()).toString(16);        return fillMD5(md5);    } catch (NoSuchAlgorithmException e) {        logger.error("字串加密失败！", e);    }    return null;}/** * 加密串补齐32位 */private String fillMD5(String md5) {    return md5.length() == 32 ? md5 : fillMD5("0" + md5);}]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> md5 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis新增返回id]]></title>
      <url>/java/mybatis/2017/02/08/MyBatis%E6%96%B0%E5%A2%9E%E8%BF%94%E5%9B%9Eid/</url>
      <content type="text"><![CDATA[  新增一条数据到数据库，并返回该数据的id&lt;insert id="saveSendMessage" keyColumn="id" keyProperty="id" useGeneratedKeys="true" parameterType="SendMessageDTO"&gt;	...&lt;/insert&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> mybatis </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> mybatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[对象反射赋值]]></title>
      <url>/java/relfect/2017/01/20/%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%B0%84%E8%B5%8B%E5%80%BC/</url>
      <content type="text"><![CDATA[  在不确定对象字段及内容的前提下，为对象赋值的解决方案通常是反射赋值实现方式// 获取当前会员对象Class&lt;MemberDTO&gt; member = (Class&lt;MemberDTO&gt;) super.getMember().getClass();// 获取所有字段Field[] fileds = member.getDeclaredFields();// 遍历字段找到与当前修改字段相符合的字段for (Field field : fileds) {	// ** 获取私有字段的操作权限	field.setAccessible(true);	if (field.getName().equals(name)) {		// 找到字段对应 set 方法		PropertyDescriptor pd = new PropertyDescriptor(field.getName(), member);		Method method = pd.getWriteMethod();		// 传入当前对象，并赋值		method.invoke(super.getMember(), value);		break;	}}]]></content>
      <categories>
        
          <category> java </category>
        
          <category> relfect </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> relfect </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java实现颜色随机]]></title>
      <url>/java/2017/01/20/Java%E5%AE%9E%E7%8E%B0%E9%A2%9C%E8%89%B2%E9%9A%8F%E6%9C%BA/</url>
      <content type="text"><![CDATA[  通过随机拼接rgb编码的方式，获取随机的颜色码实现方式String r, g, b;// 定义随机数	Random random = new Random();	// 获取编码r = Integer.toHexString(random.nextInt(256)).toUpperCase();g = Integer.toHexString(random.nextInt(256)).toUpperCase();b = Integer.toHexString(random.nextInt(256)).toUpperCase();	// 编码有效性控制r = r.length() == 1 ? "0" + r : r;g = g.length() == 1 ? "0" + g : g;b = b.length() == 1 ? "0" + b : b;	// 拼接return r + g + b;]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> color </tag>
        
          <tag> random </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[判断String是否为数字]]></title>
      <url>/java/2017/01/12/%E5%88%A4%E6%96%ADString%E6%98%AF%E5%90%A6%E4%B8%BA%E6%95%B0%E5%AD%97/</url>
      <content type="text"><![CDATA[  解决思路是通过正则表达式匹配字符串内容是否全部为数字实现方式// 数字0-9出现零到多次Pattern pattern = Pattern.compile("[0-9]*");Matcher isNum = pattern.matcher(str);if (isNum.matches()) {	// 数字} else {	// 非数字}]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> string </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Zip4j解压文件]]></title>
      <url>/java/2017/01/04/Zip4j%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6/</url>
      <content type="text"><![CDATA[  使用 zip4j 可以快速对文件进行解压缩处理官网zip4j特性  支持Zip文件的创建、添加、解压、更新、移除  可读写有密码保护的Zip文件  支持AES 128/256算法加密  支持标准Zip算法加密  支持Zip64格式  支持分块Zip文件的创建和解压  支持Unicode编码的文件名  支持进度监控添加Maven依赖&lt;dependency&gt;    &lt;groupId&gt;net.lingala.zip4j&lt;/groupId&gt;    &lt;artifactId&gt;zip4j&lt;/artifactId&gt;    &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;解压实现// 获取Zip文件ZipFile zipFile = new ZipFile(file);// 指定文件名编码zipFile.setFileNameCharset("GBK");// 验证文件有效性if (!zipFile.isValidZipFile()) {    responseData.setError("压缩文件已损坏！");    return;}// 解压目录File fileDir = new File(newFile);// 目录不存在则创建if (fileDir.isDirectory() &amp;&amp; !fileDir.exists()) {    fileDir.mkdir();}// 解压zipFile.extractAll(newFile);]]></content>
      <categories>
        
          <category> java </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> zip </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[web.xml组件加载顺序]]></title>
      <url>/java/springmvc/tomcat/2016/12/29/web.xml%E7%BB%84%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</url>
      <content type="text"><![CDATA[  context-param &gt; listener &gt; filter &gt; servlet 其中同类则按编写顺序执行常用组件解析&lt;web-app xmlns="" version=""&gt;	&lt;!-- 应用名称 --&gt;	&lt;display-name&gt;Bear&lt;/display-name&gt;	&lt;!-- 应用描述 --&gt;	&lt;description&gt;&lt;/description&gt;	&lt;!-- 应用范围内的初始化参数 --&gt;	&lt;context-param&gt;		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;		&lt;!-- 加载多个spring配置文件 --&gt;		&lt;param-value&gt;classpath*:/applicationContext.xml&lt;/param-value&gt;	&lt;/context-param&gt;	&lt;!-- 加载事件监听器，在建立、修改、删除会话或servlet环境时得到通知 --&gt;	&lt;listener&gt;		&lt;!-- 定义Spring监听器 --&gt;		&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;	&lt;/listener&gt;	&lt;!-- 加载过滤器，将一个名字与一个实现了javax.servlet.Filter接口的类关联 --&gt;	&lt;filter&gt;		&lt;!-- 过滤器名称 --&gt;		&lt;filter-name&gt;&lt;/filter-name&gt;		&lt;!-- 过滤器路径 --&gt;		&lt;filter-class&gt;&lt;/filter-class&gt;		&lt;!-- 初始化参数 --&gt;		&lt;init-param&gt;			&lt;!-- 参数名称 --&gt;			&lt;param-name&gt;&lt;/param-name&gt;			&lt;!-- 参数值 --&gt;			&lt;param-value&gt;&lt;/param-value&gt;		&lt;/init-param&gt;	&lt;/filter&gt;	&lt;!-- 如果命名了过滤器，则需要将其与一个或多个servlet或jsp页面关联 --&gt;	&lt;filter-mapping&gt;		&lt;!-- 过滤器名称 --&gt;		&lt;filter-name&gt;&lt;/filter-name&gt;		&lt;!-- 应用范围，所有 --&gt;		&lt;url-pattern&gt;/*&lt;/ulr-pattern&gt;	&lt;/filter-mapping&gt;	&lt;!-- 加载servlet，在向servlet或jsp页面指定初始化参数或URL时，必须先命名servlet或jsp页面 --&gt;	&lt;servlet&gt;		&lt;!-- servlet名称 --&gt;		&lt;servlet-name&gt;springServlet&lt;/servlet-name&gt;		&lt;!-- servlet路径 --&gt;		&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;		&lt;!-- 初始化参数 --&gt;		&lt;init-param&gt;			&lt;!-- 参数名称 --&gt;			&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;			&lt;!-- 参数值 --&gt;			&lt;param-value&gt;classpath*:spring-mvc.xml&lt;/param-value&gt;		&lt;/init-param&gt;		&lt;!-- 加载优先级 --&gt;		&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;	&lt;/servlet&gt;	&lt;!-- 为指定的servlet提供缺省URL --&gt;	&lt;servlet-mapping&gt;		&lt;!-- servlet名称 --&gt;		&lt;servlet-name&gt;springServlet&lt;/servlet-name&gt;		&lt;!-- 应用范围 --&gt;		&lt;url-pattern&gt;/*&lt;/url-pattern&gt;	&lt;/servlet-mapping&gt;	&lt;!-- 会话配置 --&gt;	&lt;session-config&gt;		&lt;!-- 定义会话超时时间，会员未访问时间达到改配置，则会被服务器抛弃以节省内存 --&gt;		&lt;session-timeout&gt;30&lt;/session-timeout&gt;	&lt;/session-config&gt;	&lt;!-- 为特殊文件分配特定mime类型 --&gt;	&lt;mime-mapping&gt;&lt;/mime-mapping&gt;	&lt;!-- 应用首页入口文件列表 --&gt;	&lt;welcome-file-list&gt;&lt;/welcome-file-list&gt;	&lt;!-- 在返回特定http状态码或特定类型的异常抛出时，显示的页面 --&gt;	&lt;error-page&gt;		&lt;!-- 状态码 --&gt;		&lt;error-code&gt;404&lt;/error-code&gt;		&lt;!-- 显示页面 --&gt;		&lt;location&gt;404.jsp&lt;/location&gt;	&lt;/error-page&gt;	&lt;!-- 为标记库描述文件指定别名，可更改TLD文件的位置 ——&gt;	&lt;taglib&gt;&lt;/taglib&gt;	&lt;!-- 声明与资源相关的管理对象 --&gt; 	&lt;resource-env-ref&gt;&lt;/resource-env-ref&gt;	&lt;!-- 声明资源工厂使用的外部资源 --&gt;	&lt;resource-ref&gt;&lt;/resource-ref&gt;	&lt;!-- 指定待保护的URL，与location-config联合使用 --&gt;	&lt;security-constraint&gt;&lt;/security-constraint&gt;	&lt;!-- 指定服务器如何给试图访问受保护页面的用户授权，与security-constraint联合使用 --&gt;	&lt;login-config&gt;&lt;/login-config&gt;	&lt;!-- 安全角色列表 --&gt;	&lt;security-role&gt;&lt;/security-role&gt;	&lt;!-- 声明应用环境项 --&gt;	&lt;env-entry&gt;&lt;/env-entry&gt;&lt;/web-app&gt;]]></content>
      <categories>
        
          <category> java </category>
        
          <category> springmvc </category>
        
          <category> tomcat </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> springmvc </tag>
        
          <tag> tomcat </tag>
        
          <tag> server </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
